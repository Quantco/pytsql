
// Generated from tsql.g4 by ANTLR 4.9.2


#include "tsqlVisitor.h"

#include "tsqlParser.h"


using namespace antlrcpp;
using namespace antlr4;

tsqlParser::tsqlParser(TokenStream *input) : Parser(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

tsqlParser::~tsqlParser() {
  delete _interpreter;
}

std::string tsqlParser::getGrammarFileName() const {
  return "tsql.g4";
}

const std::vector<std::string>& tsqlParser::getRuleNames() const {
  return _ruleNames;
}

dfa::Vocabulary& tsqlParser::getVocabulary() const {
  return _vocabulary;
}


//----------------- Tsql_fileContext ------------------------------------------------------------------

tsqlParser::Tsql_fileContext::Tsql_fileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Tsql_fileContext::EOF() {
  return getToken(tsqlParser::EOF, 0);
}

std::vector<tsqlParser::BatchContext *> tsqlParser::Tsql_fileContext::batch() {
  return getRuleContexts<tsqlParser::BatchContext>();
}

tsqlParser::BatchContext* tsqlParser::Tsql_fileContext::batch(size_t i) {
  return getRuleContext<tsqlParser::BatchContext>(i);
}


size_t tsqlParser::Tsql_fileContext::getRuleIndex() const {
  return tsqlParser::RuleTsql_file;
}


antlrcpp::Any tsqlParser::Tsql_fileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTsql_file(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Tsql_fileContext* tsqlParser::tsql_file() {
  Tsql_fileContext *_localctx = _tracker.createInstance<Tsql_fileContext>(_ctx, getState());
  enterRule(_localctx, 0, tsqlParser::RuleTsql_file);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(415);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << tsqlParser::ALTER)
      | (1ULL << tsqlParser::BEGIN)
      | (1ULL << tsqlParser::BREAK)
      | (1ULL << tsqlParser::CLOSE)
      | (1ULL << tsqlParser::COMMIT)
      | (1ULL << tsqlParser::CONTINUE)
      | (1ULL << tsqlParser::CREATE)
      | (1ULL << tsqlParser::DEALLOCATE)
      | (1ULL << tsqlParser::DECLARE)
      | (1ULL << tsqlParser::DELETE)
      | (1ULL << tsqlParser::DROP)
      | (1ULL << tsqlParser::EXECUTE))) != 0) || ((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & ((1ULL << (tsqlParser::FETCH - 68))
      | (1ULL << (tsqlParser::FORCESEEK - 68))
      | (1ULL << (tsqlParser::GOTO - 68))
      | (1ULL << (tsqlParser::GRANT - 68))
      | (1ULL << (tsqlParser::IF - 68))
      | (1ULL << (tsqlParser::INSERT - 68))
      | (1ULL << (tsqlParser::NEXT - 68))
      | (1ULL << (tsqlParser::NUMERIC - 68))
      | (1ULL << (tsqlParser::OPEN - 68)))) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 136)) & ((1ULL << (tsqlParser::PRINT - 136))
      | (1ULL << (tsqlParser::RAISERROR - 136))
      | (1ULL << (tsqlParser::RETURN - 136))
      | (1ULL << (tsqlParser::REVERT - 136))
      | (1ULL << (tsqlParser::ROLLBACK - 136))
      | (1ULL << (tsqlParser::SAVE - 136))
      | (1ULL << (tsqlParser::SELECT - 136))
      | (1ULL << (tsqlParser::SET - 136))
      | (1ULL << (tsqlParser::UPDATE - 136))
      | (1ULL << (tsqlParser::USE - 136))
      | (1ULL << (tsqlParser::VALUE - 136))
      | (1ULL << (tsqlParser::WAITFOR - 136)))) != 0) || ((((_la - 202) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 202)) & ((1ULL << (tsqlParser::WHILE - 202))
      | (1ULL << (tsqlParser::WITH - 202))
      | (1ULL << (tsqlParser::ABSOLUTE - 202))
      | (1ULL << (tsqlParser::APPLY - 202))
      | (1ULL << (tsqlParser::AUTO - 202))
      | (1ULL << (tsqlParser::AVG - 202))
      | (1ULL << (tsqlParser::BASE64 - 202))
      | (1ULL << (tsqlParser::CALLER - 202))
      | (1ULL << (tsqlParser::CAST - 202))
      | (1ULL << (tsqlParser::CATCH - 202))
      | (1ULL << (tsqlParser::CHECKSUM_AGG - 202))
      | (1ULL << (tsqlParser::COMMITTED - 202))
      | (1ULL << (tsqlParser::CONCAT - 202))
      | (1ULL << (tsqlParser::CONTROL - 202))
      | (1ULL << (tsqlParser::COOKIE - 202))
      | (1ULL << (tsqlParser::COUNT - 202))
      | (1ULL << (tsqlParser::COUNT_BIG - 202))
      | (1ULL << (tsqlParser::DATE - 202))
      | (1ULL << (tsqlParser::DELAY - 202))
      | (1ULL << (tsqlParser::DELETED - 202))
      | (1ULL << (tsqlParser::DENSE_RANK - 202)))) != 0) || ((((_la - 266) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 266)) & ((1ULL << (tsqlParser::DISABLE - 266))
      | (1ULL << (tsqlParser::DYNAMIC - 266))
      | (1ULL << (tsqlParser::ENCRYPTION - 266))
      | (1ULL << (tsqlParser::EXIST - 266))
      | (1ULL << (tsqlParser::EXPAND - 266))
      | (1ULL << (tsqlParser::FAST - 266))
      | (1ULL << (tsqlParser::FAST_FORWARD - 266))
      | (1ULL << (tsqlParser::FIRST - 266))
      | (1ULL << (tsqlParser::FIRST_VALUE - 266))
      | (1ULL << (tsqlParser::FOLLOWING - 266))
      | (1ULL << (tsqlParser::FORCE - 266))
      | (1ULL << (tsqlParser::FORCED - 266))
      | (1ULL << (tsqlParser::FORWARD_ONLY - 266))
      | (1ULL << (tsqlParser::FULLSCAN - 266))
      | (1ULL << (tsqlParser::GLOBAL - 266))
      | (1ULL << (tsqlParser::GO - 266))
      | (1ULL << (tsqlParser::GROUPING - 266))
      | (1ULL << (tsqlParser::GROUPING_ID - 266))
      | (1ULL << (tsqlParser::HASH - 266))
      | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 266))
      | (1ULL << (tsqlParser::IMPERSONATE - 266))
      | (1ULL << (tsqlParser::INSENSITIVE - 266))
      | (1ULL << (tsqlParser::INSERTED - 266))
      | (1ULL << (tsqlParser::ISOLATION - 266))
      | (1ULL << (tsqlParser::IO - 266))
      | (1ULL << (tsqlParser::KEEP - 266))
      | (1ULL << (tsqlParser::KEEPFIXED - 266))
      | (1ULL << (tsqlParser::KEYSET - 266))
      | (1ULL << (tsqlParser::LAG - 266))
      | (1ULL << (tsqlParser::LAST - 266))
      | (1ULL << (tsqlParser::LAST_VALUE - 266))
      | (1ULL << (tsqlParser::LEAD - 266))
      | (1ULL << (tsqlParser::LEVEL - 266))
      | (1ULL << (tsqlParser::LOCAL - 266))
      | (1ULL << (tsqlParser::LOCK_ESCALATION - 266))
      | (1ULL << (tsqlParser::LOGIN - 266))
      | (1ULL << (tsqlParser::LOOP - 266))
      | (1ULL << (tsqlParser::MARK - 266))
      | (1ULL << (tsqlParser::MAX - 266))
      | (1ULL << (tsqlParser::MAXDOP - 266))
      | (1ULL << (tsqlParser::MAXRECURSION - 266))
      | (1ULL << (tsqlParser::MIN - 266)))) != 0) || ((((_la - 332) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 332)) & ((1ULL << (tsqlParser::MODIFY - 332))
      | (1ULL << (tsqlParser::NAME - 332))
      | (1ULL << (tsqlParser::NOCOUNT - 332))
      | (1ULL << (tsqlParser::NODES - 332))
      | (1ULL << (tsqlParser::NOEXPAND - 332))
      | (1ULL << (tsqlParser::NORECOMPUTE - 332))
      | (1ULL << (tsqlParser::NTILE - 332))
      | (1ULL << (tsqlParser::NUMBER - 332))
      | (1ULL << (tsqlParser::OFFSET - 332))
      | (1ULL << (tsqlParser::ONLINE - 332))
      | (1ULL << (tsqlParser::ONLY - 332))
      | (1ULL << (tsqlParser::OPTIMISTIC - 332))
      | (1ULL << (tsqlParser::OPTIMIZE - 332))
      | (1ULL << (tsqlParser::OUT - 332))
      | (1ULL << (tsqlParser::OUTPUT - 332))
      | (1ULL << (tsqlParser::OWNER - 332))
      | (1ULL << (tsqlParser::PARAMETERIZATION - 332))
      | (1ULL << (tsqlParser::PARTITION - 332))
      | (1ULL << (tsqlParser::PATH - 332))
      | (1ULL << (tsqlParser::PRECEDING - 332))
      | (1ULL << (tsqlParser::PRIOR - 332))
      | (1ULL << (tsqlParser::PRIVILEGES - 332))
      | (1ULL << (tsqlParser::QUERY - 332))
      | (1ULL << (tsqlParser::RANGE - 332))
      | (1ULL << (tsqlParser::RANK - 332))
      | (1ULL << (tsqlParser::READONLY - 332))
      | (1ULL << (tsqlParser::READ_ONLY - 332))
      | (1ULL << (tsqlParser::RECOMPILE - 332))
      | (1ULL << (tsqlParser::RELATIVE - 332))
      | (1ULL << (tsqlParser::REMOTE - 332))
      | (1ULL << (tsqlParser::REPEATABLE - 332))
      | (1ULL << (tsqlParser::ROBUST - 332))
      | (1ULL << (tsqlParser::ROOT - 332))
      | (1ULL << (tsqlParser::ROW - 332))
      | (1ULL << (tsqlParser::ROWGUID - 332))
      | (1ULL << (tsqlParser::ROWS - 332))
      | (1ULL << (tsqlParser::ROW_NUMBER - 332))
      | (1ULL << (tsqlParser::SAMPLE - 332))
      | (1ULL << (tsqlParser::SCHEMABINDING - 332))
      | (1ULL << (tsqlParser::SCROLL - 332))
      | (1ULL << (tsqlParser::SCROLL_LOCKS - 332))
      | (1ULL << (tsqlParser::SELF - 332))
      | (1ULL << (tsqlParser::SERIALIZABLE - 332)))) != 0) || ((((_la - 397) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 397)) & ((1ULL << (tsqlParser::SIMPLE - 397))
      | (1ULL << (tsqlParser::SIZE - 397))
      | (1ULL << (tsqlParser::SNAPSHOT - 397))
      | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 397))
      | (1ULL << (tsqlParser::STATIC - 397))
      | (1ULL << (tsqlParser::STATS_STREAM - 397))
      | (1ULL << (tsqlParser::STDEV - 397))
      | (1ULL << (tsqlParser::STDEVP - 397))
      | (1ULL << (tsqlParser::SUM - 397))
      | (1ULL << (tsqlParser::TEXTIMAGE_ON - 397))
      | (1ULL << (tsqlParser::THROW - 397))
      | (1ULL << (tsqlParser::TIES - 397))
      | (1ULL << (tsqlParser::TIME - 397))
      | (1ULL << (tsqlParser::TRY - 397))
      | (1ULL << (tsqlParser::TYPE - 397))
      | (1ULL << (tsqlParser::TYPE_WARNING - 397))
      | (1ULL << (tsqlParser::UNBOUNDED - 397))
      | (1ULL << (tsqlParser::UNCOMMITTED - 397))
      | (1ULL << (tsqlParser::UNKNOWN - 397))
      | (1ULL << (tsqlParser::USING - 397))
      | (1ULL << (tsqlParser::VAR - 397))
      | (1ULL << (tsqlParser::VARP - 397))
      | (1ULL << (tsqlParser::VIEWS - 397))
      | (1ULL << (tsqlParser::VIEW_METADATA - 397))
      | (1ULL << (tsqlParser::WORK - 397))
      | (1ULL << (tsqlParser::XML - 397))
      | (1ULL << (tsqlParser::XMLNAMESPACES - 397))
      | (1ULL << (tsqlParser::ZONE - 397))
      | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 397))
      | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 397))
      | (1ULL << (tsqlParser::ID - 397)))) != 0) || _la == tsqlParser::LR_BRACKET) {
      setState(412);
      batch();
      setState(417);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(418);
    match(tsqlParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BatchContext ------------------------------------------------------------------

tsqlParser::BatchContext::BatchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Sql_clausesContext* tsqlParser::BatchContext::sql_clauses() {
  return getRuleContext<tsqlParser::Sql_clausesContext>(0);
}

std::vector<tsqlParser::Go_statementContext *> tsqlParser::BatchContext::go_statement() {
  return getRuleContexts<tsqlParser::Go_statementContext>();
}

tsqlParser::Go_statementContext* tsqlParser::BatchContext::go_statement(size_t i) {
  return getRuleContext<tsqlParser::Go_statementContext>(i);
}


size_t tsqlParser::BatchContext::getRuleIndex() const {
  return tsqlParser::RuleBatch;
}


antlrcpp::Any tsqlParser::BatchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBatch(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::BatchContext* tsqlParser::batch() {
  BatchContext *_localctx = _tracker.createInstance<BatchContext>(_ctx, getState());
  enterRule(_localctx, 2, tsqlParser::RuleBatch);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(421);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::GO) {
      setState(420);
      go_statement();
    }
    setState(423);
    sql_clauses();
    setState(425);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      setState(424);
      go_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_clausesContext ------------------------------------------------------------------

tsqlParser::Sql_clausesContext::Sql_clausesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::Sql_clauseContext *> tsqlParser::Sql_clausesContext::sql_clause() {
  return getRuleContexts<tsqlParser::Sql_clauseContext>();
}

tsqlParser::Sql_clauseContext* tsqlParser::Sql_clausesContext::sql_clause(size_t i) {
  return getRuleContext<tsqlParser::Sql_clauseContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Sql_clausesContext::SEMI() {
  return getTokens(tsqlParser::SEMI);
}

tree::TerminalNode* tsqlParser::Sql_clausesContext::SEMI(size_t i) {
  return getToken(tsqlParser::SEMI, i);
}


size_t tsqlParser::Sql_clausesContext::getRuleIndex() const {
  return tsqlParser::RuleSql_clauses;
}


antlrcpp::Any tsqlParser::Sql_clausesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSql_clauses(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Sql_clausesContext* tsqlParser::sql_clauses() {
  Sql_clausesContext *_localctx = _tracker.createInstance<Sql_clausesContext>(_ctx, getState());
  enterRule(_localctx, 4, tsqlParser::RuleSql_clauses);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(431); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(427);
              sql_clause();
              setState(429);
              _errHandler->sync(this);

              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
              case 1: {
                setState(428);
                match(tsqlParser::SEMI);
                break;
              }

              default:
                break;
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(433); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_clauseContext ------------------------------------------------------------------

tsqlParser::Sql_clauseContext::Sql_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Dml_clauseContext* tsqlParser::Sql_clauseContext::dml_clause() {
  return getRuleContext<tsqlParser::Dml_clauseContext>(0);
}

tsqlParser::Ddl_clauseContext* tsqlParser::Sql_clauseContext::ddl_clause() {
  return getRuleContext<tsqlParser::Ddl_clauseContext>(0);
}

tsqlParser::Cfl_statementContext* tsqlParser::Sql_clauseContext::cfl_statement() {
  return getRuleContext<tsqlParser::Cfl_statementContext>(0);
}

tsqlParser::Another_statementContext* tsqlParser::Sql_clauseContext::another_statement() {
  return getRuleContext<tsqlParser::Another_statementContext>(0);
}

tsqlParser::Cfl_clauseContext* tsqlParser::Sql_clauseContext::cfl_clause() {
  return getRuleContext<tsqlParser::Cfl_clauseContext>(0);
}

tsqlParser::Declare_statementContext* tsqlParser::Sql_clauseContext::declare_statement() {
  return getRuleContext<tsqlParser::Declare_statementContext>(0);
}

tsqlParser::Print_statementContext* tsqlParser::Sql_clauseContext::print_statement() {
  return getRuleContext<tsqlParser::Print_statementContext>(0);
}


size_t tsqlParser::Sql_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleSql_clause;
}


antlrcpp::Any tsqlParser::Sql_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSql_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Sql_clauseContext* tsqlParser::sql_clause() {
  Sql_clauseContext *_localctx = _tracker.createInstance<Sql_clauseContext>(_ctx, getState());
  enterRule(_localctx, 6, tsqlParser::RuleSql_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(442);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(435);
      dml_clause();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(436);
      ddl_clause();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(437);
      cfl_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(438);
      another_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(439);
      cfl_clause();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(440);
      declare_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(441);
      print_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dml_clauseContext ------------------------------------------------------------------

tsqlParser::Dml_clauseContext::Dml_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Delete_statementContext* tsqlParser::Dml_clauseContext::delete_statement() {
  return getRuleContext<tsqlParser::Delete_statementContext>(0);
}

tsqlParser::Insert_statementContext* tsqlParser::Dml_clauseContext::insert_statement() {
  return getRuleContext<tsqlParser::Insert_statementContext>(0);
}

tsqlParser::Select_statementContext* tsqlParser::Dml_clauseContext::select_statement() {
  return getRuleContext<tsqlParser::Select_statementContext>(0);
}

tsqlParser::Update_statementContext* tsqlParser::Dml_clauseContext::update_statement() {
  return getRuleContext<tsqlParser::Update_statementContext>(0);
}


size_t tsqlParser::Dml_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleDml_clause;
}


antlrcpp::Any tsqlParser::Dml_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDml_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Dml_clauseContext* tsqlParser::dml_clause() {
  Dml_clauseContext *_localctx = _tracker.createInstance<Dml_clauseContext>(_ctx, getState());
  enterRule(_localctx, 8, tsqlParser::RuleDml_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(448);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(444);
      delete_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(445);
      insert_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(446);
      select_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(447);
      update_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ddl_clauseContext ------------------------------------------------------------------

tsqlParser::Ddl_clauseContext::Ddl_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Create_databaseContext* tsqlParser::Ddl_clauseContext::create_database() {
  return getRuleContext<tsqlParser::Create_databaseContext>(0);
}

tsqlParser::Create_indexContext* tsqlParser::Ddl_clauseContext::create_index() {
  return getRuleContext<tsqlParser::Create_indexContext>(0);
}

tsqlParser::Create_or_alter_functionContext* tsqlParser::Ddl_clauseContext::create_or_alter_function() {
  return getRuleContext<tsqlParser::Create_or_alter_functionContext>(0);
}

tsqlParser::Create_or_alter_procedureContext* tsqlParser::Ddl_clauseContext::create_or_alter_procedure() {
  return getRuleContext<tsqlParser::Create_or_alter_procedureContext>(0);
}

tsqlParser::Create_statisticsContext* tsqlParser::Ddl_clauseContext::create_statistics() {
  return getRuleContext<tsqlParser::Create_statisticsContext>(0);
}

tsqlParser::Create_schemaContext* tsqlParser::Ddl_clauseContext::create_schema() {
  return getRuleContext<tsqlParser::Create_schemaContext>(0);
}

tsqlParser::Create_synonymContext* tsqlParser::Ddl_clauseContext::create_synonym() {
  return getRuleContext<tsqlParser::Create_synonymContext>(0);
}

tsqlParser::Create_tableContext* tsqlParser::Ddl_clauseContext::create_table() {
  return getRuleContext<tsqlParser::Create_tableContext>(0);
}

tsqlParser::Create_typeContext* tsqlParser::Ddl_clauseContext::create_type() {
  return getRuleContext<tsqlParser::Create_typeContext>(0);
}

tsqlParser::Create_viewContext* tsqlParser::Ddl_clauseContext::create_view() {
  return getRuleContext<tsqlParser::Create_viewContext>(0);
}

tsqlParser::Alter_tableContext* tsqlParser::Ddl_clauseContext::alter_table() {
  return getRuleContext<tsqlParser::Alter_tableContext>(0);
}

tsqlParser::Alter_databaseContext* tsqlParser::Ddl_clauseContext::alter_database() {
  return getRuleContext<tsqlParser::Alter_databaseContext>(0);
}

tsqlParser::Drop_indexContext* tsqlParser::Ddl_clauseContext::drop_index() {
  return getRuleContext<tsqlParser::Drop_indexContext>(0);
}

tsqlParser::Drop_procedureContext* tsqlParser::Ddl_clauseContext::drop_procedure() {
  return getRuleContext<tsqlParser::Drop_procedureContext>(0);
}

tsqlParser::Drop_statisticsContext* tsqlParser::Ddl_clauseContext::drop_statistics() {
  return getRuleContext<tsqlParser::Drop_statisticsContext>(0);
}

tsqlParser::Drop_synonymContext* tsqlParser::Ddl_clauseContext::drop_synonym() {
  return getRuleContext<tsqlParser::Drop_synonymContext>(0);
}

tsqlParser::Drop_tableContext* tsqlParser::Ddl_clauseContext::drop_table() {
  return getRuleContext<tsqlParser::Drop_tableContext>(0);
}

tsqlParser::Drop_typeContext* tsqlParser::Ddl_clauseContext::drop_type() {
  return getRuleContext<tsqlParser::Drop_typeContext>(0);
}

tsqlParser::Drop_viewContext* tsqlParser::Ddl_clauseContext::drop_view() {
  return getRuleContext<tsqlParser::Drop_viewContext>(0);
}

tsqlParser::Drop_databaseContext* tsqlParser::Ddl_clauseContext::drop_database() {
  return getRuleContext<tsqlParser::Drop_databaseContext>(0);
}

tsqlParser::Drop_schemaContext* tsqlParser::Ddl_clauseContext::drop_schema() {
  return getRuleContext<tsqlParser::Drop_schemaContext>(0);
}


size_t tsqlParser::Ddl_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleDdl_clause;
}


antlrcpp::Any tsqlParser::Ddl_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDdl_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Ddl_clauseContext* tsqlParser::ddl_clause() {
  Ddl_clauseContext *_localctx = _tracker.createInstance<Ddl_clauseContext>(_ctx, getState());
  enterRule(_localctx, 10, tsqlParser::RuleDdl_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(471);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(450);
      create_database();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(451);
      create_index();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(452);
      create_or_alter_function();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(453);
      create_or_alter_procedure();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(454);
      create_statistics();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(455);
      create_schema();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(456);
      create_synonym();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(457);
      create_table();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(458);
      create_type();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(459);
      create_view();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(460);
      alter_table();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(461);
      alter_database();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(462);
      drop_index();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(463);
      drop_procedure();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(464);
      drop_statistics();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(465);
      drop_synonym();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(466);
      drop_table();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(467);
      drop_type();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(468);
      drop_view();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(469);
      drop_database();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(470);
      drop_schema();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cfl_statementContext ------------------------------------------------------------------

tsqlParser::Cfl_statementContext::Cfl_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::If_statementContext* tsqlParser::Cfl_statementContext::if_statement() {
  return getRuleContext<tsqlParser::If_statementContext>(0);
}

tsqlParser::Try_catch_statementContext* tsqlParser::Cfl_statementContext::try_catch_statement() {
  return getRuleContext<tsqlParser::Try_catch_statementContext>(0);
}

tsqlParser::Waitfor_statementContext* tsqlParser::Cfl_statementContext::waitfor_statement() {
  return getRuleContext<tsqlParser::Waitfor_statementContext>(0);
}

tsqlParser::While_statementContext* tsqlParser::Cfl_statementContext::while_statement() {
  return getRuleContext<tsqlParser::While_statementContext>(0);
}


size_t tsqlParser::Cfl_statementContext::getRuleIndex() const {
  return tsqlParser::RuleCfl_statement;
}


antlrcpp::Any tsqlParser::Cfl_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCfl_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Cfl_statementContext* tsqlParser::cfl_statement() {
  Cfl_statementContext *_localctx = _tracker.createInstance<Cfl_statementContext>(_ctx, getState());
  enterRule(_localctx, 12, tsqlParser::RuleCfl_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(477);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::IF: {
        enterOuterAlt(_localctx, 1);
        setState(473);
        if_statement();
        break;
      }

      case tsqlParser::BEGIN: {
        enterOuterAlt(_localctx, 2);
        setState(474);
        try_catch_statement();
        break;
      }

      case tsqlParser::WAITFOR: {
        enterOuterAlt(_localctx, 3);
        setState(475);
        waitfor_statement();
        break;
      }

      case tsqlParser::WHILE: {
        enterOuterAlt(_localctx, 4);
        setState(476);
        while_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cfl_clauseContext ------------------------------------------------------------------

tsqlParser::Cfl_clauseContext::Cfl_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Block_statementContext* tsqlParser::Cfl_clauseContext::block_statement() {
  return getRuleContext<tsqlParser::Block_statementContext>(0);
}

tsqlParser::Break_statementContext* tsqlParser::Cfl_clauseContext::break_statement() {
  return getRuleContext<tsqlParser::Break_statementContext>(0);
}

tsqlParser::Continue_statementContext* tsqlParser::Cfl_clauseContext::continue_statement() {
  return getRuleContext<tsqlParser::Continue_statementContext>(0);
}

tsqlParser::Goto_statementContext* tsqlParser::Cfl_clauseContext::goto_statement() {
  return getRuleContext<tsqlParser::Goto_statementContext>(0);
}

tsqlParser::Return_statementContext* tsqlParser::Cfl_clauseContext::return_statement() {
  return getRuleContext<tsqlParser::Return_statementContext>(0);
}

tsqlParser::Throw_statementContext* tsqlParser::Cfl_clauseContext::throw_statement() {
  return getRuleContext<tsqlParser::Throw_statementContext>(0);
}

tsqlParser::Raiseerror_statementContext* tsqlParser::Cfl_clauseContext::raiseerror_statement() {
  return getRuleContext<tsqlParser::Raiseerror_statementContext>(0);
}


size_t tsqlParser::Cfl_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleCfl_clause;
}


antlrcpp::Any tsqlParser::Cfl_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCfl_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Cfl_clauseContext* tsqlParser::cfl_clause() {
  Cfl_clauseContext *_localctx = _tracker.createInstance<Cfl_clauseContext>(_ctx, getState());
  enterRule(_localctx, 14, tsqlParser::RuleCfl_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(486);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(479);
      block_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(480);
      break_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(481);
      continue_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(482);
      goto_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(483);
      return_statement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(484);
      throw_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(485);
      raiseerror_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_statementContext ------------------------------------------------------------------

tsqlParser::Block_statementContext::Block_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Block_statementContext::BEGIN() {
  return getToken(tsqlParser::BEGIN, 0);
}

tree::TerminalNode* tsqlParser::Block_statementContext::END() {
  return getToken(tsqlParser::END, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Block_statementContext::SEMI() {
  return getTokens(tsqlParser::SEMI);
}

tree::TerminalNode* tsqlParser::Block_statementContext::SEMI(size_t i) {
  return getToken(tsqlParser::SEMI, i);
}

tsqlParser::Sql_clausesContext* tsqlParser::Block_statementContext::sql_clauses() {
  return getRuleContext<tsqlParser::Sql_clausesContext>(0);
}


size_t tsqlParser::Block_statementContext::getRuleIndex() const {
  return tsqlParser::RuleBlock_statement;
}


antlrcpp::Any tsqlParser::Block_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBlock_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Block_statementContext* tsqlParser::block_statement() {
  Block_statementContext *_localctx = _tracker.createInstance<Block_statementContext>(_ctx, getState());
  enterRule(_localctx, 16, tsqlParser::RuleBlock_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(488);
    match(tsqlParser::BEGIN);
    setState(490);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::SEMI) {
      setState(489);
      match(tsqlParser::SEMI);
    }
    setState(493);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << tsqlParser::ALTER)
      | (1ULL << tsqlParser::BEGIN)
      | (1ULL << tsqlParser::BREAK)
      | (1ULL << tsqlParser::CLOSE)
      | (1ULL << tsqlParser::COMMIT)
      | (1ULL << tsqlParser::CONTINUE)
      | (1ULL << tsqlParser::CREATE)
      | (1ULL << tsqlParser::DEALLOCATE)
      | (1ULL << tsqlParser::DECLARE)
      | (1ULL << tsqlParser::DELETE)
      | (1ULL << tsqlParser::DROP)
      | (1ULL << tsqlParser::EXECUTE))) != 0) || ((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & ((1ULL << (tsqlParser::FETCH - 68))
      | (1ULL << (tsqlParser::FORCESEEK - 68))
      | (1ULL << (tsqlParser::GOTO - 68))
      | (1ULL << (tsqlParser::GRANT - 68))
      | (1ULL << (tsqlParser::IF - 68))
      | (1ULL << (tsqlParser::INSERT - 68))
      | (1ULL << (tsqlParser::NEXT - 68))
      | (1ULL << (tsqlParser::NUMERIC - 68))
      | (1ULL << (tsqlParser::OPEN - 68)))) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 136)) & ((1ULL << (tsqlParser::PRINT - 136))
      | (1ULL << (tsqlParser::RAISERROR - 136))
      | (1ULL << (tsqlParser::RETURN - 136))
      | (1ULL << (tsqlParser::REVERT - 136))
      | (1ULL << (tsqlParser::ROLLBACK - 136))
      | (1ULL << (tsqlParser::SAVE - 136))
      | (1ULL << (tsqlParser::SELECT - 136))
      | (1ULL << (tsqlParser::SET - 136))
      | (1ULL << (tsqlParser::UPDATE - 136))
      | (1ULL << (tsqlParser::USE - 136))
      | (1ULL << (tsqlParser::VALUE - 136))
      | (1ULL << (tsqlParser::WAITFOR - 136)))) != 0) || ((((_la - 202) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 202)) & ((1ULL << (tsqlParser::WHILE - 202))
      | (1ULL << (tsqlParser::WITH - 202))
      | (1ULL << (tsqlParser::ABSOLUTE - 202))
      | (1ULL << (tsqlParser::APPLY - 202))
      | (1ULL << (tsqlParser::AUTO - 202))
      | (1ULL << (tsqlParser::AVG - 202))
      | (1ULL << (tsqlParser::BASE64 - 202))
      | (1ULL << (tsqlParser::CALLER - 202))
      | (1ULL << (tsqlParser::CAST - 202))
      | (1ULL << (tsqlParser::CATCH - 202))
      | (1ULL << (tsqlParser::CHECKSUM_AGG - 202))
      | (1ULL << (tsqlParser::COMMITTED - 202))
      | (1ULL << (tsqlParser::CONCAT - 202))
      | (1ULL << (tsqlParser::CONTROL - 202))
      | (1ULL << (tsqlParser::COOKIE - 202))
      | (1ULL << (tsqlParser::COUNT - 202))
      | (1ULL << (tsqlParser::COUNT_BIG - 202))
      | (1ULL << (tsqlParser::DATE - 202))
      | (1ULL << (tsqlParser::DELAY - 202))
      | (1ULL << (tsqlParser::DELETED - 202))
      | (1ULL << (tsqlParser::DENSE_RANK - 202)))) != 0) || ((((_la - 266) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 266)) & ((1ULL << (tsqlParser::DISABLE - 266))
      | (1ULL << (tsqlParser::DYNAMIC - 266))
      | (1ULL << (tsqlParser::ENCRYPTION - 266))
      | (1ULL << (tsqlParser::EXIST - 266))
      | (1ULL << (tsqlParser::EXPAND - 266))
      | (1ULL << (tsqlParser::FAST - 266))
      | (1ULL << (tsqlParser::FAST_FORWARD - 266))
      | (1ULL << (tsqlParser::FIRST - 266))
      | (1ULL << (tsqlParser::FIRST_VALUE - 266))
      | (1ULL << (tsqlParser::FOLLOWING - 266))
      | (1ULL << (tsqlParser::FORCE - 266))
      | (1ULL << (tsqlParser::FORCED - 266))
      | (1ULL << (tsqlParser::FORWARD_ONLY - 266))
      | (1ULL << (tsqlParser::FULLSCAN - 266))
      | (1ULL << (tsqlParser::GLOBAL - 266))
      | (1ULL << (tsqlParser::GROUPING - 266))
      | (1ULL << (tsqlParser::GROUPING_ID - 266))
      | (1ULL << (tsqlParser::HASH - 266))
      | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 266))
      | (1ULL << (tsqlParser::IMPERSONATE - 266))
      | (1ULL << (tsqlParser::INSENSITIVE - 266))
      | (1ULL << (tsqlParser::INSERTED - 266))
      | (1ULL << (tsqlParser::ISOLATION - 266))
      | (1ULL << (tsqlParser::IO - 266))
      | (1ULL << (tsqlParser::KEEP - 266))
      | (1ULL << (tsqlParser::KEEPFIXED - 266))
      | (1ULL << (tsqlParser::KEYSET - 266))
      | (1ULL << (tsqlParser::LAG - 266))
      | (1ULL << (tsqlParser::LAST - 266))
      | (1ULL << (tsqlParser::LAST_VALUE - 266))
      | (1ULL << (tsqlParser::LEAD - 266))
      | (1ULL << (tsqlParser::LEVEL - 266))
      | (1ULL << (tsqlParser::LOCAL - 266))
      | (1ULL << (tsqlParser::LOCK_ESCALATION - 266))
      | (1ULL << (tsqlParser::LOGIN - 266))
      | (1ULL << (tsqlParser::LOOP - 266))
      | (1ULL << (tsqlParser::MARK - 266))
      | (1ULL << (tsqlParser::MAX - 266))
      | (1ULL << (tsqlParser::MAXDOP - 266))
      | (1ULL << (tsqlParser::MAXRECURSION - 266))
      | (1ULL << (tsqlParser::MIN - 266)))) != 0) || ((((_la - 332) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 332)) & ((1ULL << (tsqlParser::MODIFY - 332))
      | (1ULL << (tsqlParser::NAME - 332))
      | (1ULL << (tsqlParser::NOCOUNT - 332))
      | (1ULL << (tsqlParser::NODES - 332))
      | (1ULL << (tsqlParser::NOEXPAND - 332))
      | (1ULL << (tsqlParser::NORECOMPUTE - 332))
      | (1ULL << (tsqlParser::NTILE - 332))
      | (1ULL << (tsqlParser::NUMBER - 332))
      | (1ULL << (tsqlParser::OFFSET - 332))
      | (1ULL << (tsqlParser::ONLINE - 332))
      | (1ULL << (tsqlParser::ONLY - 332))
      | (1ULL << (tsqlParser::OPTIMISTIC - 332))
      | (1ULL << (tsqlParser::OPTIMIZE - 332))
      | (1ULL << (tsqlParser::OUT - 332))
      | (1ULL << (tsqlParser::OUTPUT - 332))
      | (1ULL << (tsqlParser::OWNER - 332))
      | (1ULL << (tsqlParser::PARAMETERIZATION - 332))
      | (1ULL << (tsqlParser::PARTITION - 332))
      | (1ULL << (tsqlParser::PATH - 332))
      | (1ULL << (tsqlParser::PRECEDING - 332))
      | (1ULL << (tsqlParser::PRIOR - 332))
      | (1ULL << (tsqlParser::PRIVILEGES - 332))
      | (1ULL << (tsqlParser::QUERY - 332))
      | (1ULL << (tsqlParser::RANGE - 332))
      | (1ULL << (tsqlParser::RANK - 332))
      | (1ULL << (tsqlParser::READONLY - 332))
      | (1ULL << (tsqlParser::READ_ONLY - 332))
      | (1ULL << (tsqlParser::RECOMPILE - 332))
      | (1ULL << (tsqlParser::RELATIVE - 332))
      | (1ULL << (tsqlParser::REMOTE - 332))
      | (1ULL << (tsqlParser::REPEATABLE - 332))
      | (1ULL << (tsqlParser::ROBUST - 332))
      | (1ULL << (tsqlParser::ROOT - 332))
      | (1ULL << (tsqlParser::ROW - 332))
      | (1ULL << (tsqlParser::ROWGUID - 332))
      | (1ULL << (tsqlParser::ROWS - 332))
      | (1ULL << (tsqlParser::ROW_NUMBER - 332))
      | (1ULL << (tsqlParser::SAMPLE - 332))
      | (1ULL << (tsqlParser::SCHEMABINDING - 332))
      | (1ULL << (tsqlParser::SCROLL - 332))
      | (1ULL << (tsqlParser::SCROLL_LOCKS - 332))
      | (1ULL << (tsqlParser::SELF - 332))
      | (1ULL << (tsqlParser::SERIALIZABLE - 332)))) != 0) || ((((_la - 397) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 397)) & ((1ULL << (tsqlParser::SIMPLE - 397))
      | (1ULL << (tsqlParser::SIZE - 397))
      | (1ULL << (tsqlParser::SNAPSHOT - 397))
      | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 397))
      | (1ULL << (tsqlParser::STATIC - 397))
      | (1ULL << (tsqlParser::STATS_STREAM - 397))
      | (1ULL << (tsqlParser::STDEV - 397))
      | (1ULL << (tsqlParser::STDEVP - 397))
      | (1ULL << (tsqlParser::SUM - 397))
      | (1ULL << (tsqlParser::TEXTIMAGE_ON - 397))
      | (1ULL << (tsqlParser::THROW - 397))
      | (1ULL << (tsqlParser::TIES - 397))
      | (1ULL << (tsqlParser::TIME - 397))
      | (1ULL << (tsqlParser::TRY - 397))
      | (1ULL << (tsqlParser::TYPE - 397))
      | (1ULL << (tsqlParser::TYPE_WARNING - 397))
      | (1ULL << (tsqlParser::UNBOUNDED - 397))
      | (1ULL << (tsqlParser::UNCOMMITTED - 397))
      | (1ULL << (tsqlParser::UNKNOWN - 397))
      | (1ULL << (tsqlParser::USING - 397))
      | (1ULL << (tsqlParser::VAR - 397))
      | (1ULL << (tsqlParser::VARP - 397))
      | (1ULL << (tsqlParser::VIEWS - 397))
      | (1ULL << (tsqlParser::VIEW_METADATA - 397))
      | (1ULL << (tsqlParser::WORK - 397))
      | (1ULL << (tsqlParser::XML - 397))
      | (1ULL << (tsqlParser::XMLNAMESPACES - 397))
      | (1ULL << (tsqlParser::ZONE - 397))
      | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 397))
      | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 397))
      | (1ULL << (tsqlParser::ID - 397)))) != 0) || _la == tsqlParser::LR_BRACKET) {
      setState(492);
      sql_clauses();
    }
    setState(495);
    match(tsqlParser::END);
    setState(497);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      setState(496);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Break_statementContext ------------------------------------------------------------------

tsqlParser::Break_statementContext::Break_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Break_statementContext::BREAK() {
  return getToken(tsqlParser::BREAK, 0);
}

tree::TerminalNode* tsqlParser::Break_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Break_statementContext::getRuleIndex() const {
  return tsqlParser::RuleBreak_statement;
}


antlrcpp::Any tsqlParser::Break_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBreak_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Break_statementContext* tsqlParser::break_statement() {
  Break_statementContext *_localctx = _tracker.createInstance<Break_statementContext>(_ctx, getState());
  enterRule(_localctx, 18, tsqlParser::RuleBreak_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(499);
    match(tsqlParser::BREAK);
    setState(501);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      setState(500);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Continue_statementContext ------------------------------------------------------------------

tsqlParser::Continue_statementContext::Continue_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Continue_statementContext::CONTINUE() {
  return getToken(tsqlParser::CONTINUE, 0);
}

tree::TerminalNode* tsqlParser::Continue_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Continue_statementContext::getRuleIndex() const {
  return tsqlParser::RuleContinue_statement;
}


antlrcpp::Any tsqlParser::Continue_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitContinue_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Continue_statementContext* tsqlParser::continue_statement() {
  Continue_statementContext *_localctx = _tracker.createInstance<Continue_statementContext>(_ctx, getState());
  enterRule(_localctx, 20, tsqlParser::RuleContinue_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(503);
    match(tsqlParser::CONTINUE);
    setState(505);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
    case 1: {
      setState(504);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Goto_statementContext ------------------------------------------------------------------

tsqlParser::Goto_statementContext::Goto_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Goto_statementContext::GOTO() {
  return getToken(tsqlParser::GOTO, 0);
}

tsqlParser::R_idContext* tsqlParser::Goto_statementContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Goto_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tree::TerminalNode* tsqlParser::Goto_statementContext::COLON() {
  return getToken(tsqlParser::COLON, 0);
}


size_t tsqlParser::Goto_statementContext::getRuleIndex() const {
  return tsqlParser::RuleGoto_statement;
}


antlrcpp::Any tsqlParser::Goto_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitGoto_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Goto_statementContext* tsqlParser::goto_statement() {
  Goto_statementContext *_localctx = _tracker.createInstance<Goto_statementContext>(_ctx, getState());
  enterRule(_localctx, 22, tsqlParser::RuleGoto_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(517);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::GOTO: {
        enterOuterAlt(_localctx, 1);
        setState(507);
        match(tsqlParser::GOTO);
        setState(508);
        r_id();
        setState(510);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
        case 1: {
          setState(509);
          match(tsqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        enterOuterAlt(_localctx, 2);
        setState(512);
        r_id();
        setState(513);
        match(tsqlParser::COLON);
        setState(515);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
        case 1: {
          setState(514);
          match(tsqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_statementContext ------------------------------------------------------------------

tsqlParser::If_statementContext::If_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::If_statementContext::IF() {
  return getToken(tsqlParser::IF, 0);
}

tsqlParser::Search_conditionContext* tsqlParser::If_statementContext::search_condition() {
  return getRuleContext<tsqlParser::Search_conditionContext>(0);
}

tsqlParser::If_blockContext* tsqlParser::If_statementContext::if_block() {
  return getRuleContext<tsqlParser::If_blockContext>(0);
}


size_t tsqlParser::If_statementContext::getRuleIndex() const {
  return tsqlParser::RuleIf_statement;
}


antlrcpp::Any tsqlParser::If_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitIf_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::If_statementContext* tsqlParser::if_statement() {
  If_statementContext *_localctx = _tracker.createInstance<If_statementContext>(_ctx, getState());
  enterRule(_localctx, 24, tsqlParser::RuleIf_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(519);
    match(tsqlParser::IF);
    setState(520);
    search_condition(0);
    setState(521);
    if_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_blockContext ------------------------------------------------------------------

tsqlParser::If_blockContext::If_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::Sql_clauseContext *> tsqlParser::If_blockContext::sql_clause() {
  return getRuleContexts<tsqlParser::Sql_clauseContext>();
}

tsqlParser::Sql_clauseContext* tsqlParser::If_blockContext::sql_clause(size_t i) {
  return getRuleContext<tsqlParser::Sql_clauseContext>(i);
}

tree::TerminalNode* tsqlParser::If_blockContext::ELSE() {
  return getToken(tsqlParser::ELSE, 0);
}

tree::TerminalNode* tsqlParser::If_blockContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

std::vector<tsqlParser::Block_statementContext *> tsqlParser::If_blockContext::block_statement() {
  return getRuleContexts<tsqlParser::Block_statementContext>();
}

tsqlParser::Block_statementContext* tsqlParser::If_blockContext::block_statement(size_t i) {
  return getRuleContext<tsqlParser::Block_statementContext>(i);
}


size_t tsqlParser::If_blockContext::getRuleIndex() const {
  return tsqlParser::RuleIf_block;
}


antlrcpp::Any tsqlParser::If_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitIf_block(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::If_blockContext* tsqlParser::if_block() {
  If_blockContext *_localctx = _tracker.createInstance<If_blockContext>(_ctx, getState());
  enterRule(_localctx, 26, tsqlParser::RuleIf_block);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(539);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(523);
      dynamic_cast<If_blockContext *>(_localctx)->if_expr = sql_clause();
      setState(526);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
      case 1: {
        setState(524);
        match(tsqlParser::ELSE);
        setState(525);
        dynamic_cast<If_blockContext *>(_localctx)->else_expr = sql_clause();
        break;
      }

      default:
        break;
      }
      setState(529);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
      case 1: {
        setState(528);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(531);
      dynamic_cast<If_blockContext *>(_localctx)->if_block_expr = block_statement();
      setState(534);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
      case 1: {
        setState(532);
        match(tsqlParser::ELSE);
        setState(533);
        dynamic_cast<If_blockContext *>(_localctx)->else_block_expr = block_statement();
        break;
      }

      default:
        break;
      }
      setState(537);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
      case 1: {
        setState(536);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Return_statementContext ------------------------------------------------------------------

tsqlParser::Return_statementContext::Return_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Return_statementContext::RETURN() {
  return getToken(tsqlParser::RETURN, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Return_statementContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Return_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Return_statementContext::getRuleIndex() const {
  return tsqlParser::RuleReturn_statement;
}


antlrcpp::Any tsqlParser::Return_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitReturn_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Return_statementContext* tsqlParser::return_statement() {
  Return_statementContext *_localctx = _tracker.createInstance<Return_statementContext>(_ctx, getState());
  enterRule(_localctx, 28, tsqlParser::RuleReturn_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(541);
    match(tsqlParser::RETURN);
    setState(543);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
    case 1: {
      setState(542);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(546);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      setState(545);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_statementContext ------------------------------------------------------------------

tsqlParser::Throw_statementContext::Throw_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Throw_statementContext::THROW() {
  return getToken(tsqlParser::THROW, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Throw_statementContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Throw_statementContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::Throw_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Throw_statementContext::DECIMAL() {
  return getTokens(tsqlParser::DECIMAL);
}

tree::TerminalNode* tsqlParser::Throw_statementContext::DECIMAL(size_t i) {
  return getToken(tsqlParser::DECIMAL, i);
}

std::vector<tree::TerminalNode *> tsqlParser::Throw_statementContext::LOCAL_ID() {
  return getTokens(tsqlParser::LOCAL_ID);
}

tree::TerminalNode* tsqlParser::Throw_statementContext::LOCAL_ID(size_t i) {
  return getToken(tsqlParser::LOCAL_ID, i);
}

tree::TerminalNode* tsqlParser::Throw_statementContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}


size_t tsqlParser::Throw_statementContext::getRuleIndex() const {
  return tsqlParser::RuleThrow_statement;
}


antlrcpp::Any tsqlParser::Throw_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitThrow_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Throw_statementContext* tsqlParser::throw_statement() {
  Throw_statementContext *_localctx = _tracker.createInstance<Throw_statementContext>(_ctx, getState());
  enterRule(_localctx, 30, tsqlParser::RuleThrow_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(548);
    match(tsqlParser::THROW);
    setState(554);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::LOCAL_ID

    || _la == tsqlParser::DECIMAL) {
      setState(549);
      dynamic_cast<Throw_statementContext *>(_localctx)->error_number = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::LOCAL_ID

      || _la == tsqlParser::DECIMAL)) {
        dynamic_cast<Throw_statementContext *>(_localctx)->error_number = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(550);
      match(tsqlParser::COMMA);
      setState(551);
      dynamic_cast<Throw_statementContext *>(_localctx)->message = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::LOCAL_ID

      || _la == tsqlParser::STRING)) {
        dynamic_cast<Throw_statementContext *>(_localctx)->message = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(552);
      match(tsqlParser::COMMA);
      setState(553);
      dynamic_cast<Throw_statementContext *>(_localctx)->state = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::LOCAL_ID

      || _la == tsqlParser::DECIMAL)) {
        dynamic_cast<Throw_statementContext *>(_localctx)->state = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(557);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
    case 1: {
      setState(556);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Try_catch_statementContext ------------------------------------------------------------------

tsqlParser::Try_catch_statementContext::Try_catch_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> tsqlParser::Try_catch_statementContext::BEGIN() {
  return getTokens(tsqlParser::BEGIN);
}

tree::TerminalNode* tsqlParser::Try_catch_statementContext::BEGIN(size_t i) {
  return getToken(tsqlParser::BEGIN, i);
}

std::vector<tree::TerminalNode *> tsqlParser::Try_catch_statementContext::TRY() {
  return getTokens(tsqlParser::TRY);
}

tree::TerminalNode* tsqlParser::Try_catch_statementContext::TRY(size_t i) {
  return getToken(tsqlParser::TRY, i);
}

std::vector<tree::TerminalNode *> tsqlParser::Try_catch_statementContext::END() {
  return getTokens(tsqlParser::END);
}

tree::TerminalNode* tsqlParser::Try_catch_statementContext::END(size_t i) {
  return getToken(tsqlParser::END, i);
}

std::vector<tree::TerminalNode *> tsqlParser::Try_catch_statementContext::CATCH() {
  return getTokens(tsqlParser::CATCH);
}

tree::TerminalNode* tsqlParser::Try_catch_statementContext::CATCH(size_t i) {
  return getToken(tsqlParser::CATCH, i);
}

std::vector<tree::TerminalNode *> tsqlParser::Try_catch_statementContext::SEMI() {
  return getTokens(tsqlParser::SEMI);
}

tree::TerminalNode* tsqlParser::Try_catch_statementContext::SEMI(size_t i) {
  return getToken(tsqlParser::SEMI, i);
}

std::vector<tsqlParser::Sql_clausesContext *> tsqlParser::Try_catch_statementContext::sql_clauses() {
  return getRuleContexts<tsqlParser::Sql_clausesContext>();
}

tsqlParser::Sql_clausesContext* tsqlParser::Try_catch_statementContext::sql_clauses(size_t i) {
  return getRuleContext<tsqlParser::Sql_clausesContext>(i);
}


size_t tsqlParser::Try_catch_statementContext::getRuleIndex() const {
  return tsqlParser::RuleTry_catch_statement;
}


antlrcpp::Any tsqlParser::Try_catch_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTry_catch_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Try_catch_statementContext* tsqlParser::try_catch_statement() {
  Try_catch_statementContext *_localctx = _tracker.createInstance<Try_catch_statementContext>(_ctx, getState());
  enterRule(_localctx, 32, tsqlParser::RuleTry_catch_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(559);
    match(tsqlParser::BEGIN);
    setState(560);
    match(tsqlParser::TRY);
    setState(562);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::SEMI) {
      setState(561);
      match(tsqlParser::SEMI);
    }
    setState(565);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << tsqlParser::ALTER)
      | (1ULL << tsqlParser::BEGIN)
      | (1ULL << tsqlParser::BREAK)
      | (1ULL << tsqlParser::CLOSE)
      | (1ULL << tsqlParser::COMMIT)
      | (1ULL << tsqlParser::CONTINUE)
      | (1ULL << tsqlParser::CREATE)
      | (1ULL << tsqlParser::DEALLOCATE)
      | (1ULL << tsqlParser::DECLARE)
      | (1ULL << tsqlParser::DELETE)
      | (1ULL << tsqlParser::DROP)
      | (1ULL << tsqlParser::EXECUTE))) != 0) || ((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & ((1ULL << (tsqlParser::FETCH - 68))
      | (1ULL << (tsqlParser::FORCESEEK - 68))
      | (1ULL << (tsqlParser::GOTO - 68))
      | (1ULL << (tsqlParser::GRANT - 68))
      | (1ULL << (tsqlParser::IF - 68))
      | (1ULL << (tsqlParser::INSERT - 68))
      | (1ULL << (tsqlParser::NEXT - 68))
      | (1ULL << (tsqlParser::NUMERIC - 68))
      | (1ULL << (tsqlParser::OPEN - 68)))) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 136)) & ((1ULL << (tsqlParser::PRINT - 136))
      | (1ULL << (tsqlParser::RAISERROR - 136))
      | (1ULL << (tsqlParser::RETURN - 136))
      | (1ULL << (tsqlParser::REVERT - 136))
      | (1ULL << (tsqlParser::ROLLBACK - 136))
      | (1ULL << (tsqlParser::SAVE - 136))
      | (1ULL << (tsqlParser::SELECT - 136))
      | (1ULL << (tsqlParser::SET - 136))
      | (1ULL << (tsqlParser::UPDATE - 136))
      | (1ULL << (tsqlParser::USE - 136))
      | (1ULL << (tsqlParser::VALUE - 136))
      | (1ULL << (tsqlParser::WAITFOR - 136)))) != 0) || ((((_la - 202) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 202)) & ((1ULL << (tsqlParser::WHILE - 202))
      | (1ULL << (tsqlParser::WITH - 202))
      | (1ULL << (tsqlParser::ABSOLUTE - 202))
      | (1ULL << (tsqlParser::APPLY - 202))
      | (1ULL << (tsqlParser::AUTO - 202))
      | (1ULL << (tsqlParser::AVG - 202))
      | (1ULL << (tsqlParser::BASE64 - 202))
      | (1ULL << (tsqlParser::CALLER - 202))
      | (1ULL << (tsqlParser::CAST - 202))
      | (1ULL << (tsqlParser::CATCH - 202))
      | (1ULL << (tsqlParser::CHECKSUM_AGG - 202))
      | (1ULL << (tsqlParser::COMMITTED - 202))
      | (1ULL << (tsqlParser::CONCAT - 202))
      | (1ULL << (tsqlParser::CONTROL - 202))
      | (1ULL << (tsqlParser::COOKIE - 202))
      | (1ULL << (tsqlParser::COUNT - 202))
      | (1ULL << (tsqlParser::COUNT_BIG - 202))
      | (1ULL << (tsqlParser::DATE - 202))
      | (1ULL << (tsqlParser::DELAY - 202))
      | (1ULL << (tsqlParser::DELETED - 202))
      | (1ULL << (tsqlParser::DENSE_RANK - 202)))) != 0) || ((((_la - 266) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 266)) & ((1ULL << (tsqlParser::DISABLE - 266))
      | (1ULL << (tsqlParser::DYNAMIC - 266))
      | (1ULL << (tsqlParser::ENCRYPTION - 266))
      | (1ULL << (tsqlParser::EXIST - 266))
      | (1ULL << (tsqlParser::EXPAND - 266))
      | (1ULL << (tsqlParser::FAST - 266))
      | (1ULL << (tsqlParser::FAST_FORWARD - 266))
      | (1ULL << (tsqlParser::FIRST - 266))
      | (1ULL << (tsqlParser::FIRST_VALUE - 266))
      | (1ULL << (tsqlParser::FOLLOWING - 266))
      | (1ULL << (tsqlParser::FORCE - 266))
      | (1ULL << (tsqlParser::FORCED - 266))
      | (1ULL << (tsqlParser::FORWARD_ONLY - 266))
      | (1ULL << (tsqlParser::FULLSCAN - 266))
      | (1ULL << (tsqlParser::GLOBAL - 266))
      | (1ULL << (tsqlParser::GROUPING - 266))
      | (1ULL << (tsqlParser::GROUPING_ID - 266))
      | (1ULL << (tsqlParser::HASH - 266))
      | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 266))
      | (1ULL << (tsqlParser::IMPERSONATE - 266))
      | (1ULL << (tsqlParser::INSENSITIVE - 266))
      | (1ULL << (tsqlParser::INSERTED - 266))
      | (1ULL << (tsqlParser::ISOLATION - 266))
      | (1ULL << (tsqlParser::IO - 266))
      | (1ULL << (tsqlParser::KEEP - 266))
      | (1ULL << (tsqlParser::KEEPFIXED - 266))
      | (1ULL << (tsqlParser::KEYSET - 266))
      | (1ULL << (tsqlParser::LAG - 266))
      | (1ULL << (tsqlParser::LAST - 266))
      | (1ULL << (tsqlParser::LAST_VALUE - 266))
      | (1ULL << (tsqlParser::LEAD - 266))
      | (1ULL << (tsqlParser::LEVEL - 266))
      | (1ULL << (tsqlParser::LOCAL - 266))
      | (1ULL << (tsqlParser::LOCK_ESCALATION - 266))
      | (1ULL << (tsqlParser::LOGIN - 266))
      | (1ULL << (tsqlParser::LOOP - 266))
      | (1ULL << (tsqlParser::MARK - 266))
      | (1ULL << (tsqlParser::MAX - 266))
      | (1ULL << (tsqlParser::MAXDOP - 266))
      | (1ULL << (tsqlParser::MAXRECURSION - 266))
      | (1ULL << (tsqlParser::MIN - 266)))) != 0) || ((((_la - 332) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 332)) & ((1ULL << (tsqlParser::MODIFY - 332))
      | (1ULL << (tsqlParser::NAME - 332))
      | (1ULL << (tsqlParser::NOCOUNT - 332))
      | (1ULL << (tsqlParser::NODES - 332))
      | (1ULL << (tsqlParser::NOEXPAND - 332))
      | (1ULL << (tsqlParser::NORECOMPUTE - 332))
      | (1ULL << (tsqlParser::NTILE - 332))
      | (1ULL << (tsqlParser::NUMBER - 332))
      | (1ULL << (tsqlParser::OFFSET - 332))
      | (1ULL << (tsqlParser::ONLINE - 332))
      | (1ULL << (tsqlParser::ONLY - 332))
      | (1ULL << (tsqlParser::OPTIMISTIC - 332))
      | (1ULL << (tsqlParser::OPTIMIZE - 332))
      | (1ULL << (tsqlParser::OUT - 332))
      | (1ULL << (tsqlParser::OUTPUT - 332))
      | (1ULL << (tsqlParser::OWNER - 332))
      | (1ULL << (tsqlParser::PARAMETERIZATION - 332))
      | (1ULL << (tsqlParser::PARTITION - 332))
      | (1ULL << (tsqlParser::PATH - 332))
      | (1ULL << (tsqlParser::PRECEDING - 332))
      | (1ULL << (tsqlParser::PRIOR - 332))
      | (1ULL << (tsqlParser::PRIVILEGES - 332))
      | (1ULL << (tsqlParser::QUERY - 332))
      | (1ULL << (tsqlParser::RANGE - 332))
      | (1ULL << (tsqlParser::RANK - 332))
      | (1ULL << (tsqlParser::READONLY - 332))
      | (1ULL << (tsqlParser::READ_ONLY - 332))
      | (1ULL << (tsqlParser::RECOMPILE - 332))
      | (1ULL << (tsqlParser::RELATIVE - 332))
      | (1ULL << (tsqlParser::REMOTE - 332))
      | (1ULL << (tsqlParser::REPEATABLE - 332))
      | (1ULL << (tsqlParser::ROBUST - 332))
      | (1ULL << (tsqlParser::ROOT - 332))
      | (1ULL << (tsqlParser::ROW - 332))
      | (1ULL << (tsqlParser::ROWGUID - 332))
      | (1ULL << (tsqlParser::ROWS - 332))
      | (1ULL << (tsqlParser::ROW_NUMBER - 332))
      | (1ULL << (tsqlParser::SAMPLE - 332))
      | (1ULL << (tsqlParser::SCHEMABINDING - 332))
      | (1ULL << (tsqlParser::SCROLL - 332))
      | (1ULL << (tsqlParser::SCROLL_LOCKS - 332))
      | (1ULL << (tsqlParser::SELF - 332))
      | (1ULL << (tsqlParser::SERIALIZABLE - 332)))) != 0) || ((((_la - 397) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 397)) & ((1ULL << (tsqlParser::SIMPLE - 397))
      | (1ULL << (tsqlParser::SIZE - 397))
      | (1ULL << (tsqlParser::SNAPSHOT - 397))
      | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 397))
      | (1ULL << (tsqlParser::STATIC - 397))
      | (1ULL << (tsqlParser::STATS_STREAM - 397))
      | (1ULL << (tsqlParser::STDEV - 397))
      | (1ULL << (tsqlParser::STDEVP - 397))
      | (1ULL << (tsqlParser::SUM - 397))
      | (1ULL << (tsqlParser::TEXTIMAGE_ON - 397))
      | (1ULL << (tsqlParser::THROW - 397))
      | (1ULL << (tsqlParser::TIES - 397))
      | (1ULL << (tsqlParser::TIME - 397))
      | (1ULL << (tsqlParser::TRY - 397))
      | (1ULL << (tsqlParser::TYPE - 397))
      | (1ULL << (tsqlParser::TYPE_WARNING - 397))
      | (1ULL << (tsqlParser::UNBOUNDED - 397))
      | (1ULL << (tsqlParser::UNCOMMITTED - 397))
      | (1ULL << (tsqlParser::UNKNOWN - 397))
      | (1ULL << (tsqlParser::USING - 397))
      | (1ULL << (tsqlParser::VAR - 397))
      | (1ULL << (tsqlParser::VARP - 397))
      | (1ULL << (tsqlParser::VIEWS - 397))
      | (1ULL << (tsqlParser::VIEW_METADATA - 397))
      | (1ULL << (tsqlParser::WORK - 397))
      | (1ULL << (tsqlParser::XML - 397))
      | (1ULL << (tsqlParser::XMLNAMESPACES - 397))
      | (1ULL << (tsqlParser::ZONE - 397))
      | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 397))
      | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 397))
      | (1ULL << (tsqlParser::ID - 397)))) != 0) || _la == tsqlParser::LR_BRACKET) {
      setState(564);
      dynamic_cast<Try_catch_statementContext *>(_localctx)->try_clauses = sql_clauses();
    }
    setState(567);
    match(tsqlParser::END);
    setState(568);
    match(tsqlParser::TRY);
    setState(570);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::SEMI) {
      setState(569);
      match(tsqlParser::SEMI);
    }
    setState(572);
    match(tsqlParser::BEGIN);
    setState(573);
    match(tsqlParser::CATCH);
    setState(575);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::SEMI) {
      setState(574);
      match(tsqlParser::SEMI);
    }
    setState(578);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << tsqlParser::ALTER)
      | (1ULL << tsqlParser::BEGIN)
      | (1ULL << tsqlParser::BREAK)
      | (1ULL << tsqlParser::CLOSE)
      | (1ULL << tsqlParser::COMMIT)
      | (1ULL << tsqlParser::CONTINUE)
      | (1ULL << tsqlParser::CREATE)
      | (1ULL << tsqlParser::DEALLOCATE)
      | (1ULL << tsqlParser::DECLARE)
      | (1ULL << tsqlParser::DELETE)
      | (1ULL << tsqlParser::DROP)
      | (1ULL << tsqlParser::EXECUTE))) != 0) || ((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & ((1ULL << (tsqlParser::FETCH - 68))
      | (1ULL << (tsqlParser::FORCESEEK - 68))
      | (1ULL << (tsqlParser::GOTO - 68))
      | (1ULL << (tsqlParser::GRANT - 68))
      | (1ULL << (tsqlParser::IF - 68))
      | (1ULL << (tsqlParser::INSERT - 68))
      | (1ULL << (tsqlParser::NEXT - 68))
      | (1ULL << (tsqlParser::NUMERIC - 68))
      | (1ULL << (tsqlParser::OPEN - 68)))) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 136)) & ((1ULL << (tsqlParser::PRINT - 136))
      | (1ULL << (tsqlParser::RAISERROR - 136))
      | (1ULL << (tsqlParser::RETURN - 136))
      | (1ULL << (tsqlParser::REVERT - 136))
      | (1ULL << (tsqlParser::ROLLBACK - 136))
      | (1ULL << (tsqlParser::SAVE - 136))
      | (1ULL << (tsqlParser::SELECT - 136))
      | (1ULL << (tsqlParser::SET - 136))
      | (1ULL << (tsqlParser::UPDATE - 136))
      | (1ULL << (tsqlParser::USE - 136))
      | (1ULL << (tsqlParser::VALUE - 136))
      | (1ULL << (tsqlParser::WAITFOR - 136)))) != 0) || ((((_la - 202) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 202)) & ((1ULL << (tsqlParser::WHILE - 202))
      | (1ULL << (tsqlParser::WITH - 202))
      | (1ULL << (tsqlParser::ABSOLUTE - 202))
      | (1ULL << (tsqlParser::APPLY - 202))
      | (1ULL << (tsqlParser::AUTO - 202))
      | (1ULL << (tsqlParser::AVG - 202))
      | (1ULL << (tsqlParser::BASE64 - 202))
      | (1ULL << (tsqlParser::CALLER - 202))
      | (1ULL << (tsqlParser::CAST - 202))
      | (1ULL << (tsqlParser::CATCH - 202))
      | (1ULL << (tsqlParser::CHECKSUM_AGG - 202))
      | (1ULL << (tsqlParser::COMMITTED - 202))
      | (1ULL << (tsqlParser::CONCAT - 202))
      | (1ULL << (tsqlParser::CONTROL - 202))
      | (1ULL << (tsqlParser::COOKIE - 202))
      | (1ULL << (tsqlParser::COUNT - 202))
      | (1ULL << (tsqlParser::COUNT_BIG - 202))
      | (1ULL << (tsqlParser::DATE - 202))
      | (1ULL << (tsqlParser::DELAY - 202))
      | (1ULL << (tsqlParser::DELETED - 202))
      | (1ULL << (tsqlParser::DENSE_RANK - 202)))) != 0) || ((((_la - 266) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 266)) & ((1ULL << (tsqlParser::DISABLE - 266))
      | (1ULL << (tsqlParser::DYNAMIC - 266))
      | (1ULL << (tsqlParser::ENCRYPTION - 266))
      | (1ULL << (tsqlParser::EXIST - 266))
      | (1ULL << (tsqlParser::EXPAND - 266))
      | (1ULL << (tsqlParser::FAST - 266))
      | (1ULL << (tsqlParser::FAST_FORWARD - 266))
      | (1ULL << (tsqlParser::FIRST - 266))
      | (1ULL << (tsqlParser::FIRST_VALUE - 266))
      | (1ULL << (tsqlParser::FOLLOWING - 266))
      | (1ULL << (tsqlParser::FORCE - 266))
      | (1ULL << (tsqlParser::FORCED - 266))
      | (1ULL << (tsqlParser::FORWARD_ONLY - 266))
      | (1ULL << (tsqlParser::FULLSCAN - 266))
      | (1ULL << (tsqlParser::GLOBAL - 266))
      | (1ULL << (tsqlParser::GROUPING - 266))
      | (1ULL << (tsqlParser::GROUPING_ID - 266))
      | (1ULL << (tsqlParser::HASH - 266))
      | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 266))
      | (1ULL << (tsqlParser::IMPERSONATE - 266))
      | (1ULL << (tsqlParser::INSENSITIVE - 266))
      | (1ULL << (tsqlParser::INSERTED - 266))
      | (1ULL << (tsqlParser::ISOLATION - 266))
      | (1ULL << (tsqlParser::IO - 266))
      | (1ULL << (tsqlParser::KEEP - 266))
      | (1ULL << (tsqlParser::KEEPFIXED - 266))
      | (1ULL << (tsqlParser::KEYSET - 266))
      | (1ULL << (tsqlParser::LAG - 266))
      | (1ULL << (tsqlParser::LAST - 266))
      | (1ULL << (tsqlParser::LAST_VALUE - 266))
      | (1ULL << (tsqlParser::LEAD - 266))
      | (1ULL << (tsqlParser::LEVEL - 266))
      | (1ULL << (tsqlParser::LOCAL - 266))
      | (1ULL << (tsqlParser::LOCK_ESCALATION - 266))
      | (1ULL << (tsqlParser::LOGIN - 266))
      | (1ULL << (tsqlParser::LOOP - 266))
      | (1ULL << (tsqlParser::MARK - 266))
      | (1ULL << (tsqlParser::MAX - 266))
      | (1ULL << (tsqlParser::MAXDOP - 266))
      | (1ULL << (tsqlParser::MAXRECURSION - 266))
      | (1ULL << (tsqlParser::MIN - 266)))) != 0) || ((((_la - 332) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 332)) & ((1ULL << (tsqlParser::MODIFY - 332))
      | (1ULL << (tsqlParser::NAME - 332))
      | (1ULL << (tsqlParser::NOCOUNT - 332))
      | (1ULL << (tsqlParser::NODES - 332))
      | (1ULL << (tsqlParser::NOEXPAND - 332))
      | (1ULL << (tsqlParser::NORECOMPUTE - 332))
      | (1ULL << (tsqlParser::NTILE - 332))
      | (1ULL << (tsqlParser::NUMBER - 332))
      | (1ULL << (tsqlParser::OFFSET - 332))
      | (1ULL << (tsqlParser::ONLINE - 332))
      | (1ULL << (tsqlParser::ONLY - 332))
      | (1ULL << (tsqlParser::OPTIMISTIC - 332))
      | (1ULL << (tsqlParser::OPTIMIZE - 332))
      | (1ULL << (tsqlParser::OUT - 332))
      | (1ULL << (tsqlParser::OUTPUT - 332))
      | (1ULL << (tsqlParser::OWNER - 332))
      | (1ULL << (tsqlParser::PARAMETERIZATION - 332))
      | (1ULL << (tsqlParser::PARTITION - 332))
      | (1ULL << (tsqlParser::PATH - 332))
      | (1ULL << (tsqlParser::PRECEDING - 332))
      | (1ULL << (tsqlParser::PRIOR - 332))
      | (1ULL << (tsqlParser::PRIVILEGES - 332))
      | (1ULL << (tsqlParser::QUERY - 332))
      | (1ULL << (tsqlParser::RANGE - 332))
      | (1ULL << (tsqlParser::RANK - 332))
      | (1ULL << (tsqlParser::READONLY - 332))
      | (1ULL << (tsqlParser::READ_ONLY - 332))
      | (1ULL << (tsqlParser::RECOMPILE - 332))
      | (1ULL << (tsqlParser::RELATIVE - 332))
      | (1ULL << (tsqlParser::REMOTE - 332))
      | (1ULL << (tsqlParser::REPEATABLE - 332))
      | (1ULL << (tsqlParser::ROBUST - 332))
      | (1ULL << (tsqlParser::ROOT - 332))
      | (1ULL << (tsqlParser::ROW - 332))
      | (1ULL << (tsqlParser::ROWGUID - 332))
      | (1ULL << (tsqlParser::ROWS - 332))
      | (1ULL << (tsqlParser::ROW_NUMBER - 332))
      | (1ULL << (tsqlParser::SAMPLE - 332))
      | (1ULL << (tsqlParser::SCHEMABINDING - 332))
      | (1ULL << (tsqlParser::SCROLL - 332))
      | (1ULL << (tsqlParser::SCROLL_LOCKS - 332))
      | (1ULL << (tsqlParser::SELF - 332))
      | (1ULL << (tsqlParser::SERIALIZABLE - 332)))) != 0) || ((((_la - 397) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 397)) & ((1ULL << (tsqlParser::SIMPLE - 397))
      | (1ULL << (tsqlParser::SIZE - 397))
      | (1ULL << (tsqlParser::SNAPSHOT - 397))
      | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 397))
      | (1ULL << (tsqlParser::STATIC - 397))
      | (1ULL << (tsqlParser::STATS_STREAM - 397))
      | (1ULL << (tsqlParser::STDEV - 397))
      | (1ULL << (tsqlParser::STDEVP - 397))
      | (1ULL << (tsqlParser::SUM - 397))
      | (1ULL << (tsqlParser::TEXTIMAGE_ON - 397))
      | (1ULL << (tsqlParser::THROW - 397))
      | (1ULL << (tsqlParser::TIES - 397))
      | (1ULL << (tsqlParser::TIME - 397))
      | (1ULL << (tsqlParser::TRY - 397))
      | (1ULL << (tsqlParser::TYPE - 397))
      | (1ULL << (tsqlParser::TYPE_WARNING - 397))
      | (1ULL << (tsqlParser::UNBOUNDED - 397))
      | (1ULL << (tsqlParser::UNCOMMITTED - 397))
      | (1ULL << (tsqlParser::UNKNOWN - 397))
      | (1ULL << (tsqlParser::USING - 397))
      | (1ULL << (tsqlParser::VAR - 397))
      | (1ULL << (tsqlParser::VARP - 397))
      | (1ULL << (tsqlParser::VIEWS - 397))
      | (1ULL << (tsqlParser::VIEW_METADATA - 397))
      | (1ULL << (tsqlParser::WORK - 397))
      | (1ULL << (tsqlParser::XML - 397))
      | (1ULL << (tsqlParser::XMLNAMESPACES - 397))
      | (1ULL << (tsqlParser::ZONE - 397))
      | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 397))
      | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 397))
      | (1ULL << (tsqlParser::ID - 397)))) != 0) || _la == tsqlParser::LR_BRACKET) {
      setState(577);
      dynamic_cast<Try_catch_statementContext *>(_localctx)->catch_clauses = sql_clauses();
    }
    setState(580);
    match(tsqlParser::END);
    setState(581);
    match(tsqlParser::CATCH);
    setState(583);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      setState(582);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Waitfor_statementContext ------------------------------------------------------------------

tsqlParser::Waitfor_statementContext::Waitfor_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Waitfor_statementContext::WAITFOR() {
  return getToken(tsqlParser::WAITFOR, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Waitfor_statementContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Waitfor_statementContext::DELAY() {
  return getToken(tsqlParser::DELAY, 0);
}

tree::TerminalNode* tsqlParser::Waitfor_statementContext::TIME() {
  return getToken(tsqlParser::TIME, 0);
}

tree::TerminalNode* tsqlParser::Waitfor_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Waitfor_statementContext::getRuleIndex() const {
  return tsqlParser::RuleWaitfor_statement;
}


antlrcpp::Any tsqlParser::Waitfor_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitWaitfor_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Waitfor_statementContext* tsqlParser::waitfor_statement() {
  Waitfor_statementContext *_localctx = _tracker.createInstance<Waitfor_statementContext>(_ctx, getState());
  enterRule(_localctx, 34, tsqlParser::RuleWaitfor_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(585);
    match(tsqlParser::WAITFOR);
    setState(586);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::DELAY || _la == tsqlParser::TIME)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(587);
    expression(0);
    setState(589);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      setState(588);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- While_statementContext ------------------------------------------------------------------

tsqlParser::While_statementContext::While_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::While_statementContext::WHILE() {
  return getToken(tsqlParser::WHILE, 0);
}

tsqlParser::Search_conditionContext* tsqlParser::While_statementContext::search_condition() {
  return getRuleContext<tsqlParser::Search_conditionContext>(0);
}

tsqlParser::Sql_clauseContext* tsqlParser::While_statementContext::sql_clause() {
  return getRuleContext<tsqlParser::Sql_clauseContext>(0);
}

tree::TerminalNode* tsqlParser::While_statementContext::BREAK() {
  return getToken(tsqlParser::BREAK, 0);
}

tree::TerminalNode* tsqlParser::While_statementContext::CONTINUE() {
  return getToken(tsqlParser::CONTINUE, 0);
}

tree::TerminalNode* tsqlParser::While_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::While_statementContext::getRuleIndex() const {
  return tsqlParser::RuleWhile_statement;
}


antlrcpp::Any tsqlParser::While_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitWhile_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::While_statementContext* tsqlParser::while_statement() {
  While_statementContext *_localctx = _tracker.createInstance<While_statementContext>(_ctx, getState());
  enterRule(_localctx, 36, tsqlParser::RuleWhile_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(591);
    match(tsqlParser::WHILE);
    setState(592);
    search_condition(0);
    setState(602);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
    case 1: {
      setState(593);
      sql_clause();
      break;
    }

    case 2: {
      setState(594);
      match(tsqlParser::BREAK);
      setState(596);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
      case 1: {
        setState(595);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      setState(598);
      match(tsqlParser::CONTINUE);
      setState(600);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
      case 1: {
        setState(599);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Print_statementContext ------------------------------------------------------------------

tsqlParser::Print_statementContext::Print_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Print_statementContext::PRINT() {
  return getToken(tsqlParser::PRINT, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Print_statementContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Print_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Print_statementContext::getRuleIndex() const {
  return tsqlParser::RulePrint_statement;
}


antlrcpp::Any tsqlParser::Print_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitPrint_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Print_statementContext* tsqlParser::print_statement() {
  Print_statementContext *_localctx = _tracker.createInstance<Print_statementContext>(_ctx, getState());
  enterRule(_localctx, 38, tsqlParser::RulePrint_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(604);
    match(tsqlParser::PRINT);
    setState(605);
    expression(0);
    setState(607);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      setState(606);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raiseerror_statementContext ------------------------------------------------------------------

tsqlParser::Raiseerror_statementContext::Raiseerror_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Raiseerror_statementContext::RAISERROR() {
  return getToken(tsqlParser::RAISERROR, 0);
}

tree::TerminalNode* tsqlParser::Raiseerror_statementContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Raiseerror_statementContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Raiseerror_statementContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::Raiseerror_statementContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tsqlParser::Constant_LOCAL_IDContext *> tsqlParser::Raiseerror_statementContext::constant_LOCAL_ID() {
  return getRuleContexts<tsqlParser::Constant_LOCAL_IDContext>();
}

tsqlParser::Constant_LOCAL_IDContext* tsqlParser::Raiseerror_statementContext::constant_LOCAL_ID(size_t i) {
  return getRuleContext<tsqlParser::Constant_LOCAL_IDContext>(i);
}

tree::TerminalNode* tsqlParser::Raiseerror_statementContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tree::TerminalNode* tsqlParser::Raiseerror_statementContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}

tree::TerminalNode* tsqlParser::Raiseerror_statementContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* tsqlParser::Raiseerror_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Raiseerror_statementContext::getRuleIndex() const {
  return tsqlParser::RuleRaiseerror_statement;
}


antlrcpp::Any tsqlParser::Raiseerror_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitRaiseerror_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Raiseerror_statementContext* tsqlParser::raiseerror_statement() {
  Raiseerror_statementContext *_localctx = _tracker.createInstance<Raiseerror_statementContext>(_ctx, getState());
  enterRule(_localctx, 40, tsqlParser::RuleRaiseerror_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(609);
    match(tsqlParser::RAISERROR);
    setState(610);
    match(tsqlParser::LR_BRACKET);
    setState(611);
    dynamic_cast<Raiseerror_statementContext *>(_localctx)->msg = _input->LT(1);
    _la = _input->LA(1);
    if (!(((((_la - 448) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 448)) & ((1ULL << (tsqlParser::LOCAL_ID - 448))
      | (1ULL << (tsqlParser::DECIMAL - 448))
      | (1ULL << (tsqlParser::STRING - 448)))) != 0))) {
      dynamic_cast<Raiseerror_statementContext *>(_localctx)->msg = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(612);
    match(tsqlParser::COMMA);
    setState(613);
    dynamic_cast<Raiseerror_statementContext *>(_localctx)->severity = constant_LOCAL_ID();
    setState(614);
    match(tsqlParser::COMMA);
    setState(615);
    dynamic_cast<Raiseerror_statementContext *>(_localctx)->state = constant_LOCAL_ID();
    setState(620);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(616);
      match(tsqlParser::COMMA);
      setState(617);
      constant_LOCAL_ID();
      setState(622);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(623);
    match(tsqlParser::RR_BRACKET);
    setState(625);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      setState(624);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Another_statementContext ------------------------------------------------------------------

tsqlParser::Another_statementContext::Another_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Cursor_statementContext* tsqlParser::Another_statementContext::cursor_statement() {
  return getRuleContext<tsqlParser::Cursor_statementContext>(0);
}

tsqlParser::Execute_statementContext* tsqlParser::Another_statementContext::execute_statement() {
  return getRuleContext<tsqlParser::Execute_statementContext>(0);
}

tsqlParser::Security_statementContext* tsqlParser::Another_statementContext::security_statement() {
  return getRuleContext<tsqlParser::Security_statementContext>(0);
}

tsqlParser::Set_statementContext* tsqlParser::Another_statementContext::set_statement() {
  return getRuleContext<tsqlParser::Set_statementContext>(0);
}

tsqlParser::Transaction_statementContext* tsqlParser::Another_statementContext::transaction_statement() {
  return getRuleContext<tsqlParser::Transaction_statementContext>(0);
}

tsqlParser::Use_statementContext* tsqlParser::Another_statementContext::use_statement() {
  return getRuleContext<tsqlParser::Use_statementContext>(0);
}


size_t tsqlParser::Another_statementContext::getRuleIndex() const {
  return tsqlParser::RuleAnother_statement;
}


antlrcpp::Any tsqlParser::Another_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitAnother_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Another_statementContext* tsqlParser::another_statement() {
  Another_statementContext *_localctx = _tracker.createInstance<Another_statementContext>(_ctx, getState());
  enterRule(_localctx, 42, tsqlParser::RuleAnother_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(633);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(627);
      cursor_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(628);
      execute_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(629);
      security_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(630);
      set_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(631);
      transaction_statement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(632);
      use_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_statementContext ------------------------------------------------------------------

tsqlParser::Delete_statementContext::Delete_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Delete_statementContext::DELETE() {
  return getToken(tsqlParser::DELETE, 0);
}

tsqlParser::Delete_statement_fromContext* tsqlParser::Delete_statementContext::delete_statement_from() {
  return getRuleContext<tsqlParser::Delete_statement_fromContext>(0);
}

tsqlParser::With_expressionContext* tsqlParser::Delete_statementContext::with_expression() {
  return getRuleContext<tsqlParser::With_expressionContext>(0);
}

tsqlParser::Top_clause_dmContext* tsqlParser::Delete_statementContext::top_clause_dm() {
  return getRuleContext<tsqlParser::Top_clause_dmContext>(0);
}

std::vector<tree::TerminalNode *> tsqlParser::Delete_statementContext::FROM() {
  return getTokens(tsqlParser::FROM);
}

tree::TerminalNode* tsqlParser::Delete_statementContext::FROM(size_t i) {
  return getToken(tsqlParser::FROM, i);
}

tsqlParser::Insert_with_table_hintsContext* tsqlParser::Delete_statementContext::insert_with_table_hints() {
  return getRuleContext<tsqlParser::Insert_with_table_hintsContext>(0);
}

tsqlParser::Output_clauseContext* tsqlParser::Delete_statementContext::output_clause() {
  return getRuleContext<tsqlParser::Output_clauseContext>(0);
}

tsqlParser::Table_sourcesContext* tsqlParser::Delete_statementContext::table_sources() {
  return getRuleContext<tsqlParser::Table_sourcesContext>(0);
}

tsqlParser::Where_clause_dmlContext* tsqlParser::Delete_statementContext::where_clause_dml() {
  return getRuleContext<tsqlParser::Where_clause_dmlContext>(0);
}

tsqlParser::For_clauseContext* tsqlParser::Delete_statementContext::for_clause() {
  return getRuleContext<tsqlParser::For_clauseContext>(0);
}

tsqlParser::Option_clauseContext* tsqlParser::Delete_statementContext::option_clause() {
  return getRuleContext<tsqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* tsqlParser::Delete_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Delete_statementContext::getRuleIndex() const {
  return tsqlParser::RuleDelete_statement;
}


antlrcpp::Any tsqlParser::Delete_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDelete_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Delete_statementContext* tsqlParser::delete_statement() {
  Delete_statementContext *_localctx = _tracker.createInstance<Delete_statementContext>(_ctx, getState());
  enterRule(_localctx, 44, tsqlParser::RuleDelete_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(636);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WITH) {
      setState(635);
      with_expression();
    }
    setState(638);
    match(tsqlParser::DELETE);
    setState(640);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::TOP) {
      setState(639);
      top_clause_dm();
    }
    setState(643);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::FROM) {
      setState(642);
      match(tsqlParser::FROM);
    }
    setState(645);
    delete_statement_from();
    setState(647);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(646);
      insert_with_table_hints();
      break;
    }

    default:
      break;
    }
    setState(650);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
    case 1: {
      setState(649);
      output_clause();
      break;
    }

    default:
      break;
    }
    setState(654);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::FROM) {
      setState(652);
      match(tsqlParser::FROM);
      setState(653);
      table_sources();
    }
    setState(657);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WHERE) {
      setState(656);
      where_clause_dml();
    }
    setState(660);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::FOR) {
      setState(659);
      for_clause();
    }
    setState(663);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::OPTION) {
      setState(662);
      option_clause();
    }
    setState(666);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
    case 1: {
      setState(665);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_statement_fromContext ------------------------------------------------------------------

tsqlParser::Delete_statement_fromContext::Delete_statement_fromContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::R_idContext* tsqlParser::Delete_statement_fromContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tsqlParser::With_table_hintsContext* tsqlParser::Delete_statement_fromContext::with_table_hints() {
  return getRuleContext<tsqlParser::With_table_hintsContext>(0);
}

tsqlParser::Ddl_objectContext* tsqlParser::Delete_statement_fromContext::ddl_object() {
  return getRuleContext<tsqlParser::Ddl_objectContext>(0);
}

tsqlParser::Rowset_function_limitedContext* tsqlParser::Delete_statement_fromContext::rowset_function_limited() {
  return getRuleContext<tsqlParser::Rowset_function_limitedContext>(0);
}

tree::TerminalNode* tsqlParser::Delete_statement_fromContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}


size_t tsqlParser::Delete_statement_fromContext::getRuleIndex() const {
  return tsqlParser::RuleDelete_statement_from;
}


antlrcpp::Any tsqlParser::Delete_statement_fromContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDelete_statement_from(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Delete_statement_fromContext* tsqlParser::delete_statement_from() {
  Delete_statement_fromContext *_localctx = _tracker.createInstance<Delete_statement_fromContext>(_ctx, getState());
  enterRule(_localctx, 46, tsqlParser::RuleDelete_statement_from);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(675);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(668);
      r_id();
      setState(670);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
      case 1: {
        setState(669);
        with_table_hints();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(672);
      ddl_object();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(673);
      rowset_function_limited();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(674);
      dynamic_cast<Delete_statement_fromContext *>(_localctx)->table_var = match(tsqlParser::LOCAL_ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_statementContext ------------------------------------------------------------------

tsqlParser::Insert_statementContext::Insert_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Insert_statementContext::INSERT() {
  return getToken(tsqlParser::INSERT, 0);
}

tsqlParser::Insert_statement_valueContext* tsqlParser::Insert_statementContext::insert_statement_value() {
  return getRuleContext<tsqlParser::Insert_statement_valueContext>(0);
}

tsqlParser::Ddl_objectContext* tsqlParser::Insert_statementContext::ddl_object() {
  return getRuleContext<tsqlParser::Ddl_objectContext>(0);
}

tsqlParser::Rowset_function_limitedContext* tsqlParser::Insert_statementContext::rowset_function_limited() {
  return getRuleContext<tsqlParser::Rowset_function_limitedContext>(0);
}

tsqlParser::With_expressionContext* tsqlParser::Insert_statementContext::with_expression() {
  return getRuleContext<tsqlParser::With_expressionContext>(0);
}

tsqlParser::Top_clause_dmContext* tsqlParser::Insert_statementContext::top_clause_dm() {
  return getRuleContext<tsqlParser::Top_clause_dmContext>(0);
}

tree::TerminalNode* tsqlParser::Insert_statementContext::INTO() {
  return getToken(tsqlParser::INTO, 0);
}

tsqlParser::Insert_with_table_hintsContext* tsqlParser::Insert_statementContext::insert_with_table_hints() {
  return getRuleContext<tsqlParser::Insert_with_table_hintsContext>(0);
}

tree::TerminalNode* tsqlParser::Insert_statementContext::FROM() {
  return getToken(tsqlParser::FROM, 0);
}

tsqlParser::Derived_tableContext* tsqlParser::Insert_statementContext::derived_table() {
  return getRuleContext<tsqlParser::Derived_tableContext>(0);
}

tree::TerminalNode* tsqlParser::Insert_statementContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Column_name_listContext* tsqlParser::Insert_statementContext::column_name_list() {
  return getRuleContext<tsqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* tsqlParser::Insert_statementContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::Output_clauseContext* tsqlParser::Insert_statementContext::output_clause() {
  return getRuleContext<tsqlParser::Output_clauseContext>(0);
}

tsqlParser::For_clauseContext* tsqlParser::Insert_statementContext::for_clause() {
  return getRuleContext<tsqlParser::For_clauseContext>(0);
}

tsqlParser::Option_clauseContext* tsqlParser::Insert_statementContext::option_clause() {
  return getRuleContext<tsqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* tsqlParser::Insert_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Insert_statementContext::getRuleIndex() const {
  return tsqlParser::RuleInsert_statement;
}


antlrcpp::Any tsqlParser::Insert_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitInsert_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Insert_statementContext* tsqlParser::insert_statement() {
  Insert_statementContext *_localctx = _tracker.createInstance<Insert_statementContext>(_ctx, getState());
  enterRule(_localctx, 48, tsqlParser::RuleInsert_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(678);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WITH) {
      setState(677);
      with_expression();
    }
    setState(680);
    match(tsqlParser::INSERT);
    setState(682);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::TOP) {
      setState(681);
      top_clause_dm();
    }
    setState(685);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::INTO) {
      setState(684);
      match(tsqlParser::INTO);
    }
    setState(689);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::LOCAL_ID:
      case tsqlParser::ID: {
        setState(687);
        ddl_object();
        break;
      }

      case tsqlParser::OPENDATASOURCE:
      case tsqlParser::OPENQUERY: {
        setState(688);
        rowset_function_limited();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(692);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      setState(691);
      insert_with_table_hints();
      break;
    }

    default:
      break;
    }
    setState(696);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::FROM) {
      setState(694);
      match(tsqlParser::FROM);
      setState(695);
      derived_table();
    }
    setState(702);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
    case 1: {
      setState(698);
      match(tsqlParser::LR_BRACKET);
      setState(699);
      column_name_list();
      setState(700);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(705);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::OUTPUT) {
      setState(704);
      output_clause();
    }
    setState(707);
    insert_statement_value();
    setState(709);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::FOR) {
      setState(708);
      for_clause();
    }
    setState(712);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::OPTION) {
      setState(711);
      option_clause();
    }
    setState(715);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
    case 1: {
      setState(714);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_statement_valueContext ------------------------------------------------------------------

tsqlParser::Insert_statement_valueContext::Insert_statement_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Table_value_constructorContext* tsqlParser::Insert_statement_valueContext::table_value_constructor() {
  return getRuleContext<tsqlParser::Table_value_constructorContext>(0);
}

tsqlParser::Derived_tableContext* tsqlParser::Insert_statement_valueContext::derived_table() {
  return getRuleContext<tsqlParser::Derived_tableContext>(0);
}

tsqlParser::Execute_statementContext* tsqlParser::Insert_statement_valueContext::execute_statement() {
  return getRuleContext<tsqlParser::Execute_statementContext>(0);
}

tree::TerminalNode* tsqlParser::Insert_statement_valueContext::DEFAULT() {
  return getToken(tsqlParser::DEFAULT, 0);
}

tree::TerminalNode* tsqlParser::Insert_statement_valueContext::VALUES() {
  return getToken(tsqlParser::VALUES, 0);
}


size_t tsqlParser::Insert_statement_valueContext::getRuleIndex() const {
  return tsqlParser::RuleInsert_statement_value;
}


antlrcpp::Any tsqlParser::Insert_statement_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitInsert_statement_value(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Insert_statement_valueContext* tsqlParser::insert_statement_value() {
  Insert_statement_valueContext *_localctx = _tracker.createInstance<Insert_statement_valueContext>(_ctx, getState());
  enterRule(_localctx, 50, tsqlParser::RuleInsert_statement_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(722);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::VALUES: {
        enterOuterAlt(_localctx, 1);
        setState(717);
        table_value_constructor();
        break;
      }

      case tsqlParser::SELECT:
      case tsqlParser::WITH:
      case tsqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(718);
        derived_table();
        break;
      }

      case tsqlParser::EXECUTE: {
        enterOuterAlt(_localctx, 3);
        setState(719);
        execute_statement();
        break;
      }

      case tsqlParser::DEFAULT: {
        enterOuterAlt(_localctx, 4);
        setState(720);
        match(tsqlParser::DEFAULT);
        setState(721);
        match(tsqlParser::VALUES);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_statementContext ------------------------------------------------------------------

tsqlParser::Select_statementContext::Select_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Query_expressionContext* tsqlParser::Select_statementContext::query_expression() {
  return getRuleContext<tsqlParser::Query_expressionContext>(0);
}

tsqlParser::With_expressionContext* tsqlParser::Select_statementContext::with_expression() {
  return getRuleContext<tsqlParser::With_expressionContext>(0);
}

tsqlParser::Order_by_clauseContext* tsqlParser::Select_statementContext::order_by_clause() {
  return getRuleContext<tsqlParser::Order_by_clauseContext>(0);
}

tsqlParser::For_clauseContext* tsqlParser::Select_statementContext::for_clause() {
  return getRuleContext<tsqlParser::For_clauseContext>(0);
}

tsqlParser::Option_clauseContext* tsqlParser::Select_statementContext::option_clause() {
  return getRuleContext<tsqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* tsqlParser::Select_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Select_statementContext::getRuleIndex() const {
  return tsqlParser::RuleSelect_statement;
}


antlrcpp::Any tsqlParser::Select_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSelect_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Select_statementContext* tsqlParser::select_statement() {
  Select_statementContext *_localctx = _tracker.createInstance<Select_statementContext>(_ctx, getState());
  enterRule(_localctx, 52, tsqlParser::RuleSelect_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(725);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WITH) {
      setState(724);
      with_expression();
    }
    setState(727);
    query_expression(0);
    setState(729);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
    case 1: {
      setState(728);
      order_by_clause();
      break;
    }

    default:
      break;
    }
    setState(732);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
    case 1: {
      setState(731);
      for_clause();
      break;
    }

    default:
      break;
    }
    setState(735);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
    case 1: {
      setState(734);
      option_clause();
      break;
    }

    default:
      break;
    }
    setState(738);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      setState(737);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_statementContext ------------------------------------------------------------------

tsqlParser::Update_statementContext::Update_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Update_statementContext::UPDATE() {
  return getToken(tsqlParser::UPDATE, 0);
}

tree::TerminalNode* tsqlParser::Update_statementContext::SET() {
  return getToken(tsqlParser::SET, 0);
}

std::vector<tsqlParser::Update_elemContext *> tsqlParser::Update_statementContext::update_elem() {
  return getRuleContexts<tsqlParser::Update_elemContext>();
}

tsqlParser::Update_elemContext* tsqlParser::Update_statementContext::update_elem(size_t i) {
  return getRuleContext<tsqlParser::Update_elemContext>(i);
}

tsqlParser::Ddl_objectContext* tsqlParser::Update_statementContext::ddl_object() {
  return getRuleContext<tsqlParser::Ddl_objectContext>(0);
}

tsqlParser::Rowset_function_limitedContext* tsqlParser::Update_statementContext::rowset_function_limited() {
  return getRuleContext<tsqlParser::Rowset_function_limitedContext>(0);
}

tsqlParser::With_expressionContext* tsqlParser::Update_statementContext::with_expression() {
  return getRuleContext<tsqlParser::With_expressionContext>(0);
}

tsqlParser::Top_clause_dmContext* tsqlParser::Update_statementContext::top_clause_dm() {
  return getRuleContext<tsqlParser::Top_clause_dmContext>(0);
}

tsqlParser::With_table_hintsContext* tsqlParser::Update_statementContext::with_table_hints() {
  return getRuleContext<tsqlParser::With_table_hintsContext>(0);
}

std::vector<tree::TerminalNode *> tsqlParser::Update_statementContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Update_statementContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tsqlParser::Output_clauseContext* tsqlParser::Update_statementContext::output_clause() {
  return getRuleContext<tsqlParser::Output_clauseContext>(0);
}

tree::TerminalNode* tsqlParser::Update_statementContext::FROM() {
  return getToken(tsqlParser::FROM, 0);
}

tsqlParser::Table_sourcesContext* tsqlParser::Update_statementContext::table_sources() {
  return getRuleContext<tsqlParser::Table_sourcesContext>(0);
}

tsqlParser::Where_clause_dmlContext* tsqlParser::Update_statementContext::where_clause_dml() {
  return getRuleContext<tsqlParser::Where_clause_dmlContext>(0);
}

tsqlParser::For_clauseContext* tsqlParser::Update_statementContext::for_clause() {
  return getRuleContext<tsqlParser::For_clauseContext>(0);
}

tsqlParser::Option_clauseContext* tsqlParser::Update_statementContext::option_clause() {
  return getRuleContext<tsqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* tsqlParser::Update_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Update_statementContext::getRuleIndex() const {
  return tsqlParser::RuleUpdate_statement;
}


antlrcpp::Any tsqlParser::Update_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitUpdate_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Update_statementContext* tsqlParser::update_statement() {
  Update_statementContext *_localctx = _tracker.createInstance<Update_statementContext>(_ctx, getState());
  enterRule(_localctx, 54, tsqlParser::RuleUpdate_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(741);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WITH) {
      setState(740);
      with_expression();
    }
    setState(743);
    match(tsqlParser::UPDATE);
    setState(745);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::TOP) {
      setState(744);
      top_clause_dm();
    }
    setState(749);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::LOCAL_ID:
      case tsqlParser::ID: {
        setState(747);
        ddl_object();
        break;
      }

      case tsqlParser::OPENDATASOURCE:
      case tsqlParser::OPENQUERY: {
        setState(748);
        rowset_function_limited();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(752);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WITH || _la == tsqlParser::LR_BRACKET) {
      setState(751);
      with_table_hints();
    }
    setState(754);
    match(tsqlParser::SET);
    setState(755);
    update_elem();
    setState(760);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(756);
      match(tsqlParser::COMMA);
      setState(757);
      update_elem();
      setState(762);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(764);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      setState(763);
      output_clause();
      break;
    }

    default:
      break;
    }
    setState(768);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::FROM) {
      setState(766);
      match(tsqlParser::FROM);
      setState(767);
      table_sources();
    }
    setState(771);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WHERE) {
      setState(770);
      where_clause_dml();
    }
    setState(774);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::FOR) {
      setState(773);
      for_clause();
    }
    setState(777);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::OPTION) {
      setState(776);
      option_clause();
    }
    setState(780);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
    case 1: {
      setState(779);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_clause_dmlContext ------------------------------------------------------------------

tsqlParser::Where_clause_dmlContext::Where_clause_dmlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Where_clause_dmlContext::WHERE() {
  return getToken(tsqlParser::WHERE, 0);
}

tsqlParser::Search_condition_listContext* tsqlParser::Where_clause_dmlContext::search_condition_list() {
  return getRuleContext<tsqlParser::Search_condition_listContext>(0);
}

tree::TerminalNode* tsqlParser::Where_clause_dmlContext::CURRENT() {
  return getToken(tsqlParser::CURRENT, 0);
}

tree::TerminalNode* tsqlParser::Where_clause_dmlContext::OF() {
  return getToken(tsqlParser::OF, 0);
}

tsqlParser::Cursor_nameContext* tsqlParser::Where_clause_dmlContext::cursor_name() {
  return getRuleContext<tsqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Where_clause_dmlContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* tsqlParser::Where_clause_dmlContext::GLOBAL() {
  return getToken(tsqlParser::GLOBAL, 0);
}


size_t tsqlParser::Where_clause_dmlContext::getRuleIndex() const {
  return tsqlParser::RuleWhere_clause_dml;
}


antlrcpp::Any tsqlParser::Where_clause_dmlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitWhere_clause_dml(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Where_clause_dmlContext* tsqlParser::where_clause_dml() {
  Where_clause_dmlContext *_localctx = _tracker.createInstance<Where_clause_dmlContext>(_ctx, getState());
  enterRule(_localctx, 56, tsqlParser::RuleWhere_clause_dml);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(782);
    match(tsqlParser::WHERE);
    setState(793);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::CASE:
      case tsqlParser::COALESCE:
      case tsqlParser::CONVERT:
      case tsqlParser::CURRENT_TIMESTAMP:
      case tsqlParser::CURRENT_USER:
      case tsqlParser::DEFAULT:
      case tsqlParser::EXISTS:
      case tsqlParser::EXP:
      case tsqlParser::FORCESEEK:
      case tsqlParser::IDENTITY:
      case tsqlParser::IIF:
      case tsqlParser::LEFT:
      case tsqlParser::LOG:
      case tsqlParser::LOG10:
      case tsqlParser::NEXT:
      case tsqlParser::NOT:
      case tsqlParser::NULL_:
      case tsqlParser::NULLIF:
      case tsqlParser::NUMERIC:
      case tsqlParser::OVER:
      case tsqlParser::RIGHT:
      case tsqlParser::SESSION_USER:
      case tsqlParser::SIGN:
      case tsqlParser::SYSTEM_USER:
      case tsqlParser::TRY_CAST:
      case tsqlParser::TRY_CONVERT:
      case tsqlParser::TRY_PARSE:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::BINARY_CHECKSUM:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CEILING:
      case tsqlParser::CHECKSUM:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COS:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DATEADD:
      case tsqlParser::DATEDIFF:
      case tsqlParser::DATENAME:
      case tsqlParser::DATEPART:
      case tsqlParser::DATETIMEOFFSETFROMPARTS:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FLOOR:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MIN_ACTIVE_ROWVERSION:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARSE:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PERCENTILE_CONT:
      case tsqlParser::POWER:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROUND:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIN:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::STRING_AGG:
      case tsqlParser::STRING_SPLIT:
      case tsqlParser::SUM:
      case tsqlParser::SQRT:
      case tsqlParser::SQUARE:
      case tsqlParser::TAN:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::LOCAL_ID:
      case tsqlParser::DECIMAL:
      case tsqlParser::ID:
      case tsqlParser::STRING:
      case tsqlParser::BINARY:
      case tsqlParser::FLOAT:
      case tsqlParser::REAL:
      case tsqlParser::DOLLAR:
      case tsqlParser::LR_BRACKET:
      case tsqlParser::PLUS:
      case tsqlParser::MINUS:
      case tsqlParser::BIT_NOT: {
        setState(783);
        search_condition_list();
        break;
      }

      case tsqlParser::CURRENT: {
        setState(784);
        match(tsqlParser::CURRENT);
        setState(785);
        match(tsqlParser::OF);
        setState(791);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
        case 1: {
          setState(787);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
          case 1: {
            setState(786);
            match(tsqlParser::GLOBAL);
            break;
          }

          default:
            break;
          }
          setState(789);
          cursor_name();
          break;
        }

        case 2: {
          setState(790);
          dynamic_cast<Where_clause_dmlContext *>(_localctx)->cursor_var = match(tsqlParser::LOCAL_ID);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_clauseContext ------------------------------------------------------------------

tsqlParser::Output_clauseContext::Output_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Output_clauseContext::OUTPUT() {
  return getToken(tsqlParser::OUTPUT, 0);
}

std::vector<tsqlParser::Output_dml_list_elemContext *> tsqlParser::Output_clauseContext::output_dml_list_elem() {
  return getRuleContexts<tsqlParser::Output_dml_list_elemContext>();
}

tsqlParser::Output_dml_list_elemContext* tsqlParser::Output_clauseContext::output_dml_list_elem(size_t i) {
  return getRuleContext<tsqlParser::Output_dml_list_elemContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Output_clauseContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Output_clauseContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::Output_clauseContext::INTO() {
  return getToken(tsqlParser::INTO, 0);
}

tree::TerminalNode* tsqlParser::Output_clauseContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Output_clauseContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Output_clauseContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Column_name_listContext* tsqlParser::Output_clauseContext::column_name_list() {
  return getRuleContext<tsqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* tsqlParser::Output_clauseContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}


size_t tsqlParser::Output_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleOutput_clause;
}


antlrcpp::Any tsqlParser::Output_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOutput_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Output_clauseContext* tsqlParser::output_clause() {
  Output_clauseContext *_localctx = _tracker.createInstance<Output_clauseContext>(_ctx, getState());
  enterRule(_localctx, 58, tsqlParser::RuleOutput_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(795);
    match(tsqlParser::OUTPUT);
    setState(796);
    output_dml_list_elem();
    setState(801);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(797);
      match(tsqlParser::COMMA);
      setState(798);
      output_dml_list_elem();
      setState(803);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(815);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::INTO) {
      setState(804);
      match(tsqlParser::INTO);
      setState(807);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case tsqlParser::LOCAL_ID: {
          setState(805);
          match(tsqlParser::LOCAL_ID);
          break;
        }

        case tsqlParser::FORCESEEK:
        case tsqlParser::NEXT:
        case tsqlParser::NUMERIC:
        case tsqlParser::VALUE:
        case tsqlParser::ABSOLUTE:
        case tsqlParser::APPLY:
        case tsqlParser::AUTO:
        case tsqlParser::AVG:
        case tsqlParser::BASE64:
        case tsqlParser::CALLER:
        case tsqlParser::CAST:
        case tsqlParser::CATCH:
        case tsqlParser::CHECKSUM_AGG:
        case tsqlParser::COMMITTED:
        case tsqlParser::CONCAT:
        case tsqlParser::CONTROL:
        case tsqlParser::COOKIE:
        case tsqlParser::COUNT:
        case tsqlParser::COUNT_BIG:
        case tsqlParser::DATE:
        case tsqlParser::DELAY:
        case tsqlParser::DELETED:
        case tsqlParser::DENSE_RANK:
        case tsqlParser::DISABLE:
        case tsqlParser::DYNAMIC:
        case tsqlParser::ENCRYPTION:
        case tsqlParser::EXIST:
        case tsqlParser::EXPAND:
        case tsqlParser::FAST:
        case tsqlParser::FAST_FORWARD:
        case tsqlParser::FIRST:
        case tsqlParser::FIRST_VALUE:
        case tsqlParser::FOLLOWING:
        case tsqlParser::FORCE:
        case tsqlParser::FORCED:
        case tsqlParser::FORWARD_ONLY:
        case tsqlParser::FULLSCAN:
        case tsqlParser::GLOBAL:
        case tsqlParser::GROUPING:
        case tsqlParser::GROUPING_ID:
        case tsqlParser::HASH:
        case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
        case tsqlParser::IMPERSONATE:
        case tsqlParser::INSENSITIVE:
        case tsqlParser::INSERTED:
        case tsqlParser::ISOLATION:
        case tsqlParser::IO:
        case tsqlParser::KEEP:
        case tsqlParser::KEEPFIXED:
        case tsqlParser::KEYSET:
        case tsqlParser::LAG:
        case tsqlParser::LAST:
        case tsqlParser::LAST_VALUE:
        case tsqlParser::LEAD:
        case tsqlParser::LEVEL:
        case tsqlParser::LOCAL:
        case tsqlParser::LOCK_ESCALATION:
        case tsqlParser::LOGIN:
        case tsqlParser::LOOP:
        case tsqlParser::MARK:
        case tsqlParser::MAX:
        case tsqlParser::MAXDOP:
        case tsqlParser::MAXRECURSION:
        case tsqlParser::MIN:
        case tsqlParser::MODIFY:
        case tsqlParser::NAME:
        case tsqlParser::NOCOUNT:
        case tsqlParser::NODES:
        case tsqlParser::NOEXPAND:
        case tsqlParser::NORECOMPUTE:
        case tsqlParser::NTILE:
        case tsqlParser::NUMBER:
        case tsqlParser::OFFSET:
        case tsqlParser::ONLINE:
        case tsqlParser::ONLY:
        case tsqlParser::OPTIMISTIC:
        case tsqlParser::OPTIMIZE:
        case tsqlParser::OUT:
        case tsqlParser::OUTPUT:
        case tsqlParser::OWNER:
        case tsqlParser::PARAMETERIZATION:
        case tsqlParser::PARTITION:
        case tsqlParser::PATH:
        case tsqlParser::PRECEDING:
        case tsqlParser::PRIOR:
        case tsqlParser::PRIVILEGES:
        case tsqlParser::QUERY:
        case tsqlParser::RANGE:
        case tsqlParser::RANK:
        case tsqlParser::READONLY:
        case tsqlParser::READ_ONLY:
        case tsqlParser::RECOMPILE:
        case tsqlParser::RELATIVE:
        case tsqlParser::REMOTE:
        case tsqlParser::REPEATABLE:
        case tsqlParser::ROBUST:
        case tsqlParser::ROOT:
        case tsqlParser::ROW:
        case tsqlParser::ROWGUID:
        case tsqlParser::ROWS:
        case tsqlParser::ROW_NUMBER:
        case tsqlParser::SAMPLE:
        case tsqlParser::SCHEMABINDING:
        case tsqlParser::SCROLL:
        case tsqlParser::SCROLL_LOCKS:
        case tsqlParser::SELF:
        case tsqlParser::SERIALIZABLE:
        case tsqlParser::SIMPLE:
        case tsqlParser::SIZE:
        case tsqlParser::SNAPSHOT:
        case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case tsqlParser::STATIC:
        case tsqlParser::STATS_STREAM:
        case tsqlParser::STDEV:
        case tsqlParser::STDEVP:
        case tsqlParser::SUM:
        case tsqlParser::TEXTIMAGE_ON:
        case tsqlParser::THROW:
        case tsqlParser::TIES:
        case tsqlParser::TIME:
        case tsqlParser::TRY:
        case tsqlParser::TYPE:
        case tsqlParser::TYPE_WARNING:
        case tsqlParser::UNBOUNDED:
        case tsqlParser::UNCOMMITTED:
        case tsqlParser::UNKNOWN:
        case tsqlParser::USING:
        case tsqlParser::VAR:
        case tsqlParser::VARP:
        case tsqlParser::VIEWS:
        case tsqlParser::VIEW_METADATA:
        case tsqlParser::WORK:
        case tsqlParser::XML:
        case tsqlParser::XMLNAMESPACES:
        case tsqlParser::ZONE:
        case tsqlParser::DOUBLE_QUOTE_ID:
        case tsqlParser::SQUARE_BRACKET_ID:
        case tsqlParser::ID: {
          setState(806);
          table_name();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(813);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
      case 1: {
        setState(809);
        match(tsqlParser::LR_BRACKET);
        setState(810);
        column_name_list();
        setState(811);
        match(tsqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_dml_list_elemContext ------------------------------------------------------------------

tsqlParser::Output_dml_list_elemContext::Output_dml_list_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Output_column_nameContext* tsqlParser::Output_dml_list_elemContext::output_column_name() {
  return getRuleContext<tsqlParser::Output_column_nameContext>(0);
}

tsqlParser::ExpressionContext* tsqlParser::Output_dml_list_elemContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tsqlParser::Column_aliasContext* tsqlParser::Output_dml_list_elemContext::column_alias() {
  return getRuleContext<tsqlParser::Column_aliasContext>(0);
}

tree::TerminalNode* tsqlParser::Output_dml_list_elemContext::AS() {
  return getToken(tsqlParser::AS, 0);
}


size_t tsqlParser::Output_dml_list_elemContext::getRuleIndex() const {
  return tsqlParser::RuleOutput_dml_list_elem;
}


antlrcpp::Any tsqlParser::Output_dml_list_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOutput_dml_list_elem(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Output_dml_list_elemContext* tsqlParser::output_dml_list_elem() {
  Output_dml_list_elemContext *_localctx = _tracker.createInstance<Output_dml_list_elemContext>(_ctx, getState());
  enterRule(_localctx, 60, tsqlParser::RuleOutput_dml_list_elem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(819);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx)) {
    case 1: {
      setState(817);
      output_column_name();
      break;
    }

    case 2: {
      setState(818);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(825);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
    case 1: {
      setState(822);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::AS) {
        setState(821);
        match(tsqlParser::AS);
      }
      setState(824);
      column_alias();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_column_nameContext ------------------------------------------------------------------

tsqlParser::Output_column_nameContext::Output_column_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Output_column_nameContext::DOT() {
  return getToken(tsqlParser::DOT, 0);
}

tree::TerminalNode* tsqlParser::Output_column_nameContext::DELETED() {
  return getToken(tsqlParser::DELETED, 0);
}

tree::TerminalNode* tsqlParser::Output_column_nameContext::INSERTED() {
  return getToken(tsqlParser::INSERTED, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Output_column_nameContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Output_column_nameContext::STAR() {
  return getToken(tsqlParser::STAR, 0);
}

tsqlParser::R_idContext* tsqlParser::Output_column_nameContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Output_column_nameContext::DOLLAR_ACTION() {
  return getToken(tsqlParser::DOLLAR_ACTION, 0);
}


size_t tsqlParser::Output_column_nameContext::getRuleIndex() const {
  return tsqlParser::RuleOutput_column_name;
}


antlrcpp::Any tsqlParser::Output_column_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOutput_column_name(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Output_column_nameContext* tsqlParser::output_column_name() {
  Output_column_nameContext *_localctx = _tracker.createInstance<Output_column_nameContext>(_ctx, getState());
  enterRule(_localctx, 62, tsqlParser::RuleOutput_column_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(838);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(830);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx)) {
        case 1: {
          setState(827);
          match(tsqlParser::DELETED);
          break;
        }

        case 2: {
          setState(828);
          match(tsqlParser::INSERTED);
          break;
        }

        case 3: {
          setState(829);
          table_name();
          break;
        }

        default:
          break;
        }
        setState(832);
        match(tsqlParser::DOT);
        setState(835);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::STAR: {
            setState(833);
            match(tsqlParser::STAR);
            break;
          }

          case tsqlParser::FORCESEEK:
          case tsqlParser::NEXT:
          case tsqlParser::NUMERIC:
          case tsqlParser::VALUE:
          case tsqlParser::ABSOLUTE:
          case tsqlParser::APPLY:
          case tsqlParser::AUTO:
          case tsqlParser::AVG:
          case tsqlParser::BASE64:
          case tsqlParser::CALLER:
          case tsqlParser::CAST:
          case tsqlParser::CATCH:
          case tsqlParser::CHECKSUM_AGG:
          case tsqlParser::COMMITTED:
          case tsqlParser::CONCAT:
          case tsqlParser::CONTROL:
          case tsqlParser::COOKIE:
          case tsqlParser::COUNT:
          case tsqlParser::COUNT_BIG:
          case tsqlParser::DATE:
          case tsqlParser::DELAY:
          case tsqlParser::DELETED:
          case tsqlParser::DENSE_RANK:
          case tsqlParser::DISABLE:
          case tsqlParser::DYNAMIC:
          case tsqlParser::ENCRYPTION:
          case tsqlParser::EXIST:
          case tsqlParser::EXPAND:
          case tsqlParser::FAST:
          case tsqlParser::FAST_FORWARD:
          case tsqlParser::FIRST:
          case tsqlParser::FIRST_VALUE:
          case tsqlParser::FOLLOWING:
          case tsqlParser::FORCE:
          case tsqlParser::FORCED:
          case tsqlParser::FORWARD_ONLY:
          case tsqlParser::FULLSCAN:
          case tsqlParser::GLOBAL:
          case tsqlParser::GROUPING:
          case tsqlParser::GROUPING_ID:
          case tsqlParser::HASH:
          case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case tsqlParser::IMPERSONATE:
          case tsqlParser::INSENSITIVE:
          case tsqlParser::INSERTED:
          case tsqlParser::ISOLATION:
          case tsqlParser::IO:
          case tsqlParser::KEEP:
          case tsqlParser::KEEPFIXED:
          case tsqlParser::KEYSET:
          case tsqlParser::LAG:
          case tsqlParser::LAST:
          case tsqlParser::LAST_VALUE:
          case tsqlParser::LEAD:
          case tsqlParser::LEVEL:
          case tsqlParser::LOCAL:
          case tsqlParser::LOCK_ESCALATION:
          case tsqlParser::LOGIN:
          case tsqlParser::LOOP:
          case tsqlParser::MARK:
          case tsqlParser::MAX:
          case tsqlParser::MAXDOP:
          case tsqlParser::MAXRECURSION:
          case tsqlParser::MIN:
          case tsqlParser::MODIFY:
          case tsqlParser::NAME:
          case tsqlParser::NOCOUNT:
          case tsqlParser::NODES:
          case tsqlParser::NOEXPAND:
          case tsqlParser::NORECOMPUTE:
          case tsqlParser::NTILE:
          case tsqlParser::NUMBER:
          case tsqlParser::OFFSET:
          case tsqlParser::ONLINE:
          case tsqlParser::ONLY:
          case tsqlParser::OPTIMISTIC:
          case tsqlParser::OPTIMIZE:
          case tsqlParser::OUT:
          case tsqlParser::OUTPUT:
          case tsqlParser::OWNER:
          case tsqlParser::PARAMETERIZATION:
          case tsqlParser::PARTITION:
          case tsqlParser::PATH:
          case tsqlParser::PRECEDING:
          case tsqlParser::PRIOR:
          case tsqlParser::PRIVILEGES:
          case tsqlParser::QUERY:
          case tsqlParser::RANGE:
          case tsqlParser::RANK:
          case tsqlParser::READONLY:
          case tsqlParser::READ_ONLY:
          case tsqlParser::RECOMPILE:
          case tsqlParser::RELATIVE:
          case tsqlParser::REMOTE:
          case tsqlParser::REPEATABLE:
          case tsqlParser::ROBUST:
          case tsqlParser::ROOT:
          case tsqlParser::ROW:
          case tsqlParser::ROWGUID:
          case tsqlParser::ROWS:
          case tsqlParser::ROW_NUMBER:
          case tsqlParser::SAMPLE:
          case tsqlParser::SCHEMABINDING:
          case tsqlParser::SCROLL:
          case tsqlParser::SCROLL_LOCKS:
          case tsqlParser::SELF:
          case tsqlParser::SERIALIZABLE:
          case tsqlParser::SIMPLE:
          case tsqlParser::SIZE:
          case tsqlParser::SNAPSHOT:
          case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case tsqlParser::STATIC:
          case tsqlParser::STATS_STREAM:
          case tsqlParser::STDEV:
          case tsqlParser::STDEVP:
          case tsqlParser::SUM:
          case tsqlParser::TEXTIMAGE_ON:
          case tsqlParser::THROW:
          case tsqlParser::TIES:
          case tsqlParser::TIME:
          case tsqlParser::TRY:
          case tsqlParser::TYPE:
          case tsqlParser::TYPE_WARNING:
          case tsqlParser::UNBOUNDED:
          case tsqlParser::UNCOMMITTED:
          case tsqlParser::UNKNOWN:
          case tsqlParser::USING:
          case tsqlParser::VAR:
          case tsqlParser::VARP:
          case tsqlParser::VIEWS:
          case tsqlParser::VIEW_METADATA:
          case tsqlParser::WORK:
          case tsqlParser::XML:
          case tsqlParser::XMLNAMESPACES:
          case tsqlParser::ZONE:
          case tsqlParser::DOUBLE_QUOTE_ID:
          case tsqlParser::SQUARE_BRACKET_ID:
          case tsqlParser::ID: {
            setState(834);
            r_id();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case tsqlParser::DOLLAR_ACTION: {
        enterOuterAlt(_localctx, 2);
        setState(837);
        match(tsqlParser::DOLLAR_ACTION);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_databaseContext ------------------------------------------------------------------

tsqlParser::Create_databaseContext::Create_databaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Create_databaseContext::CREATE() {
  return getToken(tsqlParser::CREATE, 0);
}

tree::TerminalNode* tsqlParser::Create_databaseContext::DATABASE() {
  return getToken(tsqlParser::DATABASE, 0);
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Create_databaseContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Create_databaseContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

tree::TerminalNode* tsqlParser::Create_databaseContext::CONTAINMENT() {
  return getToken(tsqlParser::CONTAINMENT, 0);
}

tree::TerminalNode* tsqlParser::Create_databaseContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_databaseContext::ON() {
  return getTokens(tsqlParser::ON);
}

tree::TerminalNode* tsqlParser::Create_databaseContext::ON(size_t i) {
  return getToken(tsqlParser::ON, i);
}

std::vector<tsqlParser::Database_file_specContext *> tsqlParser::Create_databaseContext::database_file_spec() {
  return getRuleContexts<tsqlParser::Database_file_specContext>();
}

tsqlParser::Database_file_specContext* tsqlParser::Create_databaseContext::database_file_spec(size_t i) {
  return getRuleContext<tsqlParser::Database_file_specContext>(i);
}

tree::TerminalNode* tsqlParser::Create_databaseContext::LOG() {
  return getToken(tsqlParser::LOG, 0);
}

tree::TerminalNode* tsqlParser::Create_databaseContext::COLLATE() {
  return getToken(tsqlParser::COLLATE, 0);
}

tree::TerminalNode* tsqlParser::Create_databaseContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

std::vector<tsqlParser::Create_database_optionContext *> tsqlParser::Create_databaseContext::create_database_option() {
  return getRuleContexts<tsqlParser::Create_database_optionContext>();
}

tsqlParser::Create_database_optionContext* tsqlParser::Create_databaseContext::create_database_option(size_t i) {
  return getRuleContext<tsqlParser::Create_database_optionContext>(i);
}

tree::TerminalNode* tsqlParser::Create_databaseContext::NONE() {
  return getToken(tsqlParser::NONE, 0);
}

tree::TerminalNode* tsqlParser::Create_databaseContext::PARTIAL() {
  return getToken(tsqlParser::PARTIAL, 0);
}

tree::TerminalNode* tsqlParser::Create_databaseContext::PRIMARY() {
  return getToken(tsqlParser::PRIMARY, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_databaseContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Create_databaseContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Create_databaseContext::getRuleIndex() const {
  return tsqlParser::RuleCreate_database;
}


antlrcpp::Any tsqlParser::Create_databaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_database(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Create_databaseContext* tsqlParser::create_database() {
  Create_databaseContext *_localctx = _tracker.createInstance<Create_databaseContext>(_ctx, getState());
  enterRule(_localctx, 64, tsqlParser::RuleCreate_database);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(840);
    match(tsqlParser::CREATE);
    setState(841);
    match(tsqlParser::DATABASE);

    setState(842);
    dynamic_cast<Create_databaseContext *>(_localctx)->database = r_id();
    setState(846);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::CONTAINMENT) {
      setState(843);
      match(tsqlParser::CONTAINMENT);
      setState(844);
      match(tsqlParser::EQUAL);
      setState(845);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::NONE

      || _la == tsqlParser::PARTIAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(860);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::ON) {
      setState(848);
      match(tsqlParser::ON);
      setState(850);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::PRIMARY) {
        setState(849);
        match(tsqlParser::PRIMARY);
      }
      setState(852);
      database_file_spec();
      setState(857);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(853);
        match(tsqlParser::COMMA);
        setState(854);
        database_file_spec();
        setState(859);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(872);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::LOG) {
      setState(862);
      match(tsqlParser::LOG);
      setState(863);
      match(tsqlParser::ON);
      setState(864);
      database_file_spec();
      setState(869);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(865);
        match(tsqlParser::COMMA);
        setState(866);
        database_file_spec();
        setState(871);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(876);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::COLLATE) {
      setState(874);
      match(tsqlParser::COLLATE);
      setState(875);
      dynamic_cast<Create_databaseContext *>(_localctx)->collation_name = r_id();
    }
    setState(887);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      setState(878);
      match(tsqlParser::WITH);
      setState(879);
      create_database_option();
      setState(884);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(880);
        match(tsqlParser::COMMA);
        setState(881);
        create_database_option();
        setState(886);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_indexContext ------------------------------------------------------------------

tsqlParser::Create_indexContext::Create_indexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Create_indexContext::CREATE() {
  return getToken(tsqlParser::CREATE, 0);
}

tree::TerminalNode* tsqlParser::Create_indexContext::INDEX() {
  return getToken(tsqlParser::INDEX, 0);
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Create_indexContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Create_indexContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_indexContext::ON() {
  return getTokens(tsqlParser::ON);
}

tree::TerminalNode* tsqlParser::Create_indexContext::ON(size_t i) {
  return getToken(tsqlParser::ON, i);
}

tsqlParser::Table_name_with_hintContext* tsqlParser::Create_indexContext::table_name_with_hint() {
  return getRuleContext<tsqlParser::Table_name_with_hintContext>(0);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_indexContext::LR_BRACKET() {
  return getTokens(tsqlParser::LR_BRACKET);
}

tree::TerminalNode* tsqlParser::Create_indexContext::LR_BRACKET(size_t i) {
  return getToken(tsqlParser::LR_BRACKET, i);
}

std::vector<tsqlParser::Column_name_listContext *> tsqlParser::Create_indexContext::column_name_list() {
  return getRuleContexts<tsqlParser::Column_name_listContext>();
}

tsqlParser::Column_name_listContext* tsqlParser::Create_indexContext::column_name_list(size_t i) {
  return getRuleContext<tsqlParser::Column_name_listContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_indexContext::RR_BRACKET() {
  return getTokens(tsqlParser::RR_BRACKET);
}

tree::TerminalNode* tsqlParser::Create_indexContext::RR_BRACKET(size_t i) {
  return getToken(tsqlParser::RR_BRACKET, i);
}

tree::TerminalNode* tsqlParser::Create_indexContext::UNIQUE() {
  return getToken(tsqlParser::UNIQUE, 0);
}

tsqlParser::ClusteredContext* tsqlParser::Create_indexContext::clustered() {
  return getRuleContext<tsqlParser::ClusteredContext>(0);
}

tree::TerminalNode* tsqlParser::Create_indexContext::INCLUDE() {
  return getToken(tsqlParser::INCLUDE, 0);
}

tree::TerminalNode* tsqlParser::Create_indexContext::WHERE() {
  return getToken(tsqlParser::WHERE, 0);
}

tsqlParser::Index_optionsContext* tsqlParser::Create_indexContext::index_options() {
  return getRuleContext<tsqlParser::Index_optionsContext>(0);
}

tree::TerminalNode* tsqlParser::Create_indexContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_indexContext::ASC() {
  return getTokens(tsqlParser::ASC);
}

tree::TerminalNode* tsqlParser::Create_indexContext::ASC(size_t i) {
  return getToken(tsqlParser::ASC, i);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_indexContext::DESC() {
  return getTokens(tsqlParser::DESC);
}

tree::TerminalNode* tsqlParser::Create_indexContext::DESC(size_t i) {
  return getToken(tsqlParser::DESC, i);
}

tsqlParser::Search_conditionContext* tsqlParser::Create_indexContext::search_condition() {
  return getRuleContext<tsqlParser::Search_conditionContext>(0);
}


size_t tsqlParser::Create_indexContext::getRuleIndex() const {
  return tsqlParser::RuleCreate_index;
}


antlrcpp::Any tsqlParser::Create_indexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_index(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Create_indexContext* tsqlParser::create_index() {
  Create_indexContext *_localctx = _tracker.createInstance<Create_indexContext>(_ctx, getState());
  enterRule(_localctx, 66, tsqlParser::RuleCreate_index);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(889);
    match(tsqlParser::CREATE);
    setState(891);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::UNIQUE) {
      setState(890);
      match(tsqlParser::UNIQUE);
    }
    setState(894);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::CLUSTERED || _la == tsqlParser::NONCLUSTERED) {
      setState(893);
      clustered();
    }
    setState(896);
    match(tsqlParser::INDEX);
    setState(897);
    r_id();
    setState(898);
    match(tsqlParser::ON);
    setState(899);
    table_name_with_hint();
    setState(900);
    match(tsqlParser::LR_BRACKET);
    setState(901);
    column_name_list();
    setState(903);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::ASC

    || _la == tsqlParser::DESC) {
      setState(902);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::ASC

      || _la == tsqlParser::DESC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(905);
    match(tsqlParser::RR_BRACKET);
    setState(914);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::INCLUDE) {
      setState(906);
      match(tsqlParser::INCLUDE);
      setState(907);
      match(tsqlParser::LR_BRACKET);
      setState(908);
      column_name_list();
      setState(910);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::ASC

      || _la == tsqlParser::DESC) {
        setState(909);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::ASC

        || _la == tsqlParser::DESC)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(912);
      match(tsqlParser::RR_BRACKET);
    }
    setState(918);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WHERE) {
      setState(916);
      match(tsqlParser::WHERE);
      setState(917);
      dynamic_cast<Create_indexContext *>(_localctx)->where = search_condition(0);
    }
    setState(921);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
    case 1: {
      setState(920);
      index_options();
      break;
    }

    default:
      break;
    }
    setState(925);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::ON) {
      setState(923);
      match(tsqlParser::ON);
      setState(924);
      r_id();
    }
    setState(928);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
    case 1: {
      setState(927);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_statisticsContext ------------------------------------------------------------------

tsqlParser::Create_statisticsContext::Create_statisticsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::CREATE() {
  return getToken(tsqlParser::CREATE, 0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::STATISTICS() {
  return getToken(tsqlParser::STATISTICS, 0);
}

tsqlParser::R_idContext* tsqlParser::Create_statisticsContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

tsqlParser::Table_name_with_hintContext* tsqlParser::Create_statisticsContext::table_name_with_hint() {
  return getRuleContext<tsqlParser::Table_name_with_hintContext>(0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Column_name_listContext* tsqlParser::Create_statisticsContext::column_name_list() {
  return getRuleContext<tsqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::FULLSCAN() {
  return getToken(tsqlParser::FULLSCAN, 0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::SAMPLE() {
  return getToken(tsqlParser::SAMPLE, 0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::STATS_STREAM() {
  return getToken(tsqlParser::STATS_STREAM, 0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::PERCENT() {
  return getToken(tsqlParser::PERCENT, 0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::ROWS() {
  return getToken(tsqlParser::ROWS, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_statisticsContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::NORECOMPUTE() {
  return getToken(tsqlParser::NORECOMPUTE, 0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::INCREMENTAL() {
  return getToken(tsqlParser::INCREMENTAL, 0);
}

tree::TerminalNode* tsqlParser::Create_statisticsContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tsqlParser::On_offContext* tsqlParser::Create_statisticsContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}


size_t tsqlParser::Create_statisticsContext::getRuleIndex() const {
  return tsqlParser::RuleCreate_statistics;
}


antlrcpp::Any tsqlParser::Create_statisticsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_statistics(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Create_statisticsContext* tsqlParser::create_statistics() {
  Create_statisticsContext *_localctx = _tracker.createInstance<Create_statisticsContext>(_ctx, getState());
  enterRule(_localctx, 68, tsqlParser::RuleCreate_statistics);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(930);
    match(tsqlParser::CREATE);
    setState(931);
    match(tsqlParser::STATISTICS);
    setState(932);
    r_id();
    setState(933);
    match(tsqlParser::ON);
    setState(934);
    table_name_with_hint();
    setState(935);
    match(tsqlParser::LR_BRACKET);
    setState(936);
    column_name_list();
    setState(937);
    match(tsqlParser::RR_BRACKET);
    setState(956);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
    case 1: {
      setState(938);
      match(tsqlParser::WITH);
      setState(944);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case tsqlParser::FULLSCAN: {
          setState(939);
          match(tsqlParser::FULLSCAN);
          break;
        }

        case tsqlParser::SAMPLE: {
          setState(940);
          match(tsqlParser::SAMPLE);
          setState(941);
          match(tsqlParser::DECIMAL);
          setState(942);
          _la = _input->LA(1);
          if (!(_la == tsqlParser::PERCENT || _la == tsqlParser::ROWS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        case tsqlParser::STATS_STREAM: {
          setState(943);
          match(tsqlParser::STATS_STREAM);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(948);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
      case 1: {
        setState(946);
        match(tsqlParser::COMMA);
        setState(947);
        match(tsqlParser::NORECOMPUTE);
        break;
      }

      default:
        break;
      }
      setState(954);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::COMMA) {
        setState(950);
        match(tsqlParser::COMMA);
        setState(951);
        match(tsqlParser::INCREMENTAL);
        setState(952);
        match(tsqlParser::EQUAL);
        setState(953);
        on_off();
      }
      break;
    }

    default:
      break;
    }
    setState(959);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
    case 1: {
      setState(958);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_tableContext ------------------------------------------------------------------

tsqlParser::Create_tableContext::Create_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Create_tableContext::CREATE() {
  return getToken(tsqlParser::CREATE, 0);
}

tree::TerminalNode* tsqlParser::Create_tableContext::TABLE() {
  return getToken(tsqlParser::TABLE, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Create_tableContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Create_tableContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Column_def_table_constraintsContext* tsqlParser::Create_tableContext::column_def_table_constraints() {
  return getRuleContext<tsqlParser::Column_def_table_constraintsContext>(0);
}

tree::TerminalNode* tsqlParser::Create_tableContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Create_tableContext::COMMA() {
  return getToken(tsqlParser::COMMA, 0);
}

tree::TerminalNode* tsqlParser::Create_tableContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Create_tableContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Create_tableContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_tableContext::DEFAULT() {
  return getTokens(tsqlParser::DEFAULT);
}

tree::TerminalNode* tsqlParser::Create_tableContext::DEFAULT(size_t i) {
  return getToken(tsqlParser::DEFAULT, i);
}

tree::TerminalNode* tsqlParser::Create_tableContext::TEXTIMAGE_ON() {
  return getToken(tsqlParser::TEXTIMAGE_ON, 0);
}

tree::TerminalNode* tsqlParser::Create_tableContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Create_tableContext::getRuleIndex() const {
  return tsqlParser::RuleCreate_table;
}


antlrcpp::Any tsqlParser::Create_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Create_tableContext* tsqlParser::create_table() {
  Create_tableContext *_localctx = _tracker.createInstance<Create_tableContext>(_ctx, getState());
  enterRule(_localctx, 70, tsqlParser::RuleCreate_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(961);
    match(tsqlParser::CREATE);
    setState(962);
    match(tsqlParser::TABLE);
    setState(963);
    table_name();
    setState(964);
    match(tsqlParser::LR_BRACKET);
    setState(965);
    column_def_table_constraints();
    setState(967);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::COMMA) {
      setState(966);
      match(tsqlParser::COMMA);
    }
    setState(969);
    match(tsqlParser::RR_BRACKET);
    setState(973);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
    case 1: {
      setState(970);
      match(tsqlParser::ON);
      setState(971);
      r_id();
      break;
    }

    case 2: {
      setState(972);
      match(tsqlParser::DEFAULT);
      break;
    }

    default:
      break;
    }
    setState(978);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
    case 1: {
      setState(975);
      match(tsqlParser::TEXTIMAGE_ON);
      setState(976);
      r_id();
      break;
    }

    case 2: {
      setState(977);
      match(tsqlParser::DEFAULT);
      break;
    }

    default:
      break;
    }
    setState(981);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
    case 1: {
      setState(980);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_schemaContext ------------------------------------------------------------------

tsqlParser::Create_schemaContext::Create_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Create_schemaContext::CREATE() {
  return getToken(tsqlParser::CREATE, 0);
}

tree::TerminalNode* tsqlParser::Create_schemaContext::SCHEMA() {
  return getToken(tsqlParser::SCHEMA, 0);
}

tsqlParser::Simple_nameContext* tsqlParser::Create_schemaContext::simple_name() {
  return getRuleContext<tsqlParser::Simple_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Create_schemaContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Create_schemaContext::getRuleIndex() const {
  return tsqlParser::RuleCreate_schema;
}


antlrcpp::Any tsqlParser::Create_schemaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_schema(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Create_schemaContext* tsqlParser::create_schema() {
  Create_schemaContext *_localctx = _tracker.createInstance<Create_schemaContext>(_ctx, getState());
  enterRule(_localctx, 72, tsqlParser::RuleCreate_schema);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(983);
    match(tsqlParser::CREATE);
    setState(984);
    match(tsqlParser::SCHEMA);
    setState(985);
    simple_name();
    setState(987);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx)) {
    case 1: {
      setState(986);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_synonymContext ------------------------------------------------------------------

tsqlParser::Create_synonymContext::Create_synonymContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Create_synonymContext::CREATE() {
  return getToken(tsqlParser::CREATE, 0);
}

tree::TerminalNode* tsqlParser::Create_synonymContext::SYNONYM() {
  return getToken(tsqlParser::SYNONYM, 0);
}

tsqlParser::Simple_nameContext* tsqlParser::Create_synonymContext::simple_name() {
  return getRuleContext<tsqlParser::Simple_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Create_synonymContext::FOR() {
  return getToken(tsqlParser::FOR, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Create_synonymContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Create_synonymContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Create_synonymContext::getRuleIndex() const {
  return tsqlParser::RuleCreate_synonym;
}


antlrcpp::Any tsqlParser::Create_synonymContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_synonym(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Create_synonymContext* tsqlParser::create_synonym() {
  Create_synonymContext *_localctx = _tracker.createInstance<Create_synonymContext>(_ctx, getState());
  enterRule(_localctx, 74, tsqlParser::RuleCreate_synonym);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(989);
    match(tsqlParser::CREATE);
    setState(990);
    match(tsqlParser::SYNONYM);
    setState(991);
    simple_name();
    setState(992);
    match(tsqlParser::FOR);
    setState(993);
    table_name();
    setState(995);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
    case 1: {
      setState(994);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_viewContext ------------------------------------------------------------------

tsqlParser::Create_viewContext::Create_viewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Create_viewContext::CREATE() {
  return getToken(tsqlParser::CREATE, 0);
}

tree::TerminalNode* tsqlParser::Create_viewContext::VIEW() {
  return getToken(tsqlParser::VIEW, 0);
}

tsqlParser::Simple_nameContext* tsqlParser::Create_viewContext::simple_name() {
  return getRuleContext<tsqlParser::Simple_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Create_viewContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

tsqlParser::Select_statementContext* tsqlParser::Create_viewContext::select_statement() {
  return getRuleContext<tsqlParser::Select_statementContext>(0);
}

tree::TerminalNode* tsqlParser::Create_viewContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Column_name_listContext* tsqlParser::Create_viewContext::column_name_list() {
  return getRuleContext<tsqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* tsqlParser::Create_viewContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_viewContext::WITH() {
  return getTokens(tsqlParser::WITH);
}

tree::TerminalNode* tsqlParser::Create_viewContext::WITH(size_t i) {
  return getToken(tsqlParser::WITH, i);
}

std::vector<tsqlParser::View_attributeContext *> tsqlParser::Create_viewContext::view_attribute() {
  return getRuleContexts<tsqlParser::View_attributeContext>();
}

tsqlParser::View_attributeContext* tsqlParser::Create_viewContext::view_attribute(size_t i) {
  return getRuleContext<tsqlParser::View_attributeContext>(i);
}

tree::TerminalNode* tsqlParser::Create_viewContext::CHECK() {
  return getToken(tsqlParser::CHECK, 0);
}

tree::TerminalNode* tsqlParser::Create_viewContext::OPTION() {
  return getToken(tsqlParser::OPTION, 0);
}

tree::TerminalNode* tsqlParser::Create_viewContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_viewContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Create_viewContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Create_viewContext::getRuleIndex() const {
  return tsqlParser::RuleCreate_view;
}


antlrcpp::Any tsqlParser::Create_viewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_view(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Create_viewContext* tsqlParser::create_view() {
  Create_viewContext *_localctx = _tracker.createInstance<Create_viewContext>(_ctx, getState());
  enterRule(_localctx, 76, tsqlParser::RuleCreate_view);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(997);
    match(tsqlParser::CREATE);
    setState(998);
    match(tsqlParser::VIEW);
    setState(999);
    simple_name();
    setState(1004);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::LR_BRACKET) {
      setState(1000);
      match(tsqlParser::LR_BRACKET);
      setState(1001);
      column_name_list();
      setState(1002);
      match(tsqlParser::RR_BRACKET);
    }
    setState(1015);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WITH) {
      setState(1006);
      match(tsqlParser::WITH);
      setState(1007);
      view_attribute();
      setState(1012);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(1008);
        match(tsqlParser::COMMA);
        setState(1009);
        view_attribute();
        setState(1014);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1017);
    match(tsqlParser::AS);
    setState(1018);
    select_statement();
    setState(1022);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
    case 1: {
      setState(1019);
      match(tsqlParser::WITH);
      setState(1020);
      match(tsqlParser::CHECK);
      setState(1021);
      match(tsqlParser::OPTION);
      break;
    }

    default:
      break;
    }
    setState(1025);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
    case 1: {
      setState(1024);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- View_attributeContext ------------------------------------------------------------------

tsqlParser::View_attributeContext::View_attributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::View_attributeContext::ENCRYPTION() {
  return getToken(tsqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* tsqlParser::View_attributeContext::SCHEMABINDING() {
  return getToken(tsqlParser::SCHEMABINDING, 0);
}

tree::TerminalNode* tsqlParser::View_attributeContext::VIEW_METADATA() {
  return getToken(tsqlParser::VIEW_METADATA, 0);
}


size_t tsqlParser::View_attributeContext::getRuleIndex() const {
  return tsqlParser::RuleView_attribute;
}


antlrcpp::Any tsqlParser::View_attributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitView_attribute(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::View_attributeContext* tsqlParser::view_attribute() {
  View_attributeContext *_localctx = _tracker.createInstance<View_attributeContext>(_ctx, getState());
  enterRule(_localctx, 78, tsqlParser::RuleView_attribute);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1027);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::ENCRYPTION || _la == tsqlParser::SCHEMABINDING

    || _la == tsqlParser::VIEW_METADATA)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_tableContext ------------------------------------------------------------------

tsqlParser::Alter_tableContext::Alter_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> tsqlParser::Alter_tableContext::ALTER() {
  return getTokens(tsqlParser::ALTER);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::ALTER(size_t i) {
  return getToken(tsqlParser::ALTER, i);
}

std::vector<tree::TerminalNode *> tsqlParser::Alter_tableContext::TABLE() {
  return getTokens(tsqlParser::TABLE);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::TABLE(size_t i) {
  return getToken(tsqlParser::TABLE, i);
}

std::vector<tsqlParser::Table_nameContext *> tsqlParser::Alter_tableContext::table_name() {
  return getRuleContexts<tsqlParser::Table_nameContext>();
}

tsqlParser::Table_nameContext* tsqlParser::Alter_tableContext::table_name(size_t i) {
  return getRuleContext<tsqlParser::Table_nameContext>(i);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::SET() {
  return getToken(tsqlParser::SET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Alter_tableContext::LR_BRACKET() {
  return getTokens(tsqlParser::LR_BRACKET);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::LR_BRACKET(size_t i) {
  return getToken(tsqlParser::LR_BRACKET, i);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::LOCK_ESCALATION() {
  return getToken(tsqlParser::LOCK_ESCALATION, 0);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Alter_tableContext::RR_BRACKET() {
  return getTokens(tsqlParser::RR_BRACKET);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::RR_BRACKET(size_t i) {
  return getToken(tsqlParser::RR_BRACKET, i);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::ADD() {
  return getToken(tsqlParser::ADD, 0);
}

tsqlParser::Column_def_table_constraintContext* tsqlParser::Alter_tableContext::column_def_table_constraint() {
  return getRuleContext<tsqlParser::Column_def_table_constraintContext>(0);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::DROP() {
  return getToken(tsqlParser::DROP, 0);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::CONSTRAINT() {
  return getToken(tsqlParser::CONSTRAINT, 0);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::CHECK() {
  return getToken(tsqlParser::CHECK, 0);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::FOREIGN() {
  return getToken(tsqlParser::FOREIGN, 0);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::KEY() {
  return getToken(tsqlParser::KEY, 0);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::REFERENCES() {
  return getToken(tsqlParser::REFERENCES, 0);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::COLUMN() {
  return getToken(tsqlParser::COLUMN, 0);
}

tsqlParser::Column_def_table_constraintsContext* tsqlParser::Alter_tableContext::column_def_table_constraints() {
  return getRuleContext<tsqlParser::Column_def_table_constraintsContext>(0);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::AUTO() {
  return getToken(tsqlParser::AUTO, 0);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::DISABLE() {
  return getToken(tsqlParser::DISABLE, 0);
}

tsqlParser::R_idContext* tsqlParser::Alter_tableContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

std::vector<tsqlParser::Column_name_listContext *> tsqlParser::Alter_tableContext::column_name_list() {
  return getRuleContexts<tsqlParser::Column_name_listContext>();
}

tsqlParser::Column_name_listContext* tsqlParser::Alter_tableContext::column_name_list(size_t i) {
  return getRuleContext<tsqlParser::Column_name_listContext>(i);
}

tree::TerminalNode* tsqlParser::Alter_tableContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Alter_tableContext::getRuleIndex() const {
  return tsqlParser::RuleAlter_table;
}


antlrcpp::Any tsqlParser::Alter_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitAlter_table(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Alter_tableContext* tsqlParser::alter_table() {
  Alter_tableContext *_localctx = _tracker.createInstance<Alter_tableContext>(_ctx, getState());
  enterRule(_localctx, 80, tsqlParser::RuleAlter_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1029);
    match(tsqlParser::ALTER);
    setState(1030);
    match(tsqlParser::TABLE);
    setState(1031);
    table_name();
    setState(1065);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::SET: {
        setState(1032);
        match(tsqlParser::SET);
        setState(1033);
        match(tsqlParser::LR_BRACKET);
        setState(1034);
        match(tsqlParser::LOCK_ESCALATION);
        setState(1035);
        match(tsqlParser::EQUAL);
        setState(1036);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::TABLE

        || _la == tsqlParser::AUTO || _la == tsqlParser::DISABLE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1037);
        match(tsqlParser::RR_BRACKET);
        break;
      }

      case tsqlParser::ADD: {
        setState(1038);
        match(tsqlParser::ADD);
        setState(1039);
        column_def_table_constraint();
        break;
      }

      case tsqlParser::DROP: {
        setState(1040);
        match(tsqlParser::DROP);
        setState(1041);
        match(tsqlParser::CONSTRAINT);
        setState(1042);
        dynamic_cast<Alter_tableContext *>(_localctx)->constraint = r_id();
        break;
      }

      case tsqlParser::WITH: {
        setState(1043);
        match(tsqlParser::WITH);
        setState(1044);
        match(tsqlParser::CHECK);
        setState(1045);
        match(tsqlParser::ADD);
        setState(1046);
        match(tsqlParser::CONSTRAINT);
        setState(1047);
        dynamic_cast<Alter_tableContext *>(_localctx)->constraint = r_id();
        setState(1048);
        match(tsqlParser::FOREIGN);
        setState(1049);
        match(tsqlParser::KEY);
        setState(1050);
        match(tsqlParser::LR_BRACKET);
        setState(1051);
        dynamic_cast<Alter_tableContext *>(_localctx)->fk = column_name_list();
        setState(1052);
        match(tsqlParser::RR_BRACKET);
        setState(1053);
        match(tsqlParser::REFERENCES);
        setState(1054);
        table_name();
        setState(1055);
        match(tsqlParser::LR_BRACKET);
        setState(1056);
        dynamic_cast<Alter_tableContext *>(_localctx)->pk = column_name_list();
        setState(1057);
        match(tsqlParser::RR_BRACKET);
        break;
      }

      case tsqlParser::CHECK: {
        setState(1059);
        match(tsqlParser::CHECK);
        setState(1060);
        match(tsqlParser::CONSTRAINT);
        setState(1061);
        dynamic_cast<Alter_tableContext *>(_localctx)->constraint = r_id();
        break;
      }

      case tsqlParser::ALTER: {
        setState(1062);
        match(tsqlParser::ALTER);
        setState(1063);
        match(tsqlParser::COLUMN);
        setState(1064);
        column_def_table_constraints();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1068);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx)) {
    case 1: {
      setState(1067);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_databaseContext ------------------------------------------------------------------

tsqlParser::Alter_databaseContext::Alter_databaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Alter_databaseContext::ALTER() {
  return getToken(tsqlParser::ALTER, 0);
}

tree::TerminalNode* tsqlParser::Alter_databaseContext::DATABASE() {
  return getToken(tsqlParser::DATABASE, 0);
}

tree::TerminalNode* tsqlParser::Alter_databaseContext::CURRENT() {
  return getToken(tsqlParser::CURRENT, 0);
}

tree::TerminalNode* tsqlParser::Alter_databaseContext::MODIFY() {
  return getToken(tsqlParser::MODIFY, 0);
}

tree::TerminalNode* tsqlParser::Alter_databaseContext::NAME() {
  return getToken(tsqlParser::NAME, 0);
}

tree::TerminalNode* tsqlParser::Alter_databaseContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Alter_databaseContext::COLLATE() {
  return getToken(tsqlParser::COLLATE, 0);
}

tree::TerminalNode* tsqlParser::Alter_databaseContext::SET() {
  return getToken(tsqlParser::SET, 0);
}

tsqlParser::Database_optionspecContext* tsqlParser::Alter_databaseContext::database_optionspec() {
  return getRuleContext<tsqlParser::Database_optionspecContext>(0);
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Alter_databaseContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Alter_databaseContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

tree::TerminalNode* tsqlParser::Alter_databaseContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tree::TerminalNode* tsqlParser::Alter_databaseContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

tsqlParser::TerminationContext* tsqlParser::Alter_databaseContext::termination() {
  return getRuleContext<tsqlParser::TerminationContext>(0);
}


size_t tsqlParser::Alter_databaseContext::getRuleIndex() const {
  return tsqlParser::RuleAlter_database;
}


antlrcpp::Any tsqlParser::Alter_databaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitAlter_database(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Alter_databaseContext* tsqlParser::alter_database() {
  Alter_databaseContext *_localctx = _tracker.createInstance<Alter_databaseContext>(_ctx, getState());
  enterRule(_localctx, 82, tsqlParser::RuleAlter_database);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1070);
    match(tsqlParser::ALTER);
    setState(1071);
    match(tsqlParser::DATABASE);
    setState(1074);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        setState(1072);
        dynamic_cast<Alter_databaseContext *>(_localctx)->database = r_id();
        break;
      }

      case tsqlParser::CURRENT: {
        setState(1073);
        match(tsqlParser::CURRENT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1088);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::MODIFY: {
        setState(1076);
        match(tsqlParser::MODIFY);
        setState(1077);
        match(tsqlParser::NAME);
        setState(1078);
        match(tsqlParser::EQUAL);
        setState(1079);
        dynamic_cast<Alter_databaseContext *>(_localctx)->new_name = r_id();
        break;
      }

      case tsqlParser::COLLATE: {
        setState(1080);
        match(tsqlParser::COLLATE);
        setState(1081);
        dynamic_cast<Alter_databaseContext *>(_localctx)->collation = r_id();
        break;
      }

      case tsqlParser::SET: {
        setState(1082);
        match(tsqlParser::SET);
        setState(1083);
        database_optionspec();
        setState(1086);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
        case 1: {
          setState(1084);
          match(tsqlParser::WITH);
          setState(1085);
          termination();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1091);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
    case 1: {
      setState(1090);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Database_optionspecContext ------------------------------------------------------------------

tsqlParser::Database_optionspecContext::Database_optionspecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Auto_optionContext* tsqlParser::Database_optionspecContext::auto_option() {
  return getRuleContext<tsqlParser::Auto_optionContext>(0);
}

tsqlParser::Change_tracking_optionContext* tsqlParser::Database_optionspecContext::change_tracking_option() {
  return getRuleContext<tsqlParser::Change_tracking_optionContext>(0);
}

tsqlParser::Containment_optionContext* tsqlParser::Database_optionspecContext::containment_option() {
  return getRuleContext<tsqlParser::Containment_optionContext>(0);
}

tsqlParser::Cursor_optionContext* tsqlParser::Database_optionspecContext::cursor_option() {
  return getRuleContext<tsqlParser::Cursor_optionContext>(0);
}

tsqlParser::Date_correlation_optimization_optionContext* tsqlParser::Database_optionspecContext::date_correlation_optimization_option() {
  return getRuleContext<tsqlParser::Date_correlation_optimization_optionContext>(0);
}

tsqlParser::Db_encryption_optionContext* tsqlParser::Database_optionspecContext::db_encryption_option() {
  return getRuleContext<tsqlParser::Db_encryption_optionContext>(0);
}

tsqlParser::Db_state_optionContext* tsqlParser::Database_optionspecContext::db_state_option() {
  return getRuleContext<tsqlParser::Db_state_optionContext>(0);
}

tsqlParser::Db_update_optionContext* tsqlParser::Database_optionspecContext::db_update_option() {
  return getRuleContext<tsqlParser::Db_update_optionContext>(0);
}

tsqlParser::Db_user_access_optionContext* tsqlParser::Database_optionspecContext::db_user_access_option() {
  return getRuleContext<tsqlParser::Db_user_access_optionContext>(0);
}

tsqlParser::Delayed_durability_optionContext* tsqlParser::Database_optionspecContext::delayed_durability_option() {
  return getRuleContext<tsqlParser::Delayed_durability_optionContext>(0);
}

tsqlParser::External_access_optionContext* tsqlParser::Database_optionspecContext::external_access_option() {
  return getRuleContext<tsqlParser::External_access_optionContext>(0);
}

tree::TerminalNode* tsqlParser::Database_optionspecContext::FILESTREAM() {
  return getToken(tsqlParser::FILESTREAM, 0);
}

tsqlParser::Database_filestream_optionContext* tsqlParser::Database_optionspecContext::database_filestream_option() {
  return getRuleContext<tsqlParser::Database_filestream_optionContext>(0);
}

tsqlParser::Hadr_optionsContext* tsqlParser::Database_optionspecContext::hadr_options() {
  return getRuleContext<tsqlParser::Hadr_optionsContext>(0);
}

tsqlParser::Mixed_page_allocation_optionContext* tsqlParser::Database_optionspecContext::mixed_page_allocation_option() {
  return getRuleContext<tsqlParser::Mixed_page_allocation_optionContext>(0);
}

tsqlParser::Parameterization_optionContext* tsqlParser::Database_optionspecContext::parameterization_option() {
  return getRuleContext<tsqlParser::Parameterization_optionContext>(0);
}

tsqlParser::Recovery_optionContext* tsqlParser::Database_optionspecContext::recovery_option() {
  return getRuleContext<tsqlParser::Recovery_optionContext>(0);
}

tsqlParser::Service_broker_optionContext* tsqlParser::Database_optionspecContext::service_broker_option() {
  return getRuleContext<tsqlParser::Service_broker_optionContext>(0);
}

tsqlParser::Snapshot_optionContext* tsqlParser::Database_optionspecContext::snapshot_option() {
  return getRuleContext<tsqlParser::Snapshot_optionContext>(0);
}

tsqlParser::Sql_optionContext* tsqlParser::Database_optionspecContext::sql_option() {
  return getRuleContext<tsqlParser::Sql_optionContext>(0);
}

tsqlParser::Target_recovery_time_optionContext* tsqlParser::Database_optionspecContext::target_recovery_time_option() {
  return getRuleContext<tsqlParser::Target_recovery_time_optionContext>(0);
}

tsqlParser::TerminationContext* tsqlParser::Database_optionspecContext::termination() {
  return getRuleContext<tsqlParser::TerminationContext>(0);
}


size_t tsqlParser::Database_optionspecContext::getRuleIndex() const {
  return tsqlParser::RuleDatabase_optionspec;
}


antlrcpp::Any tsqlParser::Database_optionspecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDatabase_optionspec(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Database_optionspecContext* tsqlParser::database_optionspec() {
  Database_optionspecContext *_localctx = _tracker.createInstance<Database_optionspecContext>(_ctx, getState());
  enterRule(_localctx, 84, tsqlParser::RuleDatabase_optionspec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1115);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1093);
      auto_option();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1094);
      change_tracking_option();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1095);
      containment_option();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1096);
      cursor_option();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1097);
      date_correlation_optimization_option();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1098);
      db_encryption_option();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1099);
      db_state_option();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1100);
      db_update_option();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1101);
      db_user_access_option();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1102);
      delayed_durability_option();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1103);
      external_access_option();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1104);
      match(tsqlParser::FILESTREAM);
      setState(1105);
      database_filestream_option();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1106);
      hadr_options();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1107);
      mixed_page_allocation_option();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1108);
      parameterization_option();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1109);
      recovery_option();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1110);
      service_broker_option();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(1111);
      snapshot_option();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(1112);
      sql_option();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(1113);
      target_recovery_time_option();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(1114);
      termination();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Auto_optionContext ------------------------------------------------------------------

tsqlParser::Auto_optionContext::Auto_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Auto_optionContext::AUTO_CLOSE() {
  return getToken(tsqlParser::AUTO_CLOSE, 0);
}

tsqlParser::On_offContext* tsqlParser::Auto_optionContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}

tree::TerminalNode* tsqlParser::Auto_optionContext::AUTO_CREATE_STATISTICS() {
  return getToken(tsqlParser::AUTO_CREATE_STATISTICS, 0);
}

tree::TerminalNode* tsqlParser::Auto_optionContext::OFF() {
  return getToken(tsqlParser::OFF, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Auto_optionContext::ON() {
  return getTokens(tsqlParser::ON);
}

tree::TerminalNode* tsqlParser::Auto_optionContext::ON(size_t i) {
  return getToken(tsqlParser::ON, i);
}

tree::TerminalNode* tsqlParser::Auto_optionContext::INCREMENTAL() {
  return getToken(tsqlParser::INCREMENTAL, 0);
}

tree::TerminalNode* tsqlParser::Auto_optionContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Auto_optionContext::AUTO_SHRINK() {
  return getToken(tsqlParser::AUTO_SHRINK, 0);
}

tree::TerminalNode* tsqlParser::Auto_optionContext::AUTO_UPDATE_STATISTICS() {
  return getToken(tsqlParser::AUTO_UPDATE_STATISTICS, 0);
}

tree::TerminalNode* tsqlParser::Auto_optionContext::AUTO_UPDATE_STATISTICS_ASYNC() {
  return getToken(tsqlParser::AUTO_UPDATE_STATISTICS_ASYNC, 0);
}


size_t tsqlParser::Auto_optionContext::getRuleIndex() const {
  return tsqlParser::RuleAuto_option;
}


antlrcpp::Any tsqlParser::Auto_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitAuto_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Auto_optionContext* tsqlParser::auto_option() {
  Auto_optionContext *_localctx = _tracker.createInstance<Auto_optionContext>(_ctx, getState());
  enterRule(_localctx, 86, tsqlParser::RuleAuto_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1134);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::AUTO_CLOSE: {
        enterOuterAlt(_localctx, 1);
        setState(1117);
        match(tsqlParser::AUTO_CLOSE);
        setState(1118);
        on_off();
        break;
      }

      case tsqlParser::AUTO_CREATE_STATISTICS: {
        enterOuterAlt(_localctx, 2);
        setState(1119);
        match(tsqlParser::AUTO_CREATE_STATISTICS);
        setState(1120);
        match(tsqlParser::OFF);
        break;
      }

      case tsqlParser::ON: {
        enterOuterAlt(_localctx, 3);
        setState(1121);
        match(tsqlParser::ON);
        setState(1126);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::INCREMENTAL: {
            setState(1122);
            match(tsqlParser::INCREMENTAL);
            setState(1123);
            match(tsqlParser::EQUAL);
            setState(1124);
            match(tsqlParser::ON);
            break;
          }

          case tsqlParser::OFF: {
            setState(1125);
            match(tsqlParser::OFF);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case tsqlParser::AUTO_SHRINK: {
        enterOuterAlt(_localctx, 4);
        setState(1128);
        match(tsqlParser::AUTO_SHRINK);
        setState(1129);
        on_off();
        break;
      }

      case tsqlParser::AUTO_UPDATE_STATISTICS: {
        enterOuterAlt(_localctx, 5);
        setState(1130);
        match(tsqlParser::AUTO_UPDATE_STATISTICS);
        setState(1131);
        on_off();
        break;
      }

      case tsqlParser::AUTO_UPDATE_STATISTICS_ASYNC: {
        enterOuterAlt(_localctx, 6);
        setState(1132);
        match(tsqlParser::AUTO_UPDATE_STATISTICS_ASYNC);
        setState(1133);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::OFF

        || _la == tsqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Change_tracking_optionContext ------------------------------------------------------------------

tsqlParser::Change_tracking_optionContext::Change_tracking_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Change_tracking_optionContext::CHANGE_TRACKING() {
  return getToken(tsqlParser::CHANGE_TRACKING, 0);
}

tree::TerminalNode* tsqlParser::Change_tracking_optionContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Change_tracking_optionContext::OFF() {
  return getToken(tsqlParser::OFF, 0);
}

tree::TerminalNode* tsqlParser::Change_tracking_optionContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

std::vector<tsqlParser::Change_tracking_option_listContext *> tsqlParser::Change_tracking_optionContext::change_tracking_option_list() {
  return getRuleContexts<tsqlParser::Change_tracking_option_listContext>();
}

tsqlParser::Change_tracking_option_listContext* tsqlParser::Change_tracking_optionContext::change_tracking_option_list(size_t i) {
  return getRuleContext<tsqlParser::Change_tracking_option_listContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Change_tracking_optionContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Change_tracking_optionContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Change_tracking_optionContext::getRuleIndex() const {
  return tsqlParser::RuleChange_tracking_option;
}


antlrcpp::Any tsqlParser::Change_tracking_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitChange_tracking_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Change_tracking_optionContext* tsqlParser::change_tracking_option() {
  Change_tracking_optionContext *_localctx = _tracker.createInstance<Change_tracking_optionContext>(_ctx, getState());
  enterRule(_localctx, 88, tsqlParser::RuleChange_tracking_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1136);
    match(tsqlParser::CHANGE_TRACKING);
    setState(1137);
    match(tsqlParser::EQUAL);
    setState(1153);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::OFF: {
        setState(1138);
        match(tsqlParser::OFF);
        break;
      }

      case tsqlParser::ON: {
        setState(1139);
        match(tsqlParser::ON);
        setState(1150);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == tsqlParser::AUTO_CLEANUP

        || _la == tsqlParser::CHANGE_RETENTION) {
          setState(1140);
          change_tracking_option_list();
          setState(1145);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == tsqlParser::COMMA) {
            setState(1141);
            match(tsqlParser::COMMA);
            setState(1142);
            change_tracking_option_list();
            setState(1147);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(1152);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Change_tracking_option_listContext ------------------------------------------------------------------

tsqlParser::Change_tracking_option_listContext::Change_tracking_option_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Change_tracking_option_listContext::AUTO_CLEANUP() {
  return getToken(tsqlParser::AUTO_CLEANUP, 0);
}

tree::TerminalNode* tsqlParser::Change_tracking_option_listContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tsqlParser::On_offContext* tsqlParser::Change_tracking_option_listContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}

tree::TerminalNode* tsqlParser::Change_tracking_option_listContext::CHANGE_RETENTION() {
  return getToken(tsqlParser::CHANGE_RETENTION, 0);
}

tree::TerminalNode* tsqlParser::Change_tracking_option_listContext::DAYS() {
  return getToken(tsqlParser::DAYS, 0);
}

tree::TerminalNode* tsqlParser::Change_tracking_option_listContext::HOURS() {
  return getToken(tsqlParser::HOURS, 0);
}

tree::TerminalNode* tsqlParser::Change_tracking_option_listContext::MINUTES() {
  return getToken(tsqlParser::MINUTES, 0);
}


size_t tsqlParser::Change_tracking_option_listContext::getRuleIndex() const {
  return tsqlParser::RuleChange_tracking_option_list;
}


antlrcpp::Any tsqlParser::Change_tracking_option_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitChange_tracking_option_list(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Change_tracking_option_listContext* tsqlParser::change_tracking_option_list() {
  Change_tracking_option_listContext *_localctx = _tracker.createInstance<Change_tracking_option_listContext>(_ctx, getState());
  enterRule(_localctx, 90, tsqlParser::RuleChange_tracking_option_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1161);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::AUTO_CLEANUP: {
        enterOuterAlt(_localctx, 1);
        setState(1155);
        match(tsqlParser::AUTO_CLEANUP);
        setState(1156);
        match(tsqlParser::EQUAL);
        setState(1157);
        on_off();
        break;
      }

      case tsqlParser::CHANGE_RETENTION: {
        enterOuterAlt(_localctx, 2);
        setState(1158);
        match(tsqlParser::CHANGE_RETENTION);
        setState(1159);
        match(tsqlParser::EQUAL);
        setState(1160);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::DAYS

        || _la == tsqlParser::HOURS || _la == tsqlParser::MINUTES)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Containment_optionContext ------------------------------------------------------------------

tsqlParser::Containment_optionContext::Containment_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Containment_optionContext::CONTAINMENT() {
  return getToken(tsqlParser::CONTAINMENT, 0);
}

tree::TerminalNode* tsqlParser::Containment_optionContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Containment_optionContext::NONE() {
  return getToken(tsqlParser::NONE, 0);
}

tree::TerminalNode* tsqlParser::Containment_optionContext::PARTIAL() {
  return getToken(tsqlParser::PARTIAL, 0);
}


size_t tsqlParser::Containment_optionContext::getRuleIndex() const {
  return tsqlParser::RuleContainment_option;
}


antlrcpp::Any tsqlParser::Containment_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitContainment_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Containment_optionContext* tsqlParser::containment_option() {
  Containment_optionContext *_localctx = _tracker.createInstance<Containment_optionContext>(_ctx, getState());
  enterRule(_localctx, 92, tsqlParser::RuleContainment_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1163);
    match(tsqlParser::CONTAINMENT);
    setState(1164);
    match(tsqlParser::EQUAL);
    setState(1165);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::NONE

    || _la == tsqlParser::PARTIAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_optionContext ------------------------------------------------------------------

tsqlParser::Cursor_optionContext::Cursor_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Cursor_optionContext::CURSOR_CLOSE_ON_COMMIT() {
  return getToken(tsqlParser::CURSOR_CLOSE_ON_COMMIT, 0);
}

tsqlParser::On_offContext* tsqlParser::Cursor_optionContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}

tree::TerminalNode* tsqlParser::Cursor_optionContext::CURSOR_DEFAULT() {
  return getToken(tsqlParser::CURSOR_DEFAULT, 0);
}

tree::TerminalNode* tsqlParser::Cursor_optionContext::LOCAL() {
  return getToken(tsqlParser::LOCAL, 0);
}

tree::TerminalNode* tsqlParser::Cursor_optionContext::GLOBAL() {
  return getToken(tsqlParser::GLOBAL, 0);
}


size_t tsqlParser::Cursor_optionContext::getRuleIndex() const {
  return tsqlParser::RuleCursor_option;
}


antlrcpp::Any tsqlParser::Cursor_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCursor_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Cursor_optionContext* tsqlParser::cursor_option() {
  Cursor_optionContext *_localctx = _tracker.createInstance<Cursor_optionContext>(_ctx, getState());
  enterRule(_localctx, 94, tsqlParser::RuleCursor_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1171);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::CURSOR_CLOSE_ON_COMMIT: {
        enterOuterAlt(_localctx, 1);
        setState(1167);
        match(tsqlParser::CURSOR_CLOSE_ON_COMMIT);
        setState(1168);
        on_off();
        break;
      }

      case tsqlParser::CURSOR_DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(1169);
        match(tsqlParser::CURSOR_DEFAULT);
        setState(1170);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::GLOBAL

        || _la == tsqlParser::LOCAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Date_correlation_optimization_optionContext ------------------------------------------------------------------

tsqlParser::Date_correlation_optimization_optionContext::Date_correlation_optimization_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Date_correlation_optimization_optionContext::DATE_CORRELATION_OPTIMIZATION() {
  return getToken(tsqlParser::DATE_CORRELATION_OPTIMIZATION, 0);
}

tsqlParser::On_offContext* tsqlParser::Date_correlation_optimization_optionContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}


size_t tsqlParser::Date_correlation_optimization_optionContext::getRuleIndex() const {
  return tsqlParser::RuleDate_correlation_optimization_option;
}


antlrcpp::Any tsqlParser::Date_correlation_optimization_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDate_correlation_optimization_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Date_correlation_optimization_optionContext* tsqlParser::date_correlation_optimization_option() {
  Date_correlation_optimization_optionContext *_localctx = _tracker.createInstance<Date_correlation_optimization_optionContext>(_ctx, getState());
  enterRule(_localctx, 96, tsqlParser::RuleDate_correlation_optimization_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1173);
    match(tsqlParser::DATE_CORRELATION_OPTIMIZATION);
    setState(1174);
    on_off();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Db_encryption_optionContext ------------------------------------------------------------------

tsqlParser::Db_encryption_optionContext::Db_encryption_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Db_encryption_optionContext::ENCRYPTION() {
  return getToken(tsqlParser::ENCRYPTION, 0);
}

tsqlParser::On_offContext* tsqlParser::Db_encryption_optionContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}


size_t tsqlParser::Db_encryption_optionContext::getRuleIndex() const {
  return tsqlParser::RuleDb_encryption_option;
}


antlrcpp::Any tsqlParser::Db_encryption_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDb_encryption_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Db_encryption_optionContext* tsqlParser::db_encryption_option() {
  Db_encryption_optionContext *_localctx = _tracker.createInstance<Db_encryption_optionContext>(_ctx, getState());
  enterRule(_localctx, 98, tsqlParser::RuleDb_encryption_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1176);
    match(tsqlParser::ENCRYPTION);
    setState(1177);
    on_off();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Db_state_optionContext ------------------------------------------------------------------

tsqlParser::Db_state_optionContext::Db_state_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Db_state_optionContext::ONLINE() {
  return getToken(tsqlParser::ONLINE, 0);
}

tree::TerminalNode* tsqlParser::Db_state_optionContext::OFFLINE() {
  return getToken(tsqlParser::OFFLINE, 0);
}

tree::TerminalNode* tsqlParser::Db_state_optionContext::EMERGENCY() {
  return getToken(tsqlParser::EMERGENCY, 0);
}


size_t tsqlParser::Db_state_optionContext::getRuleIndex() const {
  return tsqlParser::RuleDb_state_option;
}


antlrcpp::Any tsqlParser::Db_state_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDb_state_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Db_state_optionContext* tsqlParser::db_state_option() {
  Db_state_optionContext *_localctx = _tracker.createInstance<Db_state_optionContext>(_ctx, getState());
  enterRule(_localctx, 100, tsqlParser::RuleDb_state_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1179);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::EMERGENCY || _la == tsqlParser::OFFLINE

    || _la == tsqlParser::ONLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Db_update_optionContext ------------------------------------------------------------------

tsqlParser::Db_update_optionContext::Db_update_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Db_update_optionContext::READ_ONLY() {
  return getToken(tsqlParser::READ_ONLY, 0);
}

tree::TerminalNode* tsqlParser::Db_update_optionContext::READ_WRITE() {
  return getToken(tsqlParser::READ_WRITE, 0);
}


size_t tsqlParser::Db_update_optionContext::getRuleIndex() const {
  return tsqlParser::RuleDb_update_option;
}


antlrcpp::Any tsqlParser::Db_update_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDb_update_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Db_update_optionContext* tsqlParser::db_update_option() {
  Db_update_optionContext *_localctx = _tracker.createInstance<Db_update_optionContext>(_ctx, getState());
  enterRule(_localctx, 102, tsqlParser::RuleDb_update_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1181);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::READ_ONLY

    || _la == tsqlParser::READ_WRITE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Db_user_access_optionContext ------------------------------------------------------------------

tsqlParser::Db_user_access_optionContext::Db_user_access_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Db_user_access_optionContext::SINGLE_USER() {
  return getToken(tsqlParser::SINGLE_USER, 0);
}

tree::TerminalNode* tsqlParser::Db_user_access_optionContext::RESTRICTED_USER() {
  return getToken(tsqlParser::RESTRICTED_USER, 0);
}

tree::TerminalNode* tsqlParser::Db_user_access_optionContext::MULTI_USER() {
  return getToken(tsqlParser::MULTI_USER, 0);
}


size_t tsqlParser::Db_user_access_optionContext::getRuleIndex() const {
  return tsqlParser::RuleDb_user_access_option;
}


antlrcpp::Any tsqlParser::Db_user_access_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDb_user_access_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Db_user_access_optionContext* tsqlParser::db_user_access_option() {
  Db_user_access_optionContext *_localctx = _tracker.createInstance<Db_user_access_optionContext>(_ctx, getState());
  enterRule(_localctx, 104, tsqlParser::RuleDb_user_access_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1183);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::MULTI_USER

    || _la == tsqlParser::RESTRICTED_USER || _la == tsqlParser::SINGLE_USER)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_durability_optionContext ------------------------------------------------------------------

tsqlParser::Delayed_durability_optionContext::Delayed_durability_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Delayed_durability_optionContext::DELAYED_DURABILITY() {
  return getToken(tsqlParser::DELAYED_DURABILITY, 0);
}

tree::TerminalNode* tsqlParser::Delayed_durability_optionContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Delayed_durability_optionContext::DISABLED() {
  return getToken(tsqlParser::DISABLED, 0);
}

tree::TerminalNode* tsqlParser::Delayed_durability_optionContext::ALLOWED() {
  return getToken(tsqlParser::ALLOWED, 0);
}

tree::TerminalNode* tsqlParser::Delayed_durability_optionContext::FORCED() {
  return getToken(tsqlParser::FORCED, 0);
}


size_t tsqlParser::Delayed_durability_optionContext::getRuleIndex() const {
  return tsqlParser::RuleDelayed_durability_option;
}


antlrcpp::Any tsqlParser::Delayed_durability_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDelayed_durability_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Delayed_durability_optionContext* tsqlParser::delayed_durability_option() {
  Delayed_durability_optionContext *_localctx = _tracker.createInstance<Delayed_durability_optionContext>(_ctx, getState());
  enterRule(_localctx, 106, tsqlParser::RuleDelayed_durability_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1185);
    match(tsqlParser::DELAYED_DURABILITY);
    setState(1186);
    match(tsqlParser::EQUAL);
    setState(1187);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::ALLOWED

    || _la == tsqlParser::DISABLED || _la == tsqlParser::FORCED)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- External_access_optionContext ------------------------------------------------------------------

tsqlParser::External_access_optionContext::External_access_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::External_access_optionContext::DB_CHAINING() {
  return getToken(tsqlParser::DB_CHAINING, 0);
}

tsqlParser::On_offContext* tsqlParser::External_access_optionContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}

tree::TerminalNode* tsqlParser::External_access_optionContext::TRUSTWORTHY() {
  return getToken(tsqlParser::TRUSTWORTHY, 0);
}

tree::TerminalNode* tsqlParser::External_access_optionContext::DEFAULT_LANGUAGE() {
  return getToken(tsqlParser::DEFAULT_LANGUAGE, 0);
}

tree::TerminalNode* tsqlParser::External_access_optionContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tsqlParser::R_idContext* tsqlParser::External_access_optionContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::External_access_optionContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}

tree::TerminalNode* tsqlParser::External_access_optionContext::DEFAULT_FULLTEXT_LANGUAGE() {
  return getToken(tsqlParser::DEFAULT_FULLTEXT_LANGUAGE, 0);
}

tree::TerminalNode* tsqlParser::External_access_optionContext::NESTED_TRIGGERS() {
  return getToken(tsqlParser::NESTED_TRIGGERS, 0);
}

tree::TerminalNode* tsqlParser::External_access_optionContext::OFF() {
  return getToken(tsqlParser::OFF, 0);
}

tree::TerminalNode* tsqlParser::External_access_optionContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

tree::TerminalNode* tsqlParser::External_access_optionContext::TRANSFORM_NOISE_WORDS() {
  return getToken(tsqlParser::TRANSFORM_NOISE_WORDS, 0);
}

tree::TerminalNode* tsqlParser::External_access_optionContext::TWO_DIGIT_YEAR_CUTOFF() {
  return getToken(tsqlParser::TWO_DIGIT_YEAR_CUTOFF, 0);
}

tree::TerminalNode* tsqlParser::External_access_optionContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}


size_t tsqlParser::External_access_optionContext::getRuleIndex() const {
  return tsqlParser::RuleExternal_access_option;
}


antlrcpp::Any tsqlParser::External_access_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitExternal_access_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::External_access_optionContext* tsqlParser::external_access_option() {
  External_access_optionContext *_localctx = _tracker.createInstance<External_access_optionContext>(_ctx, getState());
  enterRule(_localctx, 108, tsqlParser::RuleExternal_access_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1214);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::DB_CHAINING: {
        enterOuterAlt(_localctx, 1);
        setState(1189);
        match(tsqlParser::DB_CHAINING);
        setState(1190);
        on_off();
        break;
      }

      case tsqlParser::TRUSTWORTHY: {
        enterOuterAlt(_localctx, 2);
        setState(1191);
        match(tsqlParser::TRUSTWORTHY);
        setState(1192);
        on_off();
        break;
      }

      case tsqlParser::DEFAULT_LANGUAGE: {
        enterOuterAlt(_localctx, 3);
        setState(1193);
        match(tsqlParser::DEFAULT_LANGUAGE);
        setState(1194);
        match(tsqlParser::EQUAL);
        setState(1197);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::FORCESEEK:
          case tsqlParser::NEXT:
          case tsqlParser::NUMERIC:
          case tsqlParser::VALUE:
          case tsqlParser::ABSOLUTE:
          case tsqlParser::APPLY:
          case tsqlParser::AUTO:
          case tsqlParser::AVG:
          case tsqlParser::BASE64:
          case tsqlParser::CALLER:
          case tsqlParser::CAST:
          case tsqlParser::CATCH:
          case tsqlParser::CHECKSUM_AGG:
          case tsqlParser::COMMITTED:
          case tsqlParser::CONCAT:
          case tsqlParser::CONTROL:
          case tsqlParser::COOKIE:
          case tsqlParser::COUNT:
          case tsqlParser::COUNT_BIG:
          case tsqlParser::DATE:
          case tsqlParser::DELAY:
          case tsqlParser::DELETED:
          case tsqlParser::DENSE_RANK:
          case tsqlParser::DISABLE:
          case tsqlParser::DYNAMIC:
          case tsqlParser::ENCRYPTION:
          case tsqlParser::EXIST:
          case tsqlParser::EXPAND:
          case tsqlParser::FAST:
          case tsqlParser::FAST_FORWARD:
          case tsqlParser::FIRST:
          case tsqlParser::FIRST_VALUE:
          case tsqlParser::FOLLOWING:
          case tsqlParser::FORCE:
          case tsqlParser::FORCED:
          case tsqlParser::FORWARD_ONLY:
          case tsqlParser::FULLSCAN:
          case tsqlParser::GLOBAL:
          case tsqlParser::GROUPING:
          case tsqlParser::GROUPING_ID:
          case tsqlParser::HASH:
          case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case tsqlParser::IMPERSONATE:
          case tsqlParser::INSENSITIVE:
          case tsqlParser::INSERTED:
          case tsqlParser::ISOLATION:
          case tsqlParser::IO:
          case tsqlParser::KEEP:
          case tsqlParser::KEEPFIXED:
          case tsqlParser::KEYSET:
          case tsqlParser::LAG:
          case tsqlParser::LAST:
          case tsqlParser::LAST_VALUE:
          case tsqlParser::LEAD:
          case tsqlParser::LEVEL:
          case tsqlParser::LOCAL:
          case tsqlParser::LOCK_ESCALATION:
          case tsqlParser::LOGIN:
          case tsqlParser::LOOP:
          case tsqlParser::MARK:
          case tsqlParser::MAX:
          case tsqlParser::MAXDOP:
          case tsqlParser::MAXRECURSION:
          case tsqlParser::MIN:
          case tsqlParser::MODIFY:
          case tsqlParser::NAME:
          case tsqlParser::NOCOUNT:
          case tsqlParser::NODES:
          case tsqlParser::NOEXPAND:
          case tsqlParser::NORECOMPUTE:
          case tsqlParser::NTILE:
          case tsqlParser::NUMBER:
          case tsqlParser::OFFSET:
          case tsqlParser::ONLINE:
          case tsqlParser::ONLY:
          case tsqlParser::OPTIMISTIC:
          case tsqlParser::OPTIMIZE:
          case tsqlParser::OUT:
          case tsqlParser::OUTPUT:
          case tsqlParser::OWNER:
          case tsqlParser::PARAMETERIZATION:
          case tsqlParser::PARTITION:
          case tsqlParser::PATH:
          case tsqlParser::PRECEDING:
          case tsqlParser::PRIOR:
          case tsqlParser::PRIVILEGES:
          case tsqlParser::QUERY:
          case tsqlParser::RANGE:
          case tsqlParser::RANK:
          case tsqlParser::READONLY:
          case tsqlParser::READ_ONLY:
          case tsqlParser::RECOMPILE:
          case tsqlParser::RELATIVE:
          case tsqlParser::REMOTE:
          case tsqlParser::REPEATABLE:
          case tsqlParser::ROBUST:
          case tsqlParser::ROOT:
          case tsqlParser::ROW:
          case tsqlParser::ROWGUID:
          case tsqlParser::ROWS:
          case tsqlParser::ROW_NUMBER:
          case tsqlParser::SAMPLE:
          case tsqlParser::SCHEMABINDING:
          case tsqlParser::SCROLL:
          case tsqlParser::SCROLL_LOCKS:
          case tsqlParser::SELF:
          case tsqlParser::SERIALIZABLE:
          case tsqlParser::SIMPLE:
          case tsqlParser::SIZE:
          case tsqlParser::SNAPSHOT:
          case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case tsqlParser::STATIC:
          case tsqlParser::STATS_STREAM:
          case tsqlParser::STDEV:
          case tsqlParser::STDEVP:
          case tsqlParser::SUM:
          case tsqlParser::TEXTIMAGE_ON:
          case tsqlParser::THROW:
          case tsqlParser::TIES:
          case tsqlParser::TIME:
          case tsqlParser::TRY:
          case tsqlParser::TYPE:
          case tsqlParser::TYPE_WARNING:
          case tsqlParser::UNBOUNDED:
          case tsqlParser::UNCOMMITTED:
          case tsqlParser::UNKNOWN:
          case tsqlParser::USING:
          case tsqlParser::VAR:
          case tsqlParser::VARP:
          case tsqlParser::VIEWS:
          case tsqlParser::VIEW_METADATA:
          case tsqlParser::WORK:
          case tsqlParser::XML:
          case tsqlParser::XMLNAMESPACES:
          case tsqlParser::ZONE:
          case tsqlParser::DOUBLE_QUOTE_ID:
          case tsqlParser::SQUARE_BRACKET_ID:
          case tsqlParser::ID: {
            setState(1195);
            r_id();
            break;
          }

          case tsqlParser::STRING: {
            setState(1196);
            match(tsqlParser::STRING);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case tsqlParser::DEFAULT_FULLTEXT_LANGUAGE: {
        enterOuterAlt(_localctx, 4);
        setState(1199);
        match(tsqlParser::DEFAULT_FULLTEXT_LANGUAGE);
        setState(1200);
        match(tsqlParser::EQUAL);
        setState(1203);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::FORCESEEK:
          case tsqlParser::NEXT:
          case tsqlParser::NUMERIC:
          case tsqlParser::VALUE:
          case tsqlParser::ABSOLUTE:
          case tsqlParser::APPLY:
          case tsqlParser::AUTO:
          case tsqlParser::AVG:
          case tsqlParser::BASE64:
          case tsqlParser::CALLER:
          case tsqlParser::CAST:
          case tsqlParser::CATCH:
          case tsqlParser::CHECKSUM_AGG:
          case tsqlParser::COMMITTED:
          case tsqlParser::CONCAT:
          case tsqlParser::CONTROL:
          case tsqlParser::COOKIE:
          case tsqlParser::COUNT:
          case tsqlParser::COUNT_BIG:
          case tsqlParser::DATE:
          case tsqlParser::DELAY:
          case tsqlParser::DELETED:
          case tsqlParser::DENSE_RANK:
          case tsqlParser::DISABLE:
          case tsqlParser::DYNAMIC:
          case tsqlParser::ENCRYPTION:
          case tsqlParser::EXIST:
          case tsqlParser::EXPAND:
          case tsqlParser::FAST:
          case tsqlParser::FAST_FORWARD:
          case tsqlParser::FIRST:
          case tsqlParser::FIRST_VALUE:
          case tsqlParser::FOLLOWING:
          case tsqlParser::FORCE:
          case tsqlParser::FORCED:
          case tsqlParser::FORWARD_ONLY:
          case tsqlParser::FULLSCAN:
          case tsqlParser::GLOBAL:
          case tsqlParser::GROUPING:
          case tsqlParser::GROUPING_ID:
          case tsqlParser::HASH:
          case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case tsqlParser::IMPERSONATE:
          case tsqlParser::INSENSITIVE:
          case tsqlParser::INSERTED:
          case tsqlParser::ISOLATION:
          case tsqlParser::IO:
          case tsqlParser::KEEP:
          case tsqlParser::KEEPFIXED:
          case tsqlParser::KEYSET:
          case tsqlParser::LAG:
          case tsqlParser::LAST:
          case tsqlParser::LAST_VALUE:
          case tsqlParser::LEAD:
          case tsqlParser::LEVEL:
          case tsqlParser::LOCAL:
          case tsqlParser::LOCK_ESCALATION:
          case tsqlParser::LOGIN:
          case tsqlParser::LOOP:
          case tsqlParser::MARK:
          case tsqlParser::MAX:
          case tsqlParser::MAXDOP:
          case tsqlParser::MAXRECURSION:
          case tsqlParser::MIN:
          case tsqlParser::MODIFY:
          case tsqlParser::NAME:
          case tsqlParser::NOCOUNT:
          case tsqlParser::NODES:
          case tsqlParser::NOEXPAND:
          case tsqlParser::NORECOMPUTE:
          case tsqlParser::NTILE:
          case tsqlParser::NUMBER:
          case tsqlParser::OFFSET:
          case tsqlParser::ONLINE:
          case tsqlParser::ONLY:
          case tsqlParser::OPTIMISTIC:
          case tsqlParser::OPTIMIZE:
          case tsqlParser::OUT:
          case tsqlParser::OUTPUT:
          case tsqlParser::OWNER:
          case tsqlParser::PARAMETERIZATION:
          case tsqlParser::PARTITION:
          case tsqlParser::PATH:
          case tsqlParser::PRECEDING:
          case tsqlParser::PRIOR:
          case tsqlParser::PRIVILEGES:
          case tsqlParser::QUERY:
          case tsqlParser::RANGE:
          case tsqlParser::RANK:
          case tsqlParser::READONLY:
          case tsqlParser::READ_ONLY:
          case tsqlParser::RECOMPILE:
          case tsqlParser::RELATIVE:
          case tsqlParser::REMOTE:
          case tsqlParser::REPEATABLE:
          case tsqlParser::ROBUST:
          case tsqlParser::ROOT:
          case tsqlParser::ROW:
          case tsqlParser::ROWGUID:
          case tsqlParser::ROWS:
          case tsqlParser::ROW_NUMBER:
          case tsqlParser::SAMPLE:
          case tsqlParser::SCHEMABINDING:
          case tsqlParser::SCROLL:
          case tsqlParser::SCROLL_LOCKS:
          case tsqlParser::SELF:
          case tsqlParser::SERIALIZABLE:
          case tsqlParser::SIMPLE:
          case tsqlParser::SIZE:
          case tsqlParser::SNAPSHOT:
          case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case tsqlParser::STATIC:
          case tsqlParser::STATS_STREAM:
          case tsqlParser::STDEV:
          case tsqlParser::STDEVP:
          case tsqlParser::SUM:
          case tsqlParser::TEXTIMAGE_ON:
          case tsqlParser::THROW:
          case tsqlParser::TIES:
          case tsqlParser::TIME:
          case tsqlParser::TRY:
          case tsqlParser::TYPE:
          case tsqlParser::TYPE_WARNING:
          case tsqlParser::UNBOUNDED:
          case tsqlParser::UNCOMMITTED:
          case tsqlParser::UNKNOWN:
          case tsqlParser::USING:
          case tsqlParser::VAR:
          case tsqlParser::VARP:
          case tsqlParser::VIEWS:
          case tsqlParser::VIEW_METADATA:
          case tsqlParser::WORK:
          case tsqlParser::XML:
          case tsqlParser::XMLNAMESPACES:
          case tsqlParser::ZONE:
          case tsqlParser::DOUBLE_QUOTE_ID:
          case tsqlParser::SQUARE_BRACKET_ID:
          case tsqlParser::ID: {
            setState(1201);
            r_id();
            break;
          }

          case tsqlParser::STRING: {
            setState(1202);
            match(tsqlParser::STRING);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case tsqlParser::NESTED_TRIGGERS: {
        enterOuterAlt(_localctx, 5);
        setState(1205);
        match(tsqlParser::NESTED_TRIGGERS);
        setState(1206);
        match(tsqlParser::EQUAL);
        setState(1207);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::OFF

        || _la == tsqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case tsqlParser::TRANSFORM_NOISE_WORDS: {
        enterOuterAlt(_localctx, 6);
        setState(1208);
        match(tsqlParser::TRANSFORM_NOISE_WORDS);
        setState(1209);
        match(tsqlParser::EQUAL);
        setState(1210);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::OFF

        || _la == tsqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case tsqlParser::TWO_DIGIT_YEAR_CUTOFF: {
        enterOuterAlt(_localctx, 7);
        setState(1211);
        match(tsqlParser::TWO_DIGIT_YEAR_CUTOFF);
        setState(1212);
        match(tsqlParser::EQUAL);
        setState(1213);
        match(tsqlParser::DECIMAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hadr_optionsContext ------------------------------------------------------------------

tsqlParser::Hadr_optionsContext::Hadr_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Hadr_optionsContext::ALTER() {
  return getToken(tsqlParser::ALTER, 0);
}

tree::TerminalNode* tsqlParser::Hadr_optionsContext::DATABASE() {
  return getToken(tsqlParser::DATABASE, 0);
}

tree::TerminalNode* tsqlParser::Hadr_optionsContext::SET() {
  return getToken(tsqlParser::SET, 0);
}

tree::TerminalNode* tsqlParser::Hadr_optionsContext::HADR() {
  return getToken(tsqlParser::HADR, 0);
}


size_t tsqlParser::Hadr_optionsContext::getRuleIndex() const {
  return tsqlParser::RuleHadr_options;
}


antlrcpp::Any tsqlParser::Hadr_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitHadr_options(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Hadr_optionsContext* tsqlParser::hadr_options() {
  Hadr_optionsContext *_localctx = _tracker.createInstance<Hadr_optionsContext>(_ctx, getState());
  enterRule(_localctx, 110, tsqlParser::RuleHadr_options);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1216);
    match(tsqlParser::ALTER);
    setState(1217);
    match(tsqlParser::DATABASE);
    setState(1218);
    match(tsqlParser::SET);
    setState(1219);
    match(tsqlParser::HADR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mixed_page_allocation_optionContext ------------------------------------------------------------------

tsqlParser::Mixed_page_allocation_optionContext::Mixed_page_allocation_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Mixed_page_allocation_optionContext::MIXED_PAGE_ALLOCATION() {
  return getToken(tsqlParser::MIXED_PAGE_ALLOCATION, 0);
}

tree::TerminalNode* tsqlParser::Mixed_page_allocation_optionContext::OFF() {
  return getToken(tsqlParser::OFF, 0);
}

tree::TerminalNode* tsqlParser::Mixed_page_allocation_optionContext::ON() {
  return getToken(tsqlParser::ON, 0);
}


size_t tsqlParser::Mixed_page_allocation_optionContext::getRuleIndex() const {
  return tsqlParser::RuleMixed_page_allocation_option;
}


antlrcpp::Any tsqlParser::Mixed_page_allocation_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitMixed_page_allocation_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Mixed_page_allocation_optionContext* tsqlParser::mixed_page_allocation_option() {
  Mixed_page_allocation_optionContext *_localctx = _tracker.createInstance<Mixed_page_allocation_optionContext>(_ctx, getState());
  enterRule(_localctx, 112, tsqlParser::RuleMixed_page_allocation_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1221);
    match(tsqlParser::MIXED_PAGE_ALLOCATION);
    setState(1222);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::OFF

    || _la == tsqlParser::ON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameterization_optionContext ------------------------------------------------------------------

tsqlParser::Parameterization_optionContext::Parameterization_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Parameterization_optionContext::PARAMETERIZATION() {
  return getToken(tsqlParser::PARAMETERIZATION, 0);
}

tree::TerminalNode* tsqlParser::Parameterization_optionContext::SIMPLE() {
  return getToken(tsqlParser::SIMPLE, 0);
}

tree::TerminalNode* tsqlParser::Parameterization_optionContext::FORCED() {
  return getToken(tsqlParser::FORCED, 0);
}


size_t tsqlParser::Parameterization_optionContext::getRuleIndex() const {
  return tsqlParser::RuleParameterization_option;
}


antlrcpp::Any tsqlParser::Parameterization_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitParameterization_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Parameterization_optionContext* tsqlParser::parameterization_option() {
  Parameterization_optionContext *_localctx = _tracker.createInstance<Parameterization_optionContext>(_ctx, getState());
  enterRule(_localctx, 114, tsqlParser::RuleParameterization_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1224);
    match(tsqlParser::PARAMETERIZATION);
    setState(1225);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::FORCED || _la == tsqlParser::SIMPLE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recovery_optionContext ------------------------------------------------------------------

tsqlParser::Recovery_optionContext::Recovery_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Recovery_optionContext::RECOVERY() {
  return getToken(tsqlParser::RECOVERY, 0);
}

tree::TerminalNode* tsqlParser::Recovery_optionContext::FULL() {
  return getToken(tsqlParser::FULL, 0);
}

tree::TerminalNode* tsqlParser::Recovery_optionContext::BULK_LOGGED() {
  return getToken(tsqlParser::BULK_LOGGED, 0);
}

tree::TerminalNode* tsqlParser::Recovery_optionContext::SIMPLE() {
  return getToken(tsqlParser::SIMPLE, 0);
}

tree::TerminalNode* tsqlParser::Recovery_optionContext::TORN_PAGE_DETECTION() {
  return getToken(tsqlParser::TORN_PAGE_DETECTION, 0);
}

tsqlParser::On_offContext* tsqlParser::Recovery_optionContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}

tree::TerminalNode* tsqlParser::Recovery_optionContext::PAGE_VERIFY() {
  return getToken(tsqlParser::PAGE_VERIFY, 0);
}

tree::TerminalNode* tsqlParser::Recovery_optionContext::CHECKSUM() {
  return getToken(tsqlParser::CHECKSUM, 0);
}

tree::TerminalNode* tsqlParser::Recovery_optionContext::NONE() {
  return getToken(tsqlParser::NONE, 0);
}


size_t tsqlParser::Recovery_optionContext::getRuleIndex() const {
  return tsqlParser::RuleRecovery_option;
}


antlrcpp::Any tsqlParser::Recovery_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitRecovery_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Recovery_optionContext* tsqlParser::recovery_option() {
  Recovery_optionContext *_localctx = _tracker.createInstance<Recovery_optionContext>(_ctx, getState());
  enterRule(_localctx, 116, tsqlParser::RuleRecovery_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1233);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::RECOVERY: {
        enterOuterAlt(_localctx, 1);
        setState(1227);
        match(tsqlParser::RECOVERY);
        setState(1228);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::FULL || _la == tsqlParser::BULK_LOGGED || _la == tsqlParser::SIMPLE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case tsqlParser::TORN_PAGE_DETECTION: {
        enterOuterAlt(_localctx, 2);
        setState(1229);
        match(tsqlParser::TORN_PAGE_DETECTION);
        setState(1230);
        on_off();
        break;
      }

      case tsqlParser::PAGE_VERIFY: {
        enterOuterAlt(_localctx, 3);
        setState(1231);
        match(tsqlParser::PAGE_VERIFY);
        setState(1232);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::NONE || _la == tsqlParser::CHECKSUM || _la == tsqlParser::TORN_PAGE_DETECTION)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Service_broker_optionContext ------------------------------------------------------------------

tsqlParser::Service_broker_optionContext::Service_broker_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Service_broker_optionContext::ENABLE_BROKER() {
  return getToken(tsqlParser::ENABLE_BROKER, 0);
}

tree::TerminalNode* tsqlParser::Service_broker_optionContext::DISABLE_BROKER() {
  return getToken(tsqlParser::DISABLE_BROKER, 0);
}

tree::TerminalNode* tsqlParser::Service_broker_optionContext::NEW_BROKER() {
  return getToken(tsqlParser::NEW_BROKER, 0);
}

tree::TerminalNode* tsqlParser::Service_broker_optionContext::ERROR_BROKER_CONVERSATIONS() {
  return getToken(tsqlParser::ERROR_BROKER_CONVERSATIONS, 0);
}

tree::TerminalNode* tsqlParser::Service_broker_optionContext::HONOR_BROKER_PRIORITY() {
  return getToken(tsqlParser::HONOR_BROKER_PRIORITY, 0);
}

tsqlParser::On_offContext* tsqlParser::Service_broker_optionContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}


size_t tsqlParser::Service_broker_optionContext::getRuleIndex() const {
  return tsqlParser::RuleService_broker_option;
}


antlrcpp::Any tsqlParser::Service_broker_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitService_broker_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Service_broker_optionContext* tsqlParser::service_broker_option() {
  Service_broker_optionContext *_localctx = _tracker.createInstance<Service_broker_optionContext>(_ctx, getState());
  enterRule(_localctx, 118, tsqlParser::RuleService_broker_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1241);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::ENABLE_BROKER: {
        enterOuterAlt(_localctx, 1);
        setState(1235);
        match(tsqlParser::ENABLE_BROKER);
        break;
      }

      case tsqlParser::DISABLE_BROKER: {
        enterOuterAlt(_localctx, 2);
        setState(1236);
        match(tsqlParser::DISABLE_BROKER);
        break;
      }

      case tsqlParser::NEW_BROKER: {
        enterOuterAlt(_localctx, 3);
        setState(1237);
        match(tsqlParser::NEW_BROKER);
        break;
      }

      case tsqlParser::ERROR_BROKER_CONVERSATIONS: {
        enterOuterAlt(_localctx, 4);
        setState(1238);
        match(tsqlParser::ERROR_BROKER_CONVERSATIONS);
        break;
      }

      case tsqlParser::HONOR_BROKER_PRIORITY: {
        enterOuterAlt(_localctx, 5);
        setState(1239);
        match(tsqlParser::HONOR_BROKER_PRIORITY);
        setState(1240);
        on_off();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Snapshot_optionContext ------------------------------------------------------------------

tsqlParser::Snapshot_optionContext::Snapshot_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Snapshot_optionContext::ALLOW_SNAPSHOT_ISOLATION() {
  return getToken(tsqlParser::ALLOW_SNAPSHOT_ISOLATION, 0);
}

tsqlParser::On_offContext* tsqlParser::Snapshot_optionContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}

tree::TerminalNode* tsqlParser::Snapshot_optionContext::READ_COMMITTED_SNAPSHOT() {
  return getToken(tsqlParser::READ_COMMITTED_SNAPSHOT, 0);
}

tree::TerminalNode* tsqlParser::Snapshot_optionContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

tree::TerminalNode* tsqlParser::Snapshot_optionContext::OFF() {
  return getToken(tsqlParser::OFF, 0);
}


size_t tsqlParser::Snapshot_optionContext::getRuleIndex() const {
  return tsqlParser::RuleSnapshot_option;
}


antlrcpp::Any tsqlParser::Snapshot_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSnapshot_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Snapshot_optionContext* tsqlParser::snapshot_option() {
  Snapshot_optionContext *_localctx = _tracker.createInstance<Snapshot_optionContext>(_ctx, getState());
  enterRule(_localctx, 120, tsqlParser::RuleSnapshot_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1248);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::ALLOW_SNAPSHOT_ISOLATION: {
        enterOuterAlt(_localctx, 1);
        setState(1243);
        match(tsqlParser::ALLOW_SNAPSHOT_ISOLATION);
        setState(1244);
        on_off();
        break;
      }

      case tsqlParser::READ_COMMITTED_SNAPSHOT: {
        enterOuterAlt(_localctx, 2);
        setState(1245);
        match(tsqlParser::READ_COMMITTED_SNAPSHOT);
        setState(1246);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::OFF

        || _la == tsqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case tsqlParser::OFF:
      case tsqlParser::ON: {
        enterOuterAlt(_localctx, 3);
        setState(1247);
        dynamic_cast<Snapshot_optionContext *>(_localctx)->MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::OFF

        || _la == tsqlParser::ON)) {
          dynamic_cast<Snapshot_optionContext *>(_localctx)->MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_optionContext ------------------------------------------------------------------

tsqlParser::Sql_optionContext::Sql_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Sql_optionContext::ANSI_NULL_DEFAULT() {
  return getToken(tsqlParser::ANSI_NULL_DEFAULT, 0);
}

tsqlParser::On_offContext* tsqlParser::Sql_optionContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}

tree::TerminalNode* tsqlParser::Sql_optionContext::ANSI_NULLS() {
  return getToken(tsqlParser::ANSI_NULLS, 0);
}

tree::TerminalNode* tsqlParser::Sql_optionContext::ANSI_PADDING() {
  return getToken(tsqlParser::ANSI_PADDING, 0);
}

tree::TerminalNode* tsqlParser::Sql_optionContext::ANSI_WARNINGS() {
  return getToken(tsqlParser::ANSI_WARNINGS, 0);
}

tree::TerminalNode* tsqlParser::Sql_optionContext::ARITHABORT() {
  return getToken(tsqlParser::ARITHABORT, 0);
}

tree::TerminalNode* tsqlParser::Sql_optionContext::COMPATIBILITY_LEVEL() {
  return getToken(tsqlParser::COMPATIBILITY_LEVEL, 0);
}

tree::TerminalNode* tsqlParser::Sql_optionContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Sql_optionContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tree::TerminalNode* tsqlParser::Sql_optionContext::CONCAT_NULL_YIELDS_NULL() {
  return getToken(tsqlParser::CONCAT_NULL_YIELDS_NULL, 0);
}

tree::TerminalNode* tsqlParser::Sql_optionContext::NUMERIC_ROUNDABORT() {
  return getToken(tsqlParser::NUMERIC_ROUNDABORT, 0);
}

tree::TerminalNode* tsqlParser::Sql_optionContext::QUOTED_IDENTIFIER() {
  return getToken(tsqlParser::QUOTED_IDENTIFIER, 0);
}

tree::TerminalNode* tsqlParser::Sql_optionContext::RECURSIVE_TRIGGERS() {
  return getToken(tsqlParser::RECURSIVE_TRIGGERS, 0);
}


size_t tsqlParser::Sql_optionContext::getRuleIndex() const {
  return tsqlParser::RuleSql_option;
}


antlrcpp::Any tsqlParser::Sql_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSql_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Sql_optionContext* tsqlParser::sql_option() {
  Sql_optionContext *_localctx = _tracker.createInstance<Sql_optionContext>(_ctx, getState());
  enterRule(_localctx, 122, tsqlParser::RuleSql_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1271);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::ANSI_NULL_DEFAULT: {
        enterOuterAlt(_localctx, 1);
        setState(1250);
        match(tsqlParser::ANSI_NULL_DEFAULT);
        setState(1251);
        on_off();
        break;
      }

      case tsqlParser::ANSI_NULLS: {
        enterOuterAlt(_localctx, 2);
        setState(1252);
        match(tsqlParser::ANSI_NULLS);
        setState(1253);
        on_off();
        break;
      }

      case tsqlParser::ANSI_PADDING: {
        enterOuterAlt(_localctx, 3);
        setState(1254);
        match(tsqlParser::ANSI_PADDING);
        setState(1255);
        on_off();
        break;
      }

      case tsqlParser::ANSI_WARNINGS: {
        enterOuterAlt(_localctx, 4);
        setState(1256);
        match(tsqlParser::ANSI_WARNINGS);
        setState(1257);
        on_off();
        break;
      }

      case tsqlParser::ARITHABORT: {
        enterOuterAlt(_localctx, 5);
        setState(1258);
        match(tsqlParser::ARITHABORT);
        setState(1259);
        on_off();
        break;
      }

      case tsqlParser::COMPATIBILITY_LEVEL: {
        enterOuterAlt(_localctx, 6);
        setState(1260);
        match(tsqlParser::COMPATIBILITY_LEVEL);
        setState(1261);
        match(tsqlParser::EQUAL);
        setState(1262);
        match(tsqlParser::DECIMAL);
        break;
      }

      case tsqlParser::CONCAT_NULL_YIELDS_NULL: {
        enterOuterAlt(_localctx, 7);
        setState(1263);
        match(tsqlParser::CONCAT_NULL_YIELDS_NULL);
        setState(1264);
        on_off();
        break;
      }

      case tsqlParser::NUMERIC_ROUNDABORT: {
        enterOuterAlt(_localctx, 8);
        setState(1265);
        match(tsqlParser::NUMERIC_ROUNDABORT);
        setState(1266);
        on_off();
        break;
      }

      case tsqlParser::QUOTED_IDENTIFIER: {
        enterOuterAlt(_localctx, 9);
        setState(1267);
        match(tsqlParser::QUOTED_IDENTIFIER);
        setState(1268);
        on_off();
        break;
      }

      case tsqlParser::RECURSIVE_TRIGGERS: {
        enterOuterAlt(_localctx, 10);
        setState(1269);
        match(tsqlParser::RECURSIVE_TRIGGERS);
        setState(1270);
        on_off();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Target_recovery_time_optionContext ------------------------------------------------------------------

tsqlParser::Target_recovery_time_optionContext::Target_recovery_time_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Target_recovery_time_optionContext::TARGET_RECOVERY_TIME() {
  return getToken(tsqlParser::TARGET_RECOVERY_TIME, 0);
}

tree::TerminalNode* tsqlParser::Target_recovery_time_optionContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Target_recovery_time_optionContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tree::TerminalNode* tsqlParser::Target_recovery_time_optionContext::SECONDS() {
  return getToken(tsqlParser::SECONDS, 0);
}

tree::TerminalNode* tsqlParser::Target_recovery_time_optionContext::MINUTES() {
  return getToken(tsqlParser::MINUTES, 0);
}


size_t tsqlParser::Target_recovery_time_optionContext::getRuleIndex() const {
  return tsqlParser::RuleTarget_recovery_time_option;
}


antlrcpp::Any tsqlParser::Target_recovery_time_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTarget_recovery_time_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Target_recovery_time_optionContext* tsqlParser::target_recovery_time_option() {
  Target_recovery_time_optionContext *_localctx = _tracker.createInstance<Target_recovery_time_optionContext>(_ctx, getState());
  enterRule(_localctx, 124, tsqlParser::RuleTarget_recovery_time_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1273);
    match(tsqlParser::TARGET_RECOVERY_TIME);
    setState(1274);
    match(tsqlParser::EQUAL);
    setState(1275);
    match(tsqlParser::DECIMAL);
    setState(1276);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::MINUTES

    || _la == tsqlParser::SECONDS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TerminationContext ------------------------------------------------------------------

tsqlParser::TerminationContext::TerminationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::TerminationContext::ROLLBACK() {
  return getToken(tsqlParser::ROLLBACK, 0);
}

tree::TerminalNode* tsqlParser::TerminationContext::AFTER() {
  return getToken(tsqlParser::AFTER, 0);
}

tree::TerminalNode* tsqlParser::TerminationContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tree::TerminalNode* tsqlParser::TerminationContext::IMMEDIATE() {
  return getToken(tsqlParser::IMMEDIATE, 0);
}

tree::TerminalNode* tsqlParser::TerminationContext::NO_WAIT() {
  return getToken(tsqlParser::NO_WAIT, 0);
}


size_t tsqlParser::TerminationContext::getRuleIndex() const {
  return tsqlParser::RuleTermination;
}


antlrcpp::Any tsqlParser::TerminationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTermination(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::TerminationContext* tsqlParser::termination() {
  TerminationContext *_localctx = _tracker.createInstance<TerminationContext>(_ctx, getState());
  enterRule(_localctx, 126, tsqlParser::RuleTermination);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1284);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1278);
      match(tsqlParser::ROLLBACK);
      setState(1279);
      match(tsqlParser::AFTER);
      setState(1280);
      dynamic_cast<TerminationContext *>(_localctx)->seconds = match(tsqlParser::DECIMAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1281);
      match(tsqlParser::ROLLBACK);
      setState(1282);
      match(tsqlParser::IMMEDIATE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1283);
      match(tsqlParser::NO_WAIT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_indexContext ------------------------------------------------------------------

tsqlParser::Drop_indexContext::Drop_indexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Drop_indexContext::DROP() {
  return getToken(tsqlParser::DROP, 0);
}

tree::TerminalNode* tsqlParser::Drop_indexContext::INDEX() {
  return getToken(tsqlParser::INDEX, 0);
}

tsqlParser::R_idContext* tsqlParser::Drop_indexContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Drop_indexContext::IF() {
  return getToken(tsqlParser::IF, 0);
}

tree::TerminalNode* tsqlParser::Drop_indexContext::EXISTS() {
  return getToken(tsqlParser::EXISTS, 0);
}

tree::TerminalNode* tsqlParser::Drop_indexContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Drop_indexContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Drop_indexContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Drop_indexContext::getRuleIndex() const {
  return tsqlParser::RuleDrop_index;
}


antlrcpp::Any tsqlParser::Drop_indexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDrop_index(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Drop_indexContext* tsqlParser::drop_index() {
  Drop_indexContext *_localctx = _tracker.createInstance<Drop_indexContext>(_ctx, getState());
  enterRule(_localctx, 128, tsqlParser::RuleDrop_index);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1286);
    match(tsqlParser::DROP);
    setState(1287);
    match(tsqlParser::INDEX);
    setState(1290);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::IF) {
      setState(1288);
      match(tsqlParser::IF);
      setState(1289);
      match(tsqlParser::EXISTS);
    }
    setState(1292);
    dynamic_cast<Drop_indexContext *>(_localctx)->name = r_id();
    setState(1295);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::ON) {
      setState(1293);
      match(tsqlParser::ON);
      setState(1294);
      table_name();
    }
    setState(1298);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx)) {
    case 1: {
      setState(1297);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_procedureContext ------------------------------------------------------------------

tsqlParser::Drop_procedureContext::Drop_procedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Drop_procedureContext::DROP() {
  return getToken(tsqlParser::DROP, 0);
}

tree::TerminalNode* tsqlParser::Drop_procedureContext::PROCEDURE() {
  return getToken(tsqlParser::PROCEDURE, 0);
}

tsqlParser::Func_proc_nameContext* tsqlParser::Drop_procedureContext::func_proc_name() {
  return getRuleContext<tsqlParser::Func_proc_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Drop_procedureContext::IF() {
  return getToken(tsqlParser::IF, 0);
}

tree::TerminalNode* tsqlParser::Drop_procedureContext::EXISTS() {
  return getToken(tsqlParser::EXISTS, 0);
}

tree::TerminalNode* tsqlParser::Drop_procedureContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Drop_procedureContext::getRuleIndex() const {
  return tsqlParser::RuleDrop_procedure;
}


antlrcpp::Any tsqlParser::Drop_procedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDrop_procedure(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Drop_procedureContext* tsqlParser::drop_procedure() {
  Drop_procedureContext *_localctx = _tracker.createInstance<Drop_procedureContext>(_ctx, getState());
  enterRule(_localctx, 130, tsqlParser::RuleDrop_procedure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1300);
    match(tsqlParser::DROP);
    setState(1301);
    match(tsqlParser::PROCEDURE);
    setState(1304);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::IF) {
      setState(1302);
      match(tsqlParser::IF);
      setState(1303);
      match(tsqlParser::EXISTS);
    }
    setState(1306);
    func_proc_name();
    setState(1308);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
    case 1: {
      setState(1307);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_statisticsContext ------------------------------------------------------------------

tsqlParser::Drop_statisticsContext::Drop_statisticsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Drop_statisticsContext::DROP() {
  return getToken(tsqlParser::DROP, 0);
}

tree::TerminalNode* tsqlParser::Drop_statisticsContext::STATISTICS() {
  return getToken(tsqlParser::STATISTICS, 0);
}

tree::TerminalNode* tsqlParser::Drop_statisticsContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tsqlParser::R_idContext* tsqlParser::Drop_statisticsContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tsqlParser::Table_nameContext* tsqlParser::Drop_statisticsContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Drop_statisticsContext::DOT() {
  return getToken(tsqlParser::DOT, 0);
}


size_t tsqlParser::Drop_statisticsContext::getRuleIndex() const {
  return tsqlParser::RuleDrop_statistics;
}


antlrcpp::Any tsqlParser::Drop_statisticsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDrop_statistics(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Drop_statisticsContext* tsqlParser::drop_statistics() {
  Drop_statisticsContext *_localctx = _tracker.createInstance<Drop_statisticsContext>(_ctx, getState());
  enterRule(_localctx, 132, tsqlParser::RuleDrop_statistics);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1310);
    match(tsqlParser::DROP);
    setState(1311);
    match(tsqlParser::STATISTICS);
    setState(1315);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx)) {
    case 1: {
      setState(1312);
      table_name();
      setState(1313);
      match(tsqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(1317);
    dynamic_cast<Drop_statisticsContext *>(_localctx)->name = r_id();
    setState(1318);
    match(tsqlParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_tableContext ------------------------------------------------------------------

tsqlParser::Drop_tableContext::Drop_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Drop_tableContext::DROP() {
  return getToken(tsqlParser::DROP, 0);
}

tree::TerminalNode* tsqlParser::Drop_tableContext::TABLE() {
  return getToken(tsqlParser::TABLE, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Drop_tableContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Drop_tableContext::IF() {
  return getToken(tsqlParser::IF, 0);
}

tree::TerminalNode* tsqlParser::Drop_tableContext::EXISTS() {
  return getToken(tsqlParser::EXISTS, 0);
}

tree::TerminalNode* tsqlParser::Drop_tableContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Drop_tableContext::getRuleIndex() const {
  return tsqlParser::RuleDrop_table;
}


antlrcpp::Any tsqlParser::Drop_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDrop_table(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Drop_tableContext* tsqlParser::drop_table() {
  Drop_tableContext *_localctx = _tracker.createInstance<Drop_tableContext>(_ctx, getState());
  enterRule(_localctx, 134, tsqlParser::RuleDrop_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1320);
    match(tsqlParser::DROP);
    setState(1321);
    match(tsqlParser::TABLE);
    setState(1324);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::IF) {
      setState(1322);
      match(tsqlParser::IF);
      setState(1323);
      match(tsqlParser::EXISTS);
    }
    setState(1326);
    table_name();
    setState(1328);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx)) {
    case 1: {
      setState(1327);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_databaseContext ------------------------------------------------------------------

tsqlParser::Drop_databaseContext::Drop_databaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Drop_databaseContext::DROP() {
  return getToken(tsqlParser::DROP, 0);
}

tree::TerminalNode* tsqlParser::Drop_databaseContext::DATABASE() {
  return getToken(tsqlParser::DATABASE, 0);
}

tree::TerminalNode* tsqlParser::Drop_databaseContext::CURRENT() {
  return getToken(tsqlParser::CURRENT, 0);
}

tree::TerminalNode* tsqlParser::Drop_databaseContext::IF() {
  return getToken(tsqlParser::IF, 0);
}

tree::TerminalNode* tsqlParser::Drop_databaseContext::EXISTS() {
  return getToken(tsqlParser::EXISTS, 0);
}

tsqlParser::R_idContext* tsqlParser::Drop_databaseContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Drop_databaseContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Drop_databaseContext::getRuleIndex() const {
  return tsqlParser::RuleDrop_database;
}


antlrcpp::Any tsqlParser::Drop_databaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDrop_database(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Drop_databaseContext* tsqlParser::drop_database() {
  Drop_databaseContext *_localctx = _tracker.createInstance<Drop_databaseContext>(_ctx, getState());
  enterRule(_localctx, 136, tsqlParser::RuleDrop_database);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1330);
    match(tsqlParser::DROP);
    setState(1331);
    match(tsqlParser::DATABASE);
    setState(1334);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::IF) {
      setState(1332);
      match(tsqlParser::IF);
      setState(1333);
      match(tsqlParser::EXISTS);
    }
    setState(1338);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        setState(1336);
        dynamic_cast<Drop_databaseContext *>(_localctx)->database = r_id();
        break;
      }

      case tsqlParser::CURRENT: {
        setState(1337);
        match(tsqlParser::CURRENT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1341);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx)) {
    case 1: {
      setState(1340);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_synonymContext ------------------------------------------------------------------

tsqlParser::Drop_synonymContext::Drop_synonymContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Drop_synonymContext::DROP() {
  return getToken(tsqlParser::DROP, 0);
}

tree::TerminalNode* tsqlParser::Drop_synonymContext::SYNONYM() {
  return getToken(tsqlParser::SYNONYM, 0);
}

tsqlParser::Simple_nameContext* tsqlParser::Drop_synonymContext::simple_name() {
  return getRuleContext<tsqlParser::Simple_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Drop_synonymContext::IF() {
  return getToken(tsqlParser::IF, 0);
}

tree::TerminalNode* tsqlParser::Drop_synonymContext::EXISTS() {
  return getToken(tsqlParser::EXISTS, 0);
}

tree::TerminalNode* tsqlParser::Drop_synonymContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Drop_synonymContext::getRuleIndex() const {
  return tsqlParser::RuleDrop_synonym;
}


antlrcpp::Any tsqlParser::Drop_synonymContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDrop_synonym(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Drop_synonymContext* tsqlParser::drop_synonym() {
  Drop_synonymContext *_localctx = _tracker.createInstance<Drop_synonymContext>(_ctx, getState());
  enterRule(_localctx, 138, tsqlParser::RuleDrop_synonym);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1343);
    match(tsqlParser::DROP);
    setState(1344);
    match(tsqlParser::SYNONYM);
    setState(1347);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::IF) {
      setState(1345);
      match(tsqlParser::IF);
      setState(1346);
      match(tsqlParser::EXISTS);
    }
    setState(1349);
    simple_name();
    setState(1351);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx)) {
    case 1: {
      setState(1350);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_viewContext ------------------------------------------------------------------

tsqlParser::Drop_viewContext::Drop_viewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Drop_viewContext::DROP() {
  return getToken(tsqlParser::DROP, 0);
}

tree::TerminalNode* tsqlParser::Drop_viewContext::VIEW() {
  return getToken(tsqlParser::VIEW, 0);
}

std::vector<tsqlParser::Simple_nameContext *> tsqlParser::Drop_viewContext::simple_name() {
  return getRuleContexts<tsqlParser::Simple_nameContext>();
}

tsqlParser::Simple_nameContext* tsqlParser::Drop_viewContext::simple_name(size_t i) {
  return getRuleContext<tsqlParser::Simple_nameContext>(i);
}

tree::TerminalNode* tsqlParser::Drop_viewContext::IF() {
  return getToken(tsqlParser::IF, 0);
}

tree::TerminalNode* tsqlParser::Drop_viewContext::EXISTS() {
  return getToken(tsqlParser::EXISTS, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Drop_viewContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Drop_viewContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::Drop_viewContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Drop_viewContext::getRuleIndex() const {
  return tsqlParser::RuleDrop_view;
}


antlrcpp::Any tsqlParser::Drop_viewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDrop_view(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Drop_viewContext* tsqlParser::drop_view() {
  Drop_viewContext *_localctx = _tracker.createInstance<Drop_viewContext>(_ctx, getState());
  enterRule(_localctx, 140, tsqlParser::RuleDrop_view);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1353);
    match(tsqlParser::DROP);
    setState(1354);
    match(tsqlParser::VIEW);
    setState(1357);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::IF) {
      setState(1355);
      match(tsqlParser::IF);
      setState(1356);
      match(tsqlParser::EXISTS);
    }
    setState(1359);
    simple_name();
    setState(1364);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(1360);
      match(tsqlParser::COMMA);
      setState(1361);
      simple_name();
      setState(1366);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1368);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx)) {
    case 1: {
      setState(1367);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_schemaContext ------------------------------------------------------------------

tsqlParser::Drop_schemaContext::Drop_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Drop_schemaContext::DROP() {
  return getToken(tsqlParser::DROP, 0);
}

tree::TerminalNode* tsqlParser::Drop_schemaContext::SCHEMA() {
  return getToken(tsqlParser::SCHEMA, 0);
}

tsqlParser::Simple_nameContext* tsqlParser::Drop_schemaContext::simple_name() {
  return getRuleContext<tsqlParser::Simple_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Drop_schemaContext::IF() {
  return getToken(tsqlParser::IF, 0);
}

tree::TerminalNode* tsqlParser::Drop_schemaContext::EXISTS() {
  return getToken(tsqlParser::EXISTS, 0);
}

tree::TerminalNode* tsqlParser::Drop_schemaContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Drop_schemaContext::getRuleIndex() const {
  return tsqlParser::RuleDrop_schema;
}


antlrcpp::Any tsqlParser::Drop_schemaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDrop_schema(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Drop_schemaContext* tsqlParser::drop_schema() {
  Drop_schemaContext *_localctx = _tracker.createInstance<Drop_schemaContext>(_ctx, getState());
  enterRule(_localctx, 142, tsqlParser::RuleDrop_schema);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1370);
    match(tsqlParser::DROP);
    setState(1371);
    match(tsqlParser::SCHEMA);
    setState(1374);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::IF) {
      setState(1372);
      match(tsqlParser::IF);
      setState(1373);
      match(tsqlParser::EXISTS);
    }
    setState(1376);
    simple_name();
    setState(1378);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx)) {
    case 1: {
      setState(1377);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_typeContext ------------------------------------------------------------------

tsqlParser::Create_typeContext::Create_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Create_typeContext::CREATE() {
  return getToken(tsqlParser::CREATE, 0);
}

tree::TerminalNode* tsqlParser::Create_typeContext::TYPE() {
  return getToken(tsqlParser::TYPE, 0);
}

tree::TerminalNode* tsqlParser::Create_typeContext::FROM() {
  return getToken(tsqlParser::FROM, 0);
}

tsqlParser::Data_typeContext* tsqlParser::Create_typeContext::data_type() {
  return getRuleContext<tsqlParser::Data_typeContext>(0);
}

tsqlParser::Default_valueContext* tsqlParser::Create_typeContext::default_value() {
  return getRuleContext<tsqlParser::Default_valueContext>(0);
}

tsqlParser::Simple_nameContext* tsqlParser::Create_typeContext::simple_name() {
  return getRuleContext<tsqlParser::Simple_nameContext>(0);
}


size_t tsqlParser::Create_typeContext::getRuleIndex() const {
  return tsqlParser::RuleCreate_type;
}


antlrcpp::Any tsqlParser::Create_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_type(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Create_typeContext* tsqlParser::create_type() {
  Create_typeContext *_localctx = _tracker.createInstance<Create_typeContext>(_ctx, getState());
  enterRule(_localctx, 144, tsqlParser::RuleCreate_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1380);
    match(tsqlParser::CREATE);
    setState(1381);
    match(tsqlParser::TYPE);
    setState(1382);
    dynamic_cast<Create_typeContext *>(_localctx)->name = simple_name();
    setState(1383);
    match(tsqlParser::FROM);
    setState(1384);
    data_type();
    setState(1385);
    default_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_typeContext ------------------------------------------------------------------

tsqlParser::Drop_typeContext::Drop_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Drop_typeContext::DROP() {
  return getToken(tsqlParser::DROP, 0);
}

tree::TerminalNode* tsqlParser::Drop_typeContext::TYPE() {
  return getToken(tsqlParser::TYPE, 0);
}

tsqlParser::Simple_nameContext* tsqlParser::Drop_typeContext::simple_name() {
  return getRuleContext<tsqlParser::Simple_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Drop_typeContext::IF() {
  return getToken(tsqlParser::IF, 0);
}

tree::TerminalNode* tsqlParser::Drop_typeContext::EXISTS() {
  return getToken(tsqlParser::EXISTS, 0);
}


size_t tsqlParser::Drop_typeContext::getRuleIndex() const {
  return tsqlParser::RuleDrop_type;
}


antlrcpp::Any tsqlParser::Drop_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDrop_type(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Drop_typeContext* tsqlParser::drop_type() {
  Drop_typeContext *_localctx = _tracker.createInstance<Drop_typeContext>(_ctx, getState());
  enterRule(_localctx, 146, tsqlParser::RuleDrop_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1387);
    match(tsqlParser::DROP);
    setState(1388);
    match(tsqlParser::TYPE);
    setState(1391);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::IF) {
      setState(1389);
      match(tsqlParser::IF);
      setState(1390);
      match(tsqlParser::EXISTS);
    }
    setState(1393);
    dynamic_cast<Drop_typeContext *>(_localctx)->name = simple_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rowset_function_limitedContext ------------------------------------------------------------------

tsqlParser::Rowset_function_limitedContext::Rowset_function_limitedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::OpenqueryContext* tsqlParser::Rowset_function_limitedContext::openquery() {
  return getRuleContext<tsqlParser::OpenqueryContext>(0);
}

tsqlParser::OpendatasourceContext* tsqlParser::Rowset_function_limitedContext::opendatasource() {
  return getRuleContext<tsqlParser::OpendatasourceContext>(0);
}


size_t tsqlParser::Rowset_function_limitedContext::getRuleIndex() const {
  return tsqlParser::RuleRowset_function_limited;
}


antlrcpp::Any tsqlParser::Rowset_function_limitedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitRowset_function_limited(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Rowset_function_limitedContext* tsqlParser::rowset_function_limited() {
  Rowset_function_limitedContext *_localctx = _tracker.createInstance<Rowset_function_limitedContext>(_ctx, getState());
  enterRule(_localctx, 148, tsqlParser::RuleRowset_function_limited);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1397);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::OPENQUERY: {
        enterOuterAlt(_localctx, 1);
        setState(1395);
        openquery();
        break;
      }

      case tsqlParser::OPENDATASOURCE: {
        enterOuterAlt(_localctx, 2);
        setState(1396);
        opendatasource();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpenqueryContext ------------------------------------------------------------------

tsqlParser::OpenqueryContext::OpenqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::OpenqueryContext::OPENQUERY() {
  return getToken(tsqlParser::OPENQUERY, 0);
}

tree::TerminalNode* tsqlParser::OpenqueryContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::OpenqueryContext::COMMA() {
  return getToken(tsqlParser::COMMA, 0);
}

tree::TerminalNode* tsqlParser::OpenqueryContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::R_idContext* tsqlParser::OpenqueryContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::OpenqueryContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}


size_t tsqlParser::OpenqueryContext::getRuleIndex() const {
  return tsqlParser::RuleOpenquery;
}


antlrcpp::Any tsqlParser::OpenqueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOpenquery(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::OpenqueryContext* tsqlParser::openquery() {
  OpenqueryContext *_localctx = _tracker.createInstance<OpenqueryContext>(_ctx, getState());
  enterRule(_localctx, 150, tsqlParser::RuleOpenquery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1399);
    match(tsqlParser::OPENQUERY);
    setState(1400);
    match(tsqlParser::LR_BRACKET);
    setState(1401);
    dynamic_cast<OpenqueryContext *>(_localctx)->linked_server = r_id();
    setState(1402);
    match(tsqlParser::COMMA);
    setState(1403);
    dynamic_cast<OpenqueryContext *>(_localctx)->query = match(tsqlParser::STRING);
    setState(1404);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpendatasourceContext ------------------------------------------------------------------

tsqlParser::OpendatasourceContext::OpendatasourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::OpendatasourceContext::OPENDATASOURCE() {
  return getToken(tsqlParser::OPENDATASOURCE, 0);
}

tree::TerminalNode* tsqlParser::OpendatasourceContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::OpendatasourceContext::COMMA() {
  return getToken(tsqlParser::COMMA, 0);
}

tree::TerminalNode* tsqlParser::OpendatasourceContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::OpendatasourceContext::DOT() {
  return getTokens(tsqlParser::DOT);
}

tree::TerminalNode* tsqlParser::OpendatasourceContext::DOT(size_t i) {
  return getToken(tsqlParser::DOT, i);
}

std::vector<tree::TerminalNode *> tsqlParser::OpendatasourceContext::STRING() {
  return getTokens(tsqlParser::STRING);
}

tree::TerminalNode* tsqlParser::OpendatasourceContext::STRING(size_t i) {
  return getToken(tsqlParser::STRING, i);
}

std::vector<tsqlParser::R_idContext *> tsqlParser::OpendatasourceContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::OpendatasourceContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}


size_t tsqlParser::OpendatasourceContext::getRuleIndex() const {
  return tsqlParser::RuleOpendatasource;
}


antlrcpp::Any tsqlParser::OpendatasourceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOpendatasource(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::OpendatasourceContext* tsqlParser::opendatasource() {
  OpendatasourceContext *_localctx = _tracker.createInstance<OpendatasourceContext>(_ctx, getState());
  enterRule(_localctx, 152, tsqlParser::RuleOpendatasource);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1406);
    match(tsqlParser::OPENDATASOURCE);
    setState(1407);
    match(tsqlParser::LR_BRACKET);
    setState(1408);
    dynamic_cast<OpendatasourceContext *>(_localctx)->provider = match(tsqlParser::STRING);
    setState(1409);
    match(tsqlParser::COMMA);
    setState(1410);
    dynamic_cast<OpendatasourceContext *>(_localctx)->init = match(tsqlParser::STRING);
    setState(1411);
    match(tsqlParser::RR_BRACKET);
    setState(1412);
    match(tsqlParser::DOT);
    setState(1414);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & ((1ULL << (tsqlParser::FORCESEEK - 73))
      | (1ULL << (tsqlParser::NEXT - 73))
      | (1ULL << (tsqlParser::NUMERIC - 73)))) != 0) || ((((_la - 196) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 196)) & ((1ULL << (tsqlParser::VALUE - 196))
      | (1ULL << (tsqlParser::ABSOLUTE - 196))
      | (1ULL << (tsqlParser::APPLY - 196))
      | (1ULL << (tsqlParser::AUTO - 196))
      | (1ULL << (tsqlParser::AVG - 196))
      | (1ULL << (tsqlParser::BASE64 - 196))
      | (1ULL << (tsqlParser::CALLER - 196))
      | (1ULL << (tsqlParser::CAST - 196))
      | (1ULL << (tsqlParser::CATCH - 196))
      | (1ULL << (tsqlParser::CHECKSUM_AGG - 196))
      | (1ULL << (tsqlParser::COMMITTED - 196))
      | (1ULL << (tsqlParser::CONCAT - 196))
      | (1ULL << (tsqlParser::CONTROL - 196))
      | (1ULL << (tsqlParser::COOKIE - 196))
      | (1ULL << (tsqlParser::COUNT - 196))
      | (1ULL << (tsqlParser::COUNT_BIG - 196))
      | (1ULL << (tsqlParser::DATE - 196)))) != 0) || ((((_la - 261) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 261)) & ((1ULL << (tsqlParser::DELAY - 261))
      | (1ULL << (tsqlParser::DELETED - 261))
      | (1ULL << (tsqlParser::DENSE_RANK - 261))
      | (1ULL << (tsqlParser::DISABLE - 261))
      | (1ULL << (tsqlParser::DYNAMIC - 261))
      | (1ULL << (tsqlParser::ENCRYPTION - 261))
      | (1ULL << (tsqlParser::EXIST - 261))
      | (1ULL << (tsqlParser::EXPAND - 261))
      | (1ULL << (tsqlParser::FAST - 261))
      | (1ULL << (tsqlParser::FAST_FORWARD - 261))
      | (1ULL << (tsqlParser::FIRST - 261))
      | (1ULL << (tsqlParser::FIRST_VALUE - 261))
      | (1ULL << (tsqlParser::FOLLOWING - 261))
      | (1ULL << (tsqlParser::FORCE - 261))
      | (1ULL << (tsqlParser::FORCED - 261))
      | (1ULL << (tsqlParser::FORWARD_ONLY - 261))
      | (1ULL << (tsqlParser::FULLSCAN - 261))
      | (1ULL << (tsqlParser::GLOBAL - 261))
      | (1ULL << (tsqlParser::GROUPING - 261))
      | (1ULL << (tsqlParser::GROUPING_ID - 261))
      | (1ULL << (tsqlParser::HASH - 261))
      | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 261))
      | (1ULL << (tsqlParser::IMPERSONATE - 261))
      | (1ULL << (tsqlParser::INSENSITIVE - 261))
      | (1ULL << (tsqlParser::INSERTED - 261))
      | (1ULL << (tsqlParser::ISOLATION - 261))
      | (1ULL << (tsqlParser::IO - 261))
      | (1ULL << (tsqlParser::KEEP - 261))
      | (1ULL << (tsqlParser::KEEPFIXED - 261))
      | (1ULL << (tsqlParser::KEYSET - 261))
      | (1ULL << (tsqlParser::LAG - 261))
      | (1ULL << (tsqlParser::LAST - 261))
      | (1ULL << (tsqlParser::LAST_VALUE - 261))
      | (1ULL << (tsqlParser::LEAD - 261))
      | (1ULL << (tsqlParser::LEVEL - 261))
      | (1ULL << (tsqlParser::LOCAL - 261))
      | (1ULL << (tsqlParser::LOCK_ESCALATION - 261))
      | (1ULL << (tsqlParser::LOGIN - 261))
      | (1ULL << (tsqlParser::LOOP - 261))
      | (1ULL << (tsqlParser::MARK - 261))
      | (1ULL << (tsqlParser::MAX - 261))
      | (1ULL << (tsqlParser::MAXDOP - 261))
      | (1ULL << (tsqlParser::MAXRECURSION - 261)))) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 328)) & ((1ULL << (tsqlParser::MIN - 328))
      | (1ULL << (tsqlParser::MODIFY - 328))
      | (1ULL << (tsqlParser::NAME - 328))
      | (1ULL << (tsqlParser::NOCOUNT - 328))
      | (1ULL << (tsqlParser::NODES - 328))
      | (1ULL << (tsqlParser::NOEXPAND - 328))
      | (1ULL << (tsqlParser::NORECOMPUTE - 328))
      | (1ULL << (tsqlParser::NTILE - 328))
      | (1ULL << (tsqlParser::NUMBER - 328))
      | (1ULL << (tsqlParser::OFFSET - 328))
      | (1ULL << (tsqlParser::ONLINE - 328))
      | (1ULL << (tsqlParser::ONLY - 328))
      | (1ULL << (tsqlParser::OPTIMISTIC - 328))
      | (1ULL << (tsqlParser::OPTIMIZE - 328))
      | (1ULL << (tsqlParser::OUT - 328))
      | (1ULL << (tsqlParser::OUTPUT - 328))
      | (1ULL << (tsqlParser::OWNER - 328))
      | (1ULL << (tsqlParser::PARAMETERIZATION - 328))
      | (1ULL << (tsqlParser::PARTITION - 328))
      | (1ULL << (tsqlParser::PATH - 328))
      | (1ULL << (tsqlParser::PRECEDING - 328))
      | (1ULL << (tsqlParser::PRIOR - 328))
      | (1ULL << (tsqlParser::PRIVILEGES - 328))
      | (1ULL << (tsqlParser::QUERY - 328))
      | (1ULL << (tsqlParser::RANGE - 328))
      | (1ULL << (tsqlParser::RANK - 328))
      | (1ULL << (tsqlParser::READONLY - 328))
      | (1ULL << (tsqlParser::READ_ONLY - 328))
      | (1ULL << (tsqlParser::RECOMPILE - 328))
      | (1ULL << (tsqlParser::RELATIVE - 328))
      | (1ULL << (tsqlParser::REMOTE - 328))
      | (1ULL << (tsqlParser::REPEATABLE - 328))
      | (1ULL << (tsqlParser::ROBUST - 328))
      | (1ULL << (tsqlParser::ROOT - 328))
      | (1ULL << (tsqlParser::ROW - 328))
      | (1ULL << (tsqlParser::ROWGUID - 328))
      | (1ULL << (tsqlParser::ROWS - 328))
      | (1ULL << (tsqlParser::ROW_NUMBER - 328))
      | (1ULL << (tsqlParser::SAMPLE - 328))
      | (1ULL << (tsqlParser::SCHEMABINDING - 328))
      | (1ULL << (tsqlParser::SCROLL - 328))
      | (1ULL << (tsqlParser::SCROLL_LOCKS - 328)))) != 0) || ((((_la - 393) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 393)) & ((1ULL << (tsqlParser::SELF - 393))
      | (1ULL << (tsqlParser::SERIALIZABLE - 393))
      | (1ULL << (tsqlParser::SIMPLE - 393))
      | (1ULL << (tsqlParser::SIZE - 393))
      | (1ULL << (tsqlParser::SNAPSHOT - 393))
      | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 393))
      | (1ULL << (tsqlParser::STATIC - 393))
      | (1ULL << (tsqlParser::STATS_STREAM - 393))
      | (1ULL << (tsqlParser::STDEV - 393))
      | (1ULL << (tsqlParser::STDEVP - 393))
      | (1ULL << (tsqlParser::SUM - 393))
      | (1ULL << (tsqlParser::TEXTIMAGE_ON - 393))
      | (1ULL << (tsqlParser::THROW - 393))
      | (1ULL << (tsqlParser::TIES - 393))
      | (1ULL << (tsqlParser::TIME - 393))
      | (1ULL << (tsqlParser::TRY - 393))
      | (1ULL << (tsqlParser::TYPE - 393))
      | (1ULL << (tsqlParser::TYPE_WARNING - 393))
      | (1ULL << (tsqlParser::UNBOUNDED - 393))
      | (1ULL << (tsqlParser::UNCOMMITTED - 393))
      | (1ULL << (tsqlParser::UNKNOWN - 393))
      | (1ULL << (tsqlParser::USING - 393))
      | (1ULL << (tsqlParser::VAR - 393))
      | (1ULL << (tsqlParser::VARP - 393))
      | (1ULL << (tsqlParser::VIEWS - 393))
      | (1ULL << (tsqlParser::VIEW_METADATA - 393))
      | (1ULL << (tsqlParser::WORK - 393))
      | (1ULL << (tsqlParser::XML - 393))
      | (1ULL << (tsqlParser::XMLNAMESPACES - 393))
      | (1ULL << (tsqlParser::ZONE - 393))
      | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 393))
      | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 393))
      | (1ULL << (tsqlParser::ID - 393)))) != 0)) {
      setState(1413);
      dynamic_cast<OpendatasourceContext *>(_localctx)->database = r_id();
    }
    setState(1416);
    match(tsqlParser::DOT);
    setState(1418);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & ((1ULL << (tsqlParser::FORCESEEK - 73))
      | (1ULL << (tsqlParser::NEXT - 73))
      | (1ULL << (tsqlParser::NUMERIC - 73)))) != 0) || ((((_la - 196) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 196)) & ((1ULL << (tsqlParser::VALUE - 196))
      | (1ULL << (tsqlParser::ABSOLUTE - 196))
      | (1ULL << (tsqlParser::APPLY - 196))
      | (1ULL << (tsqlParser::AUTO - 196))
      | (1ULL << (tsqlParser::AVG - 196))
      | (1ULL << (tsqlParser::BASE64 - 196))
      | (1ULL << (tsqlParser::CALLER - 196))
      | (1ULL << (tsqlParser::CAST - 196))
      | (1ULL << (tsqlParser::CATCH - 196))
      | (1ULL << (tsqlParser::CHECKSUM_AGG - 196))
      | (1ULL << (tsqlParser::COMMITTED - 196))
      | (1ULL << (tsqlParser::CONCAT - 196))
      | (1ULL << (tsqlParser::CONTROL - 196))
      | (1ULL << (tsqlParser::COOKIE - 196))
      | (1ULL << (tsqlParser::COUNT - 196))
      | (1ULL << (tsqlParser::COUNT_BIG - 196))
      | (1ULL << (tsqlParser::DATE - 196)))) != 0) || ((((_la - 261) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 261)) & ((1ULL << (tsqlParser::DELAY - 261))
      | (1ULL << (tsqlParser::DELETED - 261))
      | (1ULL << (tsqlParser::DENSE_RANK - 261))
      | (1ULL << (tsqlParser::DISABLE - 261))
      | (1ULL << (tsqlParser::DYNAMIC - 261))
      | (1ULL << (tsqlParser::ENCRYPTION - 261))
      | (1ULL << (tsqlParser::EXIST - 261))
      | (1ULL << (tsqlParser::EXPAND - 261))
      | (1ULL << (tsqlParser::FAST - 261))
      | (1ULL << (tsqlParser::FAST_FORWARD - 261))
      | (1ULL << (tsqlParser::FIRST - 261))
      | (1ULL << (tsqlParser::FIRST_VALUE - 261))
      | (1ULL << (tsqlParser::FOLLOWING - 261))
      | (1ULL << (tsqlParser::FORCE - 261))
      | (1ULL << (tsqlParser::FORCED - 261))
      | (1ULL << (tsqlParser::FORWARD_ONLY - 261))
      | (1ULL << (tsqlParser::FULLSCAN - 261))
      | (1ULL << (tsqlParser::GLOBAL - 261))
      | (1ULL << (tsqlParser::GROUPING - 261))
      | (1ULL << (tsqlParser::GROUPING_ID - 261))
      | (1ULL << (tsqlParser::HASH - 261))
      | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 261))
      | (1ULL << (tsqlParser::IMPERSONATE - 261))
      | (1ULL << (tsqlParser::INSENSITIVE - 261))
      | (1ULL << (tsqlParser::INSERTED - 261))
      | (1ULL << (tsqlParser::ISOLATION - 261))
      | (1ULL << (tsqlParser::IO - 261))
      | (1ULL << (tsqlParser::KEEP - 261))
      | (1ULL << (tsqlParser::KEEPFIXED - 261))
      | (1ULL << (tsqlParser::KEYSET - 261))
      | (1ULL << (tsqlParser::LAG - 261))
      | (1ULL << (tsqlParser::LAST - 261))
      | (1ULL << (tsqlParser::LAST_VALUE - 261))
      | (1ULL << (tsqlParser::LEAD - 261))
      | (1ULL << (tsqlParser::LEVEL - 261))
      | (1ULL << (tsqlParser::LOCAL - 261))
      | (1ULL << (tsqlParser::LOCK_ESCALATION - 261))
      | (1ULL << (tsqlParser::LOGIN - 261))
      | (1ULL << (tsqlParser::LOOP - 261))
      | (1ULL << (tsqlParser::MARK - 261))
      | (1ULL << (tsqlParser::MAX - 261))
      | (1ULL << (tsqlParser::MAXDOP - 261))
      | (1ULL << (tsqlParser::MAXRECURSION - 261)))) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 328)) & ((1ULL << (tsqlParser::MIN - 328))
      | (1ULL << (tsqlParser::MODIFY - 328))
      | (1ULL << (tsqlParser::NAME - 328))
      | (1ULL << (tsqlParser::NOCOUNT - 328))
      | (1ULL << (tsqlParser::NODES - 328))
      | (1ULL << (tsqlParser::NOEXPAND - 328))
      | (1ULL << (tsqlParser::NORECOMPUTE - 328))
      | (1ULL << (tsqlParser::NTILE - 328))
      | (1ULL << (tsqlParser::NUMBER - 328))
      | (1ULL << (tsqlParser::OFFSET - 328))
      | (1ULL << (tsqlParser::ONLINE - 328))
      | (1ULL << (tsqlParser::ONLY - 328))
      | (1ULL << (tsqlParser::OPTIMISTIC - 328))
      | (1ULL << (tsqlParser::OPTIMIZE - 328))
      | (1ULL << (tsqlParser::OUT - 328))
      | (1ULL << (tsqlParser::OUTPUT - 328))
      | (1ULL << (tsqlParser::OWNER - 328))
      | (1ULL << (tsqlParser::PARAMETERIZATION - 328))
      | (1ULL << (tsqlParser::PARTITION - 328))
      | (1ULL << (tsqlParser::PATH - 328))
      | (1ULL << (tsqlParser::PRECEDING - 328))
      | (1ULL << (tsqlParser::PRIOR - 328))
      | (1ULL << (tsqlParser::PRIVILEGES - 328))
      | (1ULL << (tsqlParser::QUERY - 328))
      | (1ULL << (tsqlParser::RANGE - 328))
      | (1ULL << (tsqlParser::RANK - 328))
      | (1ULL << (tsqlParser::READONLY - 328))
      | (1ULL << (tsqlParser::READ_ONLY - 328))
      | (1ULL << (tsqlParser::RECOMPILE - 328))
      | (1ULL << (tsqlParser::RELATIVE - 328))
      | (1ULL << (tsqlParser::REMOTE - 328))
      | (1ULL << (tsqlParser::REPEATABLE - 328))
      | (1ULL << (tsqlParser::ROBUST - 328))
      | (1ULL << (tsqlParser::ROOT - 328))
      | (1ULL << (tsqlParser::ROW - 328))
      | (1ULL << (tsqlParser::ROWGUID - 328))
      | (1ULL << (tsqlParser::ROWS - 328))
      | (1ULL << (tsqlParser::ROW_NUMBER - 328))
      | (1ULL << (tsqlParser::SAMPLE - 328))
      | (1ULL << (tsqlParser::SCHEMABINDING - 328))
      | (1ULL << (tsqlParser::SCROLL - 328))
      | (1ULL << (tsqlParser::SCROLL_LOCKS - 328)))) != 0) || ((((_la - 393) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 393)) & ((1ULL << (tsqlParser::SELF - 393))
      | (1ULL << (tsqlParser::SERIALIZABLE - 393))
      | (1ULL << (tsqlParser::SIMPLE - 393))
      | (1ULL << (tsqlParser::SIZE - 393))
      | (1ULL << (tsqlParser::SNAPSHOT - 393))
      | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 393))
      | (1ULL << (tsqlParser::STATIC - 393))
      | (1ULL << (tsqlParser::STATS_STREAM - 393))
      | (1ULL << (tsqlParser::STDEV - 393))
      | (1ULL << (tsqlParser::STDEVP - 393))
      | (1ULL << (tsqlParser::SUM - 393))
      | (1ULL << (tsqlParser::TEXTIMAGE_ON - 393))
      | (1ULL << (tsqlParser::THROW - 393))
      | (1ULL << (tsqlParser::TIES - 393))
      | (1ULL << (tsqlParser::TIME - 393))
      | (1ULL << (tsqlParser::TRY - 393))
      | (1ULL << (tsqlParser::TYPE - 393))
      | (1ULL << (tsqlParser::TYPE_WARNING - 393))
      | (1ULL << (tsqlParser::UNBOUNDED - 393))
      | (1ULL << (tsqlParser::UNCOMMITTED - 393))
      | (1ULL << (tsqlParser::UNKNOWN - 393))
      | (1ULL << (tsqlParser::USING - 393))
      | (1ULL << (tsqlParser::VAR - 393))
      | (1ULL << (tsqlParser::VARP - 393))
      | (1ULL << (tsqlParser::VIEWS - 393))
      | (1ULL << (tsqlParser::VIEW_METADATA - 393))
      | (1ULL << (tsqlParser::WORK - 393))
      | (1ULL << (tsqlParser::XML - 393))
      | (1ULL << (tsqlParser::XMLNAMESPACES - 393))
      | (1ULL << (tsqlParser::ZONE - 393))
      | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 393))
      | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 393))
      | (1ULL << (tsqlParser::ID - 393)))) != 0)) {
      setState(1417);
      dynamic_cast<OpendatasourceContext *>(_localctx)->scheme = r_id();
    }
    setState(1420);
    match(tsqlParser::DOT);

    setState(1421);
    dynamic_cast<OpendatasourceContext *>(_localctx)->table = r_id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_statementContext ------------------------------------------------------------------

tsqlParser::Declare_statementContext::Declare_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Declare_statementContext::DECLARE() {
  return getToken(tsqlParser::DECLARE, 0);
}

tree::TerminalNode* tsqlParser::Declare_statementContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tsqlParser::Table_type_definitionContext* tsqlParser::Declare_statementContext::table_type_definition() {
  return getRuleContext<tsqlParser::Table_type_definitionContext>(0);
}

tree::TerminalNode* tsqlParser::Declare_statementContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

tree::TerminalNode* tsqlParser::Declare_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

std::vector<tsqlParser::Declare_localContext *> tsqlParser::Declare_statementContext::declare_local() {
  return getRuleContexts<tsqlParser::Declare_localContext>();
}

tsqlParser::Declare_localContext* tsqlParser::Declare_statementContext::declare_local(size_t i) {
  return getRuleContext<tsqlParser::Declare_localContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Declare_statementContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Declare_statementContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Declare_statementContext::getRuleIndex() const {
  return tsqlParser::RuleDeclare_statement;
}


antlrcpp::Any tsqlParser::Declare_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Declare_statementContext* tsqlParser::declare_statement() {
  Declare_statementContext *_localctx = _tracker.createInstance<Declare_statementContext>(_ctx, getState());
  enterRule(_localctx, 154, tsqlParser::RuleDeclare_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1444);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1423);
      match(tsqlParser::DECLARE);
      setState(1424);
      match(tsqlParser::LOCAL_ID);
      setState(1426);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::AS) {
        setState(1425);
        match(tsqlParser::AS);
      }
      setState(1428);
      table_type_definition();
      setState(1430);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx)) {
      case 1: {
        setState(1429);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1432);
      match(tsqlParser::DECLARE);
      setState(1433);
      declare_local();
      setState(1438);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(1434);
        match(tsqlParser::COMMA);
        setState(1435);
        declare_local();
        setState(1440);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1442);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
      case 1: {
        setState(1441);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_statementContext ------------------------------------------------------------------

tsqlParser::Cursor_statementContext::Cursor_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Cursor_statementContext::CLOSE() {
  return getToken(tsqlParser::CLOSE, 0);
}

tsqlParser::Cursor_nameContext* tsqlParser::Cursor_statementContext::cursor_name() {
  return getRuleContext<tsqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Cursor_statementContext::GLOBAL() {
  return getToken(tsqlParser::GLOBAL, 0);
}

tree::TerminalNode* tsqlParser::Cursor_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tree::TerminalNode* tsqlParser::Cursor_statementContext::DEALLOCATE() {
  return getToken(tsqlParser::DEALLOCATE, 0);
}

tsqlParser::Declare_cursorContext* tsqlParser::Cursor_statementContext::declare_cursor() {
  return getRuleContext<tsqlParser::Declare_cursorContext>(0);
}

tsqlParser::Fetch_cursorContext* tsqlParser::Cursor_statementContext::fetch_cursor() {
  return getRuleContext<tsqlParser::Fetch_cursorContext>(0);
}

tree::TerminalNode* tsqlParser::Cursor_statementContext::OPEN() {
  return getToken(tsqlParser::OPEN, 0);
}


size_t tsqlParser::Cursor_statementContext::getRuleIndex() const {
  return tsqlParser::RuleCursor_statement;
}


antlrcpp::Any tsqlParser::Cursor_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCursor_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Cursor_statementContext* tsqlParser::cursor_statement() {
  Cursor_statementContext *_localctx = _tracker.createInstance<Cursor_statementContext>(_ctx, getState());
  enterRule(_localctx, 156, tsqlParser::RuleCursor_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1472);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::CLOSE: {
        enterOuterAlt(_localctx, 1);
        setState(1446);
        match(tsqlParser::CLOSE);
        setState(1448);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx)) {
        case 1: {
          setState(1447);
          match(tsqlParser::GLOBAL);
          break;
        }

        default:
          break;
        }
        setState(1450);
        cursor_name();
        setState(1452);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
        case 1: {
          setState(1451);
          match(tsqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

      case tsqlParser::DEALLOCATE: {
        enterOuterAlt(_localctx, 2);
        setState(1454);
        match(tsqlParser::DEALLOCATE);
        setState(1456);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx)) {
        case 1: {
          setState(1455);
          match(tsqlParser::GLOBAL);
          break;
        }

        default:
          break;
        }
        setState(1458);
        cursor_name();
        setState(1460);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx)) {
        case 1: {
          setState(1459);
          match(tsqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

      case tsqlParser::DECLARE: {
        enterOuterAlt(_localctx, 3);
        setState(1462);
        declare_cursor();
        break;
      }

      case tsqlParser::FETCH: {
        enterOuterAlt(_localctx, 4);
        setState(1463);
        fetch_cursor();
        break;
      }

      case tsqlParser::OPEN: {
        enterOuterAlt(_localctx, 5);
        setState(1464);
        match(tsqlParser::OPEN);
        setState(1466);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
        case 1: {
          setState(1465);
          match(tsqlParser::GLOBAL);
          break;
        }

        default:
          break;
        }
        setState(1468);
        cursor_name();
        setState(1470);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
        case 1: {
          setState(1469);
          match(tsqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_statementContext ------------------------------------------------------------------

tsqlParser::Execute_statementContext::Execute_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Execute_statementContext::EXECUTE() {
  return getToken(tsqlParser::EXECUTE, 0);
}

tsqlParser::Func_proc_nameContext* tsqlParser::Execute_statementContext::func_proc_name() {
  return getRuleContext<tsqlParser::Func_proc_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Execute_statementContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

std::vector<tsqlParser::Execute_statement_argContext *> tsqlParser::Execute_statementContext::execute_statement_arg() {
  return getRuleContexts<tsqlParser::Execute_statement_argContext>();
}

tsqlParser::Execute_statement_argContext* tsqlParser::Execute_statementContext::execute_statement_arg(size_t i) {
  return getRuleContext<tsqlParser::Execute_statement_argContext>(i);
}

tree::TerminalNode* tsqlParser::Execute_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tree::TerminalNode* tsqlParser::Execute_statementContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Execute_statementContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Execute_statementContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::Execute_statementContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

std::vector<tsqlParser::Execute_var_stringContext *> tsqlParser::Execute_statementContext::execute_var_string() {
  return getRuleContexts<tsqlParser::Execute_var_stringContext>();
}

tsqlParser::Execute_var_stringContext* tsqlParser::Execute_statementContext::execute_var_string(size_t i) {
  return getRuleContext<tsqlParser::Execute_var_stringContext>(i);
}

tree::TerminalNode* tsqlParser::Execute_statementContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Execute_statementContext::PLUS() {
  return getTokens(tsqlParser::PLUS);
}

tree::TerminalNode* tsqlParser::Execute_statementContext::PLUS(size_t i) {
  return getToken(tsqlParser::PLUS, i);
}

tree::TerminalNode* tsqlParser::Execute_statementContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}

tree::TerminalNode* tsqlParser::Execute_statementContext::LOGIN() {
  return getToken(tsqlParser::LOGIN, 0);
}

tree::TerminalNode* tsqlParser::Execute_statementContext::USER() {
  return getToken(tsqlParser::USER, 0);
}

tree::TerminalNode* tsqlParser::Execute_statementContext::AS() {
  return getToken(tsqlParser::AS, 0);
}


size_t tsqlParser::Execute_statementContext::getRuleIndex() const {
  return tsqlParser::RuleExecute_statement;
}


antlrcpp::Any tsqlParser::Execute_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitExecute_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Execute_statementContext* tsqlParser::execute_statement() {
  Execute_statementContext *_localctx = _tracker.createInstance<Execute_statementContext>(_ctx, getState());
  enterRule(_localctx, 158, tsqlParser::RuleExecute_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1515);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 192, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1474);
      match(tsqlParser::EXECUTE);
      setState(1477);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::LOCAL_ID) {
        setState(1475);
        dynamic_cast<Execute_statementContext *>(_localctx)->return_status = match(tsqlParser::LOCAL_ID);
        setState(1476);
        match(tsqlParser::EQUAL);
      }
      setState(1479);
      func_proc_name();
      setState(1488);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx)) {
      case 1: {
        setState(1480);
        execute_statement_arg();
        setState(1485);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == tsqlParser::COMMA) {
          setState(1481);
          match(tsqlParser::COMMA);
          setState(1482);
          execute_statement_arg();
          setState(1487);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
      }
      setState(1491);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 187, _ctx)) {
      case 1: {
        setState(1490);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1493);
      match(tsqlParser::EXECUTE);
      setState(1494);
      match(tsqlParser::LR_BRACKET);
      setState(1495);
      execute_var_string();
      setState(1500);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::PLUS) {
        setState(1496);
        match(tsqlParser::PLUS);
        setState(1497);
        execute_var_string();
        setState(1502);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1503);
      match(tsqlParser::RR_BRACKET);
      setState(1510);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx)) {
      case 1: {
        setState(1505);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::AS) {
          setState(1504);
          match(tsqlParser::AS);
        }
        setState(1507);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::USER || _la == tsqlParser::LOGIN)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1508);
        match(tsqlParser::EQUAL);
        setState(1509);
        match(tsqlParser::STRING);
        break;
      }

      default:
        break;
      }
      setState(1513);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx)) {
      case 1: {
        setState(1512);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_statement_argContext ------------------------------------------------------------------

tsqlParser::Execute_statement_argContext::Execute_statement_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Execute_statement_argContext::DEFAULT() {
  return getToken(tsqlParser::DEFAULT, 0);
}

tree::TerminalNode* tsqlParser::Execute_statement_argContext::NULL_() {
  return getToken(tsqlParser::NULL_, 0);
}

tree::TerminalNode* tsqlParser::Execute_statement_argContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Execute_statement_argContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tsqlParser::Constant_LOCAL_IDContext* tsqlParser::Execute_statement_argContext::constant_LOCAL_ID() {
  return getRuleContext<tsqlParser::Constant_LOCAL_IDContext>(0);
}

tsqlParser::R_idContext* tsqlParser::Execute_statement_argContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Execute_statement_argContext::OUTPUT() {
  return getToken(tsqlParser::OUTPUT, 0);
}

tree::TerminalNode* tsqlParser::Execute_statement_argContext::OUT() {
  return getToken(tsqlParser::OUT, 0);
}


size_t tsqlParser::Execute_statement_argContext::getRuleIndex() const {
  return tsqlParser::RuleExecute_statement_arg;
}


antlrcpp::Any tsqlParser::Execute_statement_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitExecute_statement_arg(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Execute_statement_argContext* tsqlParser::execute_statement_arg() {
  Execute_statement_argContext *_localctx = _tracker.createInstance<Execute_statement_argContext>(_ctx, getState());
  enterRule(_localctx, 160, tsqlParser::RuleExecute_statement_arg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1519);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
    case 1: {
      setState(1517);
      dynamic_cast<Execute_statement_argContext *>(_localctx)->parameter = match(tsqlParser::LOCAL_ID);
      setState(1518);
      match(tsqlParser::EQUAL);
      break;
    }

    default:
      break;
    }
    setState(1530);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::LOCAL_ID:
      case tsqlParser::DECIMAL:
      case tsqlParser::ID:
      case tsqlParser::STRING:
      case tsqlParser::BINARY:
      case tsqlParser::FLOAT:
      case tsqlParser::REAL:
      case tsqlParser::DOLLAR:
      case tsqlParser::PLUS:
      case tsqlParser::MINUS: {
        setState(1523);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::LOCAL_ID:
          case tsqlParser::DECIMAL:
          case tsqlParser::STRING:
          case tsqlParser::BINARY:
          case tsqlParser::FLOAT:
          case tsqlParser::REAL:
          case tsqlParser::DOLLAR:
          case tsqlParser::PLUS:
          case tsqlParser::MINUS: {
            setState(1521);
            constant_LOCAL_ID();
            break;
          }

          case tsqlParser::FORCESEEK:
          case tsqlParser::NEXT:
          case tsqlParser::NUMERIC:
          case tsqlParser::VALUE:
          case tsqlParser::ABSOLUTE:
          case tsqlParser::APPLY:
          case tsqlParser::AUTO:
          case tsqlParser::AVG:
          case tsqlParser::BASE64:
          case tsqlParser::CALLER:
          case tsqlParser::CAST:
          case tsqlParser::CATCH:
          case tsqlParser::CHECKSUM_AGG:
          case tsqlParser::COMMITTED:
          case tsqlParser::CONCAT:
          case tsqlParser::CONTROL:
          case tsqlParser::COOKIE:
          case tsqlParser::COUNT:
          case tsqlParser::COUNT_BIG:
          case tsqlParser::DATE:
          case tsqlParser::DELAY:
          case tsqlParser::DELETED:
          case tsqlParser::DENSE_RANK:
          case tsqlParser::DISABLE:
          case tsqlParser::DYNAMIC:
          case tsqlParser::ENCRYPTION:
          case tsqlParser::EXIST:
          case tsqlParser::EXPAND:
          case tsqlParser::FAST:
          case tsqlParser::FAST_FORWARD:
          case tsqlParser::FIRST:
          case tsqlParser::FIRST_VALUE:
          case tsqlParser::FOLLOWING:
          case tsqlParser::FORCE:
          case tsqlParser::FORCED:
          case tsqlParser::FORWARD_ONLY:
          case tsqlParser::FULLSCAN:
          case tsqlParser::GLOBAL:
          case tsqlParser::GROUPING:
          case tsqlParser::GROUPING_ID:
          case tsqlParser::HASH:
          case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case tsqlParser::IMPERSONATE:
          case tsqlParser::INSENSITIVE:
          case tsqlParser::INSERTED:
          case tsqlParser::ISOLATION:
          case tsqlParser::IO:
          case tsqlParser::KEEP:
          case tsqlParser::KEEPFIXED:
          case tsqlParser::KEYSET:
          case tsqlParser::LAG:
          case tsqlParser::LAST:
          case tsqlParser::LAST_VALUE:
          case tsqlParser::LEAD:
          case tsqlParser::LEVEL:
          case tsqlParser::LOCAL:
          case tsqlParser::LOCK_ESCALATION:
          case tsqlParser::LOGIN:
          case tsqlParser::LOOP:
          case tsqlParser::MARK:
          case tsqlParser::MAX:
          case tsqlParser::MAXDOP:
          case tsqlParser::MAXRECURSION:
          case tsqlParser::MIN:
          case tsqlParser::MODIFY:
          case tsqlParser::NAME:
          case tsqlParser::NOCOUNT:
          case tsqlParser::NODES:
          case tsqlParser::NOEXPAND:
          case tsqlParser::NORECOMPUTE:
          case tsqlParser::NTILE:
          case tsqlParser::NUMBER:
          case tsqlParser::OFFSET:
          case tsqlParser::ONLINE:
          case tsqlParser::ONLY:
          case tsqlParser::OPTIMISTIC:
          case tsqlParser::OPTIMIZE:
          case tsqlParser::OUT:
          case tsqlParser::OUTPUT:
          case tsqlParser::OWNER:
          case tsqlParser::PARAMETERIZATION:
          case tsqlParser::PARTITION:
          case tsqlParser::PATH:
          case tsqlParser::PRECEDING:
          case tsqlParser::PRIOR:
          case tsqlParser::PRIVILEGES:
          case tsqlParser::QUERY:
          case tsqlParser::RANGE:
          case tsqlParser::RANK:
          case tsqlParser::READONLY:
          case tsqlParser::READ_ONLY:
          case tsqlParser::RECOMPILE:
          case tsqlParser::RELATIVE:
          case tsqlParser::REMOTE:
          case tsqlParser::REPEATABLE:
          case tsqlParser::ROBUST:
          case tsqlParser::ROOT:
          case tsqlParser::ROW:
          case tsqlParser::ROWGUID:
          case tsqlParser::ROWS:
          case tsqlParser::ROW_NUMBER:
          case tsqlParser::SAMPLE:
          case tsqlParser::SCHEMABINDING:
          case tsqlParser::SCROLL:
          case tsqlParser::SCROLL_LOCKS:
          case tsqlParser::SELF:
          case tsqlParser::SERIALIZABLE:
          case tsqlParser::SIMPLE:
          case tsqlParser::SIZE:
          case tsqlParser::SNAPSHOT:
          case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case tsqlParser::STATIC:
          case tsqlParser::STATS_STREAM:
          case tsqlParser::STDEV:
          case tsqlParser::STDEVP:
          case tsqlParser::SUM:
          case tsqlParser::TEXTIMAGE_ON:
          case tsqlParser::THROW:
          case tsqlParser::TIES:
          case tsqlParser::TIME:
          case tsqlParser::TRY:
          case tsqlParser::TYPE:
          case tsqlParser::TYPE_WARNING:
          case tsqlParser::UNBOUNDED:
          case tsqlParser::UNCOMMITTED:
          case tsqlParser::UNKNOWN:
          case tsqlParser::USING:
          case tsqlParser::VAR:
          case tsqlParser::VARP:
          case tsqlParser::VIEWS:
          case tsqlParser::VIEW_METADATA:
          case tsqlParser::WORK:
          case tsqlParser::XML:
          case tsqlParser::XMLNAMESPACES:
          case tsqlParser::ZONE:
          case tsqlParser::DOUBLE_QUOTE_ID:
          case tsqlParser::SQUARE_BRACKET_ID:
          case tsqlParser::ID: {
            setState(1522);
            r_id();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1526);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
        case 1: {
          setState(1525);
          _la = _input->LA(1);
          if (!(_la == tsqlParser::OUT

          || _la == tsqlParser::OUTPUT)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case tsqlParser::DEFAULT: {
        setState(1528);
        match(tsqlParser::DEFAULT);
        break;
      }

      case tsqlParser::NULL_: {
        setState(1529);
        match(tsqlParser::NULL_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_var_stringContext ------------------------------------------------------------------

tsqlParser::Execute_var_stringContext::Execute_var_stringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Execute_var_stringContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* tsqlParser::Execute_var_stringContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}


size_t tsqlParser::Execute_var_stringContext::getRuleIndex() const {
  return tsqlParser::RuleExecute_var_string;
}


antlrcpp::Any tsqlParser::Execute_var_stringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitExecute_var_string(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Execute_var_stringContext* tsqlParser::execute_var_string() {
  Execute_var_stringContext *_localctx = _tracker.createInstance<Execute_var_stringContext>(_ctx, getState());
  enterRule(_localctx, 162, tsqlParser::RuleExecute_var_string);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1532);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::LOCAL_ID

    || _la == tsqlParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Security_statementContext ------------------------------------------------------------------

tsqlParser::Security_statementContext::Security_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Execute_clauseContext* tsqlParser::Security_statementContext::execute_clause() {
  return getRuleContext<tsqlParser::Execute_clauseContext>(0);
}

tree::TerminalNode* tsqlParser::Security_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Security_statementContext::GRANT() {
  return getTokens(tsqlParser::GRANT);
}

tree::TerminalNode* tsqlParser::Security_statementContext::GRANT(size_t i) {
  return getToken(tsqlParser::GRANT, i);
}

tree::TerminalNode* tsqlParser::Security_statementContext::TO() {
  return getToken(tsqlParser::TO, 0);
}

tree::TerminalNode* tsqlParser::Security_statementContext::ALL() {
  return getToken(tsqlParser::ALL, 0);
}

tsqlParser::Grant_permissionContext* tsqlParser::Security_statementContext::grant_permission() {
  return getRuleContext<tsqlParser::Grant_permissionContext>(0);
}

tree::TerminalNode* tsqlParser::Security_statementContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Security_statementContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Security_statementContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

tree::TerminalNode* tsqlParser::Security_statementContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

tree::TerminalNode* tsqlParser::Security_statementContext::OPTION() {
  return getToken(tsqlParser::OPTION, 0);
}

tree::TerminalNode* tsqlParser::Security_statementContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Security_statementContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Security_statementContext::PRIVILEGES() {
  return getToken(tsqlParser::PRIVILEGES, 0);
}

tree::TerminalNode* tsqlParser::Security_statementContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Column_name_listContext* tsqlParser::Security_statementContext::column_name_list() {
  return getRuleContext<tsqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* tsqlParser::Security_statementContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Security_statementContext::REVERT() {
  return getToken(tsqlParser::REVERT, 0);
}

tree::TerminalNode* tsqlParser::Security_statementContext::COOKIE() {
  return getToken(tsqlParser::COOKIE, 0);
}

tree::TerminalNode* tsqlParser::Security_statementContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Security_statementContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}


size_t tsqlParser::Security_statementContext::getRuleIndex() const {
  return tsqlParser::RuleSecurity_statement;
}


antlrcpp::Any tsqlParser::Security_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSecurity_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Security_statementContext* tsqlParser::security_statement() {
  Security_statementContext *_localctx = _tracker.createInstance<Security_statementContext>(_ctx, getState());
  enterRule(_localctx, 164, tsqlParser::RuleSecurity_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1582);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::EXECUTE: {
        enterOuterAlt(_localctx, 1);
        setState(1534);
        execute_clause();
        setState(1536);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {
        case 1: {
          setState(1535);
          match(tsqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

      case tsqlParser::GRANT: {
        enterOuterAlt(_localctx, 2);
        setState(1538);
        match(tsqlParser::GRANT);
        setState(1550);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::ALL: {
            setState(1539);
            match(tsqlParser::ALL);
            setState(1541);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == tsqlParser::PRIVILEGES) {
              setState(1540);
              match(tsqlParser::PRIVILEGES);
            }
            break;
          }

          case tsqlParser::ALTER:
          case tsqlParser::CREATE:
          case tsqlParser::EXECUTE:
          case tsqlParser::INSERT:
          case tsqlParser::REFERENCES:
          case tsqlParser::SELECT:
          case tsqlParser::VIEW:
          case tsqlParser::CONTROL:
          case tsqlParser::IMPERSONATE:
          case tsqlParser::SHOWPLAN:
          case tsqlParser::TAKE: {
            setState(1543);
            grant_permission();
            setState(1548);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == tsqlParser::LR_BRACKET) {
              setState(1544);
              match(tsqlParser::LR_BRACKET);
              setState(1545);
              column_name_list();
              setState(1546);
              match(tsqlParser::RR_BRACKET);
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1554);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::ON) {
          setState(1552);
          match(tsqlParser::ON);
          setState(1553);
          dynamic_cast<Security_statementContext *>(_localctx)->on_id = table_name();
        }
        setState(1556);
        match(tsqlParser::TO);

        setState(1557);
        dynamic_cast<Security_statementContext *>(_localctx)->to_principal = r_id();
        setState(1561);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 202, _ctx)) {
        case 1: {
          setState(1558);
          match(tsqlParser::WITH);
          setState(1559);
          match(tsqlParser::GRANT);
          setState(1560);
          match(tsqlParser::OPTION);
          break;
        }

        default:
          break;
        }
        setState(1565);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::AS) {
          setState(1563);
          match(tsqlParser::AS);
          setState(1564);
          dynamic_cast<Security_statementContext *>(_localctx)->as_principal = r_id();
        }
        setState(1568);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
        case 1: {
          setState(1567);
          match(tsqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

      case tsqlParser::REVERT: {
        enterOuterAlt(_localctx, 3);
        setState(1570);
        match(tsqlParser::REVERT);
        setState(1577);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx)) {
        case 1: {
          setState(1571);
          match(tsqlParser::LR_BRACKET);
          setState(1572);
          match(tsqlParser::WITH);
          setState(1573);
          match(tsqlParser::COOKIE);
          setState(1574);
          match(tsqlParser::EQUAL);
          setState(1575);
          match(tsqlParser::LOCAL_ID);
          setState(1576);
          match(tsqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        }
        setState(1580);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx)) {
        case 1: {
          setState(1579);
          match(tsqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Grant_permissionContext ------------------------------------------------------------------

tsqlParser::Grant_permissionContext::Grant_permissionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::EXECUTE() {
  return getToken(tsqlParser::EXECUTE, 0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::VIEW() {
  return getToken(tsqlParser::VIEW, 0);
}

tsqlParser::R_idContext* tsqlParser::Grant_permissionContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::TAKE() {
  return getToken(tsqlParser::TAKE, 0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::CONTROL() {
  return getToken(tsqlParser::CONTROL, 0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::CREATE() {
  return getToken(tsqlParser::CREATE, 0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::TABLE() {
  return getToken(tsqlParser::TABLE, 0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::SHOWPLAN() {
  return getToken(tsqlParser::SHOWPLAN, 0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::IMPERSONATE() {
  return getToken(tsqlParser::IMPERSONATE, 0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::SELECT() {
  return getToken(tsqlParser::SELECT, 0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::REFERENCES() {
  return getToken(tsqlParser::REFERENCES, 0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::INSERT() {
  return getToken(tsqlParser::INSERT, 0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::ALTER() {
  return getToken(tsqlParser::ALTER, 0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::DATABASE() {
  return getToken(tsqlParser::DATABASE, 0);
}

tree::TerminalNode* tsqlParser::Grant_permissionContext::ANY() {
  return getToken(tsqlParser::ANY, 0);
}


size_t tsqlParser::Grant_permissionContext::getRuleIndex() const {
  return tsqlParser::RuleGrant_permission;
}


antlrcpp::Any tsqlParser::Grant_permissionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitGrant_permission(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Grant_permissionContext* tsqlParser::grant_permission() {
  Grant_permissionContext *_localctx = _tracker.createInstance<Grant_permissionContext>(_ctx, getState());
  enterRule(_localctx, 166, tsqlParser::RuleGrant_permission);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1610);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::EXECUTE: {
        enterOuterAlt(_localctx, 1);
        setState(1584);
        match(tsqlParser::EXECUTE);
        break;
      }

      case tsqlParser::VIEW: {
        enterOuterAlt(_localctx, 2);
        setState(1585);
        match(tsqlParser::VIEW);
        setState(1586);
        r_id();
        break;
      }

      case tsqlParser::TAKE: {
        enterOuterAlt(_localctx, 3);
        setState(1587);
        match(tsqlParser::TAKE);
        setState(1588);
        r_id();
        break;
      }

      case tsqlParser::CONTROL: {
        enterOuterAlt(_localctx, 4);
        setState(1589);
        match(tsqlParser::CONTROL);
        setState(1591);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & ((1ULL << (tsqlParser::FORCESEEK - 73))
          | (1ULL << (tsqlParser::NEXT - 73))
          | (1ULL << (tsqlParser::NUMERIC - 73)))) != 0) || ((((_la - 196) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 196)) & ((1ULL << (tsqlParser::VALUE - 196))
          | (1ULL << (tsqlParser::ABSOLUTE - 196))
          | (1ULL << (tsqlParser::APPLY - 196))
          | (1ULL << (tsqlParser::AUTO - 196))
          | (1ULL << (tsqlParser::AVG - 196))
          | (1ULL << (tsqlParser::BASE64 - 196))
          | (1ULL << (tsqlParser::CALLER - 196))
          | (1ULL << (tsqlParser::CAST - 196))
          | (1ULL << (tsqlParser::CATCH - 196))
          | (1ULL << (tsqlParser::CHECKSUM_AGG - 196))
          | (1ULL << (tsqlParser::COMMITTED - 196))
          | (1ULL << (tsqlParser::CONCAT - 196))
          | (1ULL << (tsqlParser::CONTROL - 196))
          | (1ULL << (tsqlParser::COOKIE - 196))
          | (1ULL << (tsqlParser::COUNT - 196))
          | (1ULL << (tsqlParser::COUNT_BIG - 196))
          | (1ULL << (tsqlParser::DATE - 196)))) != 0) || ((((_la - 261) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 261)) & ((1ULL << (tsqlParser::DELAY - 261))
          | (1ULL << (tsqlParser::DELETED - 261))
          | (1ULL << (tsqlParser::DENSE_RANK - 261))
          | (1ULL << (tsqlParser::DISABLE - 261))
          | (1ULL << (tsqlParser::DYNAMIC - 261))
          | (1ULL << (tsqlParser::ENCRYPTION - 261))
          | (1ULL << (tsqlParser::EXIST - 261))
          | (1ULL << (tsqlParser::EXPAND - 261))
          | (1ULL << (tsqlParser::FAST - 261))
          | (1ULL << (tsqlParser::FAST_FORWARD - 261))
          | (1ULL << (tsqlParser::FIRST - 261))
          | (1ULL << (tsqlParser::FIRST_VALUE - 261))
          | (1ULL << (tsqlParser::FOLLOWING - 261))
          | (1ULL << (tsqlParser::FORCE - 261))
          | (1ULL << (tsqlParser::FORCED - 261))
          | (1ULL << (tsqlParser::FORWARD_ONLY - 261))
          | (1ULL << (tsqlParser::FULLSCAN - 261))
          | (1ULL << (tsqlParser::GLOBAL - 261))
          | (1ULL << (tsqlParser::GROUPING - 261))
          | (1ULL << (tsqlParser::GROUPING_ID - 261))
          | (1ULL << (tsqlParser::HASH - 261))
          | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 261))
          | (1ULL << (tsqlParser::IMPERSONATE - 261))
          | (1ULL << (tsqlParser::INSENSITIVE - 261))
          | (1ULL << (tsqlParser::INSERTED - 261))
          | (1ULL << (tsqlParser::ISOLATION - 261))
          | (1ULL << (tsqlParser::IO - 261))
          | (1ULL << (tsqlParser::KEEP - 261))
          | (1ULL << (tsqlParser::KEEPFIXED - 261))
          | (1ULL << (tsqlParser::KEYSET - 261))
          | (1ULL << (tsqlParser::LAG - 261))
          | (1ULL << (tsqlParser::LAST - 261))
          | (1ULL << (tsqlParser::LAST_VALUE - 261))
          | (1ULL << (tsqlParser::LEAD - 261))
          | (1ULL << (tsqlParser::LEVEL - 261))
          | (1ULL << (tsqlParser::LOCAL - 261))
          | (1ULL << (tsqlParser::LOCK_ESCALATION - 261))
          | (1ULL << (tsqlParser::LOGIN - 261))
          | (1ULL << (tsqlParser::LOOP - 261))
          | (1ULL << (tsqlParser::MARK - 261))
          | (1ULL << (tsqlParser::MAX - 261))
          | (1ULL << (tsqlParser::MAXDOP - 261))
          | (1ULL << (tsqlParser::MAXRECURSION - 261)))) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 328)) & ((1ULL << (tsqlParser::MIN - 328))
          | (1ULL << (tsqlParser::MODIFY - 328))
          | (1ULL << (tsqlParser::NAME - 328))
          | (1ULL << (tsqlParser::NOCOUNT - 328))
          | (1ULL << (tsqlParser::NODES - 328))
          | (1ULL << (tsqlParser::NOEXPAND - 328))
          | (1ULL << (tsqlParser::NORECOMPUTE - 328))
          | (1ULL << (tsqlParser::NTILE - 328))
          | (1ULL << (tsqlParser::NUMBER - 328))
          | (1ULL << (tsqlParser::OFFSET - 328))
          | (1ULL << (tsqlParser::ONLINE - 328))
          | (1ULL << (tsqlParser::ONLY - 328))
          | (1ULL << (tsqlParser::OPTIMISTIC - 328))
          | (1ULL << (tsqlParser::OPTIMIZE - 328))
          | (1ULL << (tsqlParser::OUT - 328))
          | (1ULL << (tsqlParser::OUTPUT - 328))
          | (1ULL << (tsqlParser::OWNER - 328))
          | (1ULL << (tsqlParser::PARAMETERIZATION - 328))
          | (1ULL << (tsqlParser::PARTITION - 328))
          | (1ULL << (tsqlParser::PATH - 328))
          | (1ULL << (tsqlParser::PRECEDING - 328))
          | (1ULL << (tsqlParser::PRIOR - 328))
          | (1ULL << (tsqlParser::PRIVILEGES - 328))
          | (1ULL << (tsqlParser::QUERY - 328))
          | (1ULL << (tsqlParser::RANGE - 328))
          | (1ULL << (tsqlParser::RANK - 328))
          | (1ULL << (tsqlParser::READONLY - 328))
          | (1ULL << (tsqlParser::READ_ONLY - 328))
          | (1ULL << (tsqlParser::RECOMPILE - 328))
          | (1ULL << (tsqlParser::RELATIVE - 328))
          | (1ULL << (tsqlParser::REMOTE - 328))
          | (1ULL << (tsqlParser::REPEATABLE - 328))
          | (1ULL << (tsqlParser::ROBUST - 328))
          | (1ULL << (tsqlParser::ROOT - 328))
          | (1ULL << (tsqlParser::ROW - 328))
          | (1ULL << (tsqlParser::ROWGUID - 328))
          | (1ULL << (tsqlParser::ROWS - 328))
          | (1ULL << (tsqlParser::ROW_NUMBER - 328))
          | (1ULL << (tsqlParser::SAMPLE - 328))
          | (1ULL << (tsqlParser::SCHEMABINDING - 328))
          | (1ULL << (tsqlParser::SCROLL - 328))
          | (1ULL << (tsqlParser::SCROLL_LOCKS - 328)))) != 0) || ((((_la - 393) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 393)) & ((1ULL << (tsqlParser::SELF - 393))
          | (1ULL << (tsqlParser::SERIALIZABLE - 393))
          | (1ULL << (tsqlParser::SIMPLE - 393))
          | (1ULL << (tsqlParser::SIZE - 393))
          | (1ULL << (tsqlParser::SNAPSHOT - 393))
          | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 393))
          | (1ULL << (tsqlParser::STATIC - 393))
          | (1ULL << (tsqlParser::STATS_STREAM - 393))
          | (1ULL << (tsqlParser::STDEV - 393))
          | (1ULL << (tsqlParser::STDEVP - 393))
          | (1ULL << (tsqlParser::SUM - 393))
          | (1ULL << (tsqlParser::TEXTIMAGE_ON - 393))
          | (1ULL << (tsqlParser::THROW - 393))
          | (1ULL << (tsqlParser::TIES - 393))
          | (1ULL << (tsqlParser::TIME - 393))
          | (1ULL << (tsqlParser::TRY - 393))
          | (1ULL << (tsqlParser::TYPE - 393))
          | (1ULL << (tsqlParser::TYPE_WARNING - 393))
          | (1ULL << (tsqlParser::UNBOUNDED - 393))
          | (1ULL << (tsqlParser::UNCOMMITTED - 393))
          | (1ULL << (tsqlParser::UNKNOWN - 393))
          | (1ULL << (tsqlParser::USING - 393))
          | (1ULL << (tsqlParser::VAR - 393))
          | (1ULL << (tsqlParser::VARP - 393))
          | (1ULL << (tsqlParser::VIEWS - 393))
          | (1ULL << (tsqlParser::VIEW_METADATA - 393))
          | (1ULL << (tsqlParser::WORK - 393))
          | (1ULL << (tsqlParser::XML - 393))
          | (1ULL << (tsqlParser::XMLNAMESPACES - 393))
          | (1ULL << (tsqlParser::ZONE - 393))
          | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 393))
          | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 393))
          | (1ULL << (tsqlParser::ID - 393)))) != 0)) {
          setState(1590);
          r_id();
        }
        break;
      }

      case tsqlParser::CREATE: {
        enterOuterAlt(_localctx, 5);
        setState(1593);
        match(tsqlParser::CREATE);
        setState(1594);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::TABLE

        || _la == tsqlParser::VIEW)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case tsqlParser::SHOWPLAN: {
        enterOuterAlt(_localctx, 6);
        setState(1595);
        match(tsqlParser::SHOWPLAN);
        break;
      }

      case tsqlParser::IMPERSONATE: {
        enterOuterAlt(_localctx, 7);
        setState(1596);
        match(tsqlParser::IMPERSONATE);
        break;
      }

      case tsqlParser::SELECT: {
        enterOuterAlt(_localctx, 8);
        setState(1597);
        match(tsqlParser::SELECT);
        break;
      }

      case tsqlParser::REFERENCES: {
        enterOuterAlt(_localctx, 9);
        setState(1598);
        match(tsqlParser::REFERENCES);
        break;
      }

      case tsqlParser::INSERT: {
        enterOuterAlt(_localctx, 10);
        setState(1599);
        match(tsqlParser::INSERT);
        break;
      }

      case tsqlParser::ALTER: {
        enterOuterAlt(_localctx, 11);
        setState(1600);
        match(tsqlParser::ALTER);
        setState(1608);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::ANY

        || _la == tsqlParser::DATABASE || ((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & ((1ULL << (tsqlParser::FORCESEEK - 73))
          | (1ULL << (tsqlParser::NEXT - 73))
          | (1ULL << (tsqlParser::NUMERIC - 73)))) != 0) || ((((_la - 196) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 196)) & ((1ULL << (tsqlParser::VALUE - 196))
          | (1ULL << (tsqlParser::ABSOLUTE - 196))
          | (1ULL << (tsqlParser::APPLY - 196))
          | (1ULL << (tsqlParser::AUTO - 196))
          | (1ULL << (tsqlParser::AVG - 196))
          | (1ULL << (tsqlParser::BASE64 - 196))
          | (1ULL << (tsqlParser::CALLER - 196))
          | (1ULL << (tsqlParser::CAST - 196))
          | (1ULL << (tsqlParser::CATCH - 196))
          | (1ULL << (tsqlParser::CHECKSUM_AGG - 196))
          | (1ULL << (tsqlParser::COMMITTED - 196))
          | (1ULL << (tsqlParser::CONCAT - 196))
          | (1ULL << (tsqlParser::CONTROL - 196))
          | (1ULL << (tsqlParser::COOKIE - 196))
          | (1ULL << (tsqlParser::COUNT - 196))
          | (1ULL << (tsqlParser::COUNT_BIG - 196))
          | (1ULL << (tsqlParser::DATE - 196)))) != 0) || ((((_la - 261) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 261)) & ((1ULL << (tsqlParser::DELAY - 261))
          | (1ULL << (tsqlParser::DELETED - 261))
          | (1ULL << (tsqlParser::DENSE_RANK - 261))
          | (1ULL << (tsqlParser::DISABLE - 261))
          | (1ULL << (tsqlParser::DYNAMIC - 261))
          | (1ULL << (tsqlParser::ENCRYPTION - 261))
          | (1ULL << (tsqlParser::EXIST - 261))
          | (1ULL << (tsqlParser::EXPAND - 261))
          | (1ULL << (tsqlParser::FAST - 261))
          | (1ULL << (tsqlParser::FAST_FORWARD - 261))
          | (1ULL << (tsqlParser::FIRST - 261))
          | (1ULL << (tsqlParser::FIRST_VALUE - 261))
          | (1ULL << (tsqlParser::FOLLOWING - 261))
          | (1ULL << (tsqlParser::FORCE - 261))
          | (1ULL << (tsqlParser::FORCED - 261))
          | (1ULL << (tsqlParser::FORWARD_ONLY - 261))
          | (1ULL << (tsqlParser::FULLSCAN - 261))
          | (1ULL << (tsqlParser::GLOBAL - 261))
          | (1ULL << (tsqlParser::GROUPING - 261))
          | (1ULL << (tsqlParser::GROUPING_ID - 261))
          | (1ULL << (tsqlParser::HASH - 261))
          | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 261))
          | (1ULL << (tsqlParser::IMPERSONATE - 261))
          | (1ULL << (tsqlParser::INSENSITIVE - 261))
          | (1ULL << (tsqlParser::INSERTED - 261))
          | (1ULL << (tsqlParser::ISOLATION - 261))
          | (1ULL << (tsqlParser::IO - 261))
          | (1ULL << (tsqlParser::KEEP - 261))
          | (1ULL << (tsqlParser::KEEPFIXED - 261))
          | (1ULL << (tsqlParser::KEYSET - 261))
          | (1ULL << (tsqlParser::LAG - 261))
          | (1ULL << (tsqlParser::LAST - 261))
          | (1ULL << (tsqlParser::LAST_VALUE - 261))
          | (1ULL << (tsqlParser::LEAD - 261))
          | (1ULL << (tsqlParser::LEVEL - 261))
          | (1ULL << (tsqlParser::LOCAL - 261))
          | (1ULL << (tsqlParser::LOCK_ESCALATION - 261))
          | (1ULL << (tsqlParser::LOGIN - 261))
          | (1ULL << (tsqlParser::LOOP - 261))
          | (1ULL << (tsqlParser::MARK - 261))
          | (1ULL << (tsqlParser::MAX - 261))
          | (1ULL << (tsqlParser::MAXDOP - 261))
          | (1ULL << (tsqlParser::MAXRECURSION - 261)))) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 328)) & ((1ULL << (tsqlParser::MIN - 328))
          | (1ULL << (tsqlParser::MODIFY - 328))
          | (1ULL << (tsqlParser::NAME - 328))
          | (1ULL << (tsqlParser::NOCOUNT - 328))
          | (1ULL << (tsqlParser::NODES - 328))
          | (1ULL << (tsqlParser::NOEXPAND - 328))
          | (1ULL << (tsqlParser::NORECOMPUTE - 328))
          | (1ULL << (tsqlParser::NTILE - 328))
          | (1ULL << (tsqlParser::NUMBER - 328))
          | (1ULL << (tsqlParser::OFFSET - 328))
          | (1ULL << (tsqlParser::ONLINE - 328))
          | (1ULL << (tsqlParser::ONLY - 328))
          | (1ULL << (tsqlParser::OPTIMISTIC - 328))
          | (1ULL << (tsqlParser::OPTIMIZE - 328))
          | (1ULL << (tsqlParser::OUT - 328))
          | (1ULL << (tsqlParser::OUTPUT - 328))
          | (1ULL << (tsqlParser::OWNER - 328))
          | (1ULL << (tsqlParser::PARAMETERIZATION - 328))
          | (1ULL << (tsqlParser::PARTITION - 328))
          | (1ULL << (tsqlParser::PATH - 328))
          | (1ULL << (tsqlParser::PRECEDING - 328))
          | (1ULL << (tsqlParser::PRIOR - 328))
          | (1ULL << (tsqlParser::PRIVILEGES - 328))
          | (1ULL << (tsqlParser::QUERY - 328))
          | (1ULL << (tsqlParser::RANGE - 328))
          | (1ULL << (tsqlParser::RANK - 328))
          | (1ULL << (tsqlParser::READONLY - 328))
          | (1ULL << (tsqlParser::READ_ONLY - 328))
          | (1ULL << (tsqlParser::RECOMPILE - 328))
          | (1ULL << (tsqlParser::RELATIVE - 328))
          | (1ULL << (tsqlParser::REMOTE - 328))
          | (1ULL << (tsqlParser::REPEATABLE - 328))
          | (1ULL << (tsqlParser::ROBUST - 328))
          | (1ULL << (tsqlParser::ROOT - 328))
          | (1ULL << (tsqlParser::ROW - 328))
          | (1ULL << (tsqlParser::ROWGUID - 328))
          | (1ULL << (tsqlParser::ROWS - 328))
          | (1ULL << (tsqlParser::ROW_NUMBER - 328))
          | (1ULL << (tsqlParser::SAMPLE - 328))
          | (1ULL << (tsqlParser::SCHEMABINDING - 328))
          | (1ULL << (tsqlParser::SCROLL - 328))
          | (1ULL << (tsqlParser::SCROLL_LOCKS - 328)))) != 0) || ((((_la - 393) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 393)) & ((1ULL << (tsqlParser::SELF - 393))
          | (1ULL << (tsqlParser::SERIALIZABLE - 393))
          | (1ULL << (tsqlParser::SIMPLE - 393))
          | (1ULL << (tsqlParser::SIZE - 393))
          | (1ULL << (tsqlParser::SNAPSHOT - 393))
          | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 393))
          | (1ULL << (tsqlParser::STATIC - 393))
          | (1ULL << (tsqlParser::STATS_STREAM - 393))
          | (1ULL << (tsqlParser::STDEV - 393))
          | (1ULL << (tsqlParser::STDEVP - 393))
          | (1ULL << (tsqlParser::SUM - 393))
          | (1ULL << (tsqlParser::TEXTIMAGE_ON - 393))
          | (1ULL << (tsqlParser::THROW - 393))
          | (1ULL << (tsqlParser::TIES - 393))
          | (1ULL << (tsqlParser::TIME - 393))
          | (1ULL << (tsqlParser::TRY - 393))
          | (1ULL << (tsqlParser::TYPE - 393))
          | (1ULL << (tsqlParser::TYPE_WARNING - 393))
          | (1ULL << (tsqlParser::UNBOUNDED - 393))
          | (1ULL << (tsqlParser::UNCOMMITTED - 393))
          | (1ULL << (tsqlParser::UNKNOWN - 393))
          | (1ULL << (tsqlParser::USING - 393))
          | (1ULL << (tsqlParser::VAR - 393))
          | (1ULL << (tsqlParser::VARP - 393))
          | (1ULL << (tsqlParser::VIEWS - 393))
          | (1ULL << (tsqlParser::VIEW_METADATA - 393))
          | (1ULL << (tsqlParser::WORK - 393))
          | (1ULL << (tsqlParser::XML - 393))
          | (1ULL << (tsqlParser::XMLNAMESPACES - 393))
          | (1ULL << (tsqlParser::ZONE - 393))
          | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 393))
          | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 393))
          | (1ULL << (tsqlParser::ID - 393)))) != 0)) {
          setState(1602);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == tsqlParser::ANY) {
            setState(1601);
            match(tsqlParser::ANY);
          }
          setState(1606);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case tsqlParser::FORCESEEK:
            case tsqlParser::NEXT:
            case tsqlParser::NUMERIC:
            case tsqlParser::VALUE:
            case tsqlParser::ABSOLUTE:
            case tsqlParser::APPLY:
            case tsqlParser::AUTO:
            case tsqlParser::AVG:
            case tsqlParser::BASE64:
            case tsqlParser::CALLER:
            case tsqlParser::CAST:
            case tsqlParser::CATCH:
            case tsqlParser::CHECKSUM_AGG:
            case tsqlParser::COMMITTED:
            case tsqlParser::CONCAT:
            case tsqlParser::CONTROL:
            case tsqlParser::COOKIE:
            case tsqlParser::COUNT:
            case tsqlParser::COUNT_BIG:
            case tsqlParser::DATE:
            case tsqlParser::DELAY:
            case tsqlParser::DELETED:
            case tsqlParser::DENSE_RANK:
            case tsqlParser::DISABLE:
            case tsqlParser::DYNAMIC:
            case tsqlParser::ENCRYPTION:
            case tsqlParser::EXIST:
            case tsqlParser::EXPAND:
            case tsqlParser::FAST:
            case tsqlParser::FAST_FORWARD:
            case tsqlParser::FIRST:
            case tsqlParser::FIRST_VALUE:
            case tsqlParser::FOLLOWING:
            case tsqlParser::FORCE:
            case tsqlParser::FORCED:
            case tsqlParser::FORWARD_ONLY:
            case tsqlParser::FULLSCAN:
            case tsqlParser::GLOBAL:
            case tsqlParser::GROUPING:
            case tsqlParser::GROUPING_ID:
            case tsqlParser::HASH:
            case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
            case tsqlParser::IMPERSONATE:
            case tsqlParser::INSENSITIVE:
            case tsqlParser::INSERTED:
            case tsqlParser::ISOLATION:
            case tsqlParser::IO:
            case tsqlParser::KEEP:
            case tsqlParser::KEEPFIXED:
            case tsqlParser::KEYSET:
            case tsqlParser::LAG:
            case tsqlParser::LAST:
            case tsqlParser::LAST_VALUE:
            case tsqlParser::LEAD:
            case tsqlParser::LEVEL:
            case tsqlParser::LOCAL:
            case tsqlParser::LOCK_ESCALATION:
            case tsqlParser::LOGIN:
            case tsqlParser::LOOP:
            case tsqlParser::MARK:
            case tsqlParser::MAX:
            case tsqlParser::MAXDOP:
            case tsqlParser::MAXRECURSION:
            case tsqlParser::MIN:
            case tsqlParser::MODIFY:
            case tsqlParser::NAME:
            case tsqlParser::NOCOUNT:
            case tsqlParser::NODES:
            case tsqlParser::NOEXPAND:
            case tsqlParser::NORECOMPUTE:
            case tsqlParser::NTILE:
            case tsqlParser::NUMBER:
            case tsqlParser::OFFSET:
            case tsqlParser::ONLINE:
            case tsqlParser::ONLY:
            case tsqlParser::OPTIMISTIC:
            case tsqlParser::OPTIMIZE:
            case tsqlParser::OUT:
            case tsqlParser::OUTPUT:
            case tsqlParser::OWNER:
            case tsqlParser::PARAMETERIZATION:
            case tsqlParser::PARTITION:
            case tsqlParser::PATH:
            case tsqlParser::PRECEDING:
            case tsqlParser::PRIOR:
            case tsqlParser::PRIVILEGES:
            case tsqlParser::QUERY:
            case tsqlParser::RANGE:
            case tsqlParser::RANK:
            case tsqlParser::READONLY:
            case tsqlParser::READ_ONLY:
            case tsqlParser::RECOMPILE:
            case tsqlParser::RELATIVE:
            case tsqlParser::REMOTE:
            case tsqlParser::REPEATABLE:
            case tsqlParser::ROBUST:
            case tsqlParser::ROOT:
            case tsqlParser::ROW:
            case tsqlParser::ROWGUID:
            case tsqlParser::ROWS:
            case tsqlParser::ROW_NUMBER:
            case tsqlParser::SAMPLE:
            case tsqlParser::SCHEMABINDING:
            case tsqlParser::SCROLL:
            case tsqlParser::SCROLL_LOCKS:
            case tsqlParser::SELF:
            case tsqlParser::SERIALIZABLE:
            case tsqlParser::SIMPLE:
            case tsqlParser::SIZE:
            case tsqlParser::SNAPSHOT:
            case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
            case tsqlParser::STATIC:
            case tsqlParser::STATS_STREAM:
            case tsqlParser::STDEV:
            case tsqlParser::STDEVP:
            case tsqlParser::SUM:
            case tsqlParser::TEXTIMAGE_ON:
            case tsqlParser::THROW:
            case tsqlParser::TIES:
            case tsqlParser::TIME:
            case tsqlParser::TRY:
            case tsqlParser::TYPE:
            case tsqlParser::TYPE_WARNING:
            case tsqlParser::UNBOUNDED:
            case tsqlParser::UNCOMMITTED:
            case tsqlParser::UNKNOWN:
            case tsqlParser::USING:
            case tsqlParser::VAR:
            case tsqlParser::VARP:
            case tsqlParser::VIEWS:
            case tsqlParser::VIEW_METADATA:
            case tsqlParser::WORK:
            case tsqlParser::XML:
            case tsqlParser::XMLNAMESPACES:
            case tsqlParser::ZONE:
            case tsqlParser::DOUBLE_QUOTE_ID:
            case tsqlParser::SQUARE_BRACKET_ID:
            case tsqlParser::ID: {
              setState(1604);
              r_id();
              break;
            }

            case tsqlParser::DATABASE: {
              setState(1605);
              match(tsqlParser::DATABASE);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_statementContext ------------------------------------------------------------------

tsqlParser::Set_statementContext::Set_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Set_statementContext::SET() {
  return getToken(tsqlParser::SET, 0);
}

tree::TerminalNode* tsqlParser::Set_statementContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* tsqlParser::Set_statementContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Set_statementContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Set_statementContext::DOT() {
  return getToken(tsqlParser::DOT, 0);
}

tree::TerminalNode* tsqlParser::Set_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tsqlParser::R_idContext* tsqlParser::Set_statementContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tsqlParser::Assignment_operatorContext* tsqlParser::Set_statementContext::assignment_operator() {
  return getRuleContext<tsqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* tsqlParser::Set_statementContext::CURSOR() {
  return getToken(tsqlParser::CURSOR, 0);
}

tsqlParser::Declare_set_cursor_commonContext* tsqlParser::Set_statementContext::declare_set_cursor_common() {
  return getRuleContext<tsqlParser::Declare_set_cursor_commonContext>(0);
}

tree::TerminalNode* tsqlParser::Set_statementContext::FOR() {
  return getToken(tsqlParser::FOR, 0);
}

tree::TerminalNode* tsqlParser::Set_statementContext::READ() {
  return getToken(tsqlParser::READ, 0);
}

tree::TerminalNode* tsqlParser::Set_statementContext::ONLY() {
  return getToken(tsqlParser::ONLY, 0);
}

tree::TerminalNode* tsqlParser::Set_statementContext::UPDATE() {
  return getToken(tsqlParser::UPDATE, 0);
}

tree::TerminalNode* tsqlParser::Set_statementContext::OF() {
  return getToken(tsqlParser::OF, 0);
}

tsqlParser::Column_name_listContext* tsqlParser::Set_statementContext::column_name_list() {
  return getRuleContext<tsqlParser::Column_name_listContext>(0);
}

tsqlParser::Set_specialContext* tsqlParser::Set_statementContext::set_special() {
  return getRuleContext<tsqlParser::Set_specialContext>(0);
}


size_t tsqlParser::Set_statementContext::getRuleIndex() const {
  return tsqlParser::RuleSet_statement;
}


antlrcpp::Any tsqlParser::Set_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSet_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Set_statementContext* tsqlParser::set_statement() {
  Set_statementContext *_localctx = _tracker.createInstance<Set_statementContext>(_ctx, getState());
  enterRule(_localctx, 168, tsqlParser::RuleSet_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1651);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1612);
      match(tsqlParser::SET);
      setState(1613);
      match(tsqlParser::LOCAL_ID);
      setState(1616);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::DOT) {
        setState(1614);
        match(tsqlParser::DOT);
        setState(1615);
        dynamic_cast<Set_statementContext *>(_localctx)->member_name = r_id();
      }
      setState(1618);
      match(tsqlParser::EQUAL);
      setState(1619);
      expression(0);
      setState(1621);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx)) {
      case 1: {
        setState(1620);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1623);
      match(tsqlParser::SET);
      setState(1624);
      match(tsqlParser::LOCAL_ID);
      setState(1625);
      assignment_operator();
      setState(1626);
      expression(0);
      setState(1628);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {
      case 1: {
        setState(1627);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1630);
      match(tsqlParser::SET);
      setState(1631);
      match(tsqlParser::LOCAL_ID);
      setState(1632);
      match(tsqlParser::EQUAL);
      setState(1633);
      match(tsqlParser::CURSOR);
      setState(1634);
      declare_set_cursor_common();
      setState(1645);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::FOR) {
        setState(1635);
        match(tsqlParser::FOR);
        setState(1643);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::READ: {
            setState(1636);
            match(tsqlParser::READ);
            setState(1637);
            match(tsqlParser::ONLY);
            break;
          }

          case tsqlParser::UPDATE: {
            setState(1638);
            match(tsqlParser::UPDATE);
            setState(1641);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == tsqlParser::OF) {
              setState(1639);
              match(tsqlParser::OF);
              setState(1640);
              column_name_list();
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
      }
      setState(1648);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx)) {
      case 1: {
        setState(1647);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1650);
      set_special();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_statementContext ------------------------------------------------------------------

tsqlParser::Transaction_statementContext::Transaction_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::BEGIN() {
  return getToken(tsqlParser::BEGIN, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::DISTRIBUTED() {
  return getToken(tsqlParser::DISTRIBUTED, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::TRAN() {
  return getToken(tsqlParser::TRAN, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::TRANSACTION() {
  return getToken(tsqlParser::TRANSACTION, 0);
}

tsqlParser::R_idContext* tsqlParser::Transaction_statementContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::MARK() {
  return getToken(tsqlParser::MARK, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::COMMIT() {
  return getToken(tsqlParser::COMMIT, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::DELAYED_DURABILITY() {
  return getToken(tsqlParser::DELAYED_DURABILITY, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::OFF() {
  return getToken(tsqlParser::OFF, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::WORK() {
  return getToken(tsqlParser::WORK, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::ROLLBACK() {
  return getToken(tsqlParser::ROLLBACK, 0);
}

tree::TerminalNode* tsqlParser::Transaction_statementContext::SAVE() {
  return getToken(tsqlParser::SAVE, 0);
}


size_t tsqlParser::Transaction_statementContext::getRuleIndex() const {
  return tsqlParser::RuleTransaction_statement;
}


antlrcpp::Any tsqlParser::Transaction_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTransaction_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Transaction_statementContext* tsqlParser::transaction_statement() {
  Transaction_statementContext *_localctx = _tracker.createInstance<Transaction_statementContext>(_ctx, getState());
  enterRule(_localctx, 170, tsqlParser::RuleTransaction_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1730);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1653);
      match(tsqlParser::BEGIN);
      setState(1654);
      match(tsqlParser::DISTRIBUTED);
      setState(1655);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::TRAN

      || _la == tsqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1658);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
      case 1: {
        setState(1656);
        r_id();
        break;
      }

      case 2: {
        setState(1657);
        match(tsqlParser::LOCAL_ID);
        break;
      }

      default:
        break;
      }
      setState(1661);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx)) {
      case 1: {
        setState(1660);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1663);
      match(tsqlParser::BEGIN);
      setState(1664);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::TRAN

      || _la == tsqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1674);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx)) {
      case 1: {
        setState(1667);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::FORCESEEK:
          case tsqlParser::NEXT:
          case tsqlParser::NUMERIC:
          case tsqlParser::VALUE:
          case tsqlParser::ABSOLUTE:
          case tsqlParser::APPLY:
          case tsqlParser::AUTO:
          case tsqlParser::AVG:
          case tsqlParser::BASE64:
          case tsqlParser::CALLER:
          case tsqlParser::CAST:
          case tsqlParser::CATCH:
          case tsqlParser::CHECKSUM_AGG:
          case tsqlParser::COMMITTED:
          case tsqlParser::CONCAT:
          case tsqlParser::CONTROL:
          case tsqlParser::COOKIE:
          case tsqlParser::COUNT:
          case tsqlParser::COUNT_BIG:
          case tsqlParser::DATE:
          case tsqlParser::DELAY:
          case tsqlParser::DELETED:
          case tsqlParser::DENSE_RANK:
          case tsqlParser::DISABLE:
          case tsqlParser::DYNAMIC:
          case tsqlParser::ENCRYPTION:
          case tsqlParser::EXIST:
          case tsqlParser::EXPAND:
          case tsqlParser::FAST:
          case tsqlParser::FAST_FORWARD:
          case tsqlParser::FIRST:
          case tsqlParser::FIRST_VALUE:
          case tsqlParser::FOLLOWING:
          case tsqlParser::FORCE:
          case tsqlParser::FORCED:
          case tsqlParser::FORWARD_ONLY:
          case tsqlParser::FULLSCAN:
          case tsqlParser::GLOBAL:
          case tsqlParser::GROUPING:
          case tsqlParser::GROUPING_ID:
          case tsqlParser::HASH:
          case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case tsqlParser::IMPERSONATE:
          case tsqlParser::INSENSITIVE:
          case tsqlParser::INSERTED:
          case tsqlParser::ISOLATION:
          case tsqlParser::IO:
          case tsqlParser::KEEP:
          case tsqlParser::KEEPFIXED:
          case tsqlParser::KEYSET:
          case tsqlParser::LAG:
          case tsqlParser::LAST:
          case tsqlParser::LAST_VALUE:
          case tsqlParser::LEAD:
          case tsqlParser::LEVEL:
          case tsqlParser::LOCAL:
          case tsqlParser::LOCK_ESCALATION:
          case tsqlParser::LOGIN:
          case tsqlParser::LOOP:
          case tsqlParser::MARK:
          case tsqlParser::MAX:
          case tsqlParser::MAXDOP:
          case tsqlParser::MAXRECURSION:
          case tsqlParser::MIN:
          case tsqlParser::MODIFY:
          case tsqlParser::NAME:
          case tsqlParser::NOCOUNT:
          case tsqlParser::NODES:
          case tsqlParser::NOEXPAND:
          case tsqlParser::NORECOMPUTE:
          case tsqlParser::NTILE:
          case tsqlParser::NUMBER:
          case tsqlParser::OFFSET:
          case tsqlParser::ONLINE:
          case tsqlParser::ONLY:
          case tsqlParser::OPTIMISTIC:
          case tsqlParser::OPTIMIZE:
          case tsqlParser::OUT:
          case tsqlParser::OUTPUT:
          case tsqlParser::OWNER:
          case tsqlParser::PARAMETERIZATION:
          case tsqlParser::PARTITION:
          case tsqlParser::PATH:
          case tsqlParser::PRECEDING:
          case tsqlParser::PRIOR:
          case tsqlParser::PRIVILEGES:
          case tsqlParser::QUERY:
          case tsqlParser::RANGE:
          case tsqlParser::RANK:
          case tsqlParser::READONLY:
          case tsqlParser::READ_ONLY:
          case tsqlParser::RECOMPILE:
          case tsqlParser::RELATIVE:
          case tsqlParser::REMOTE:
          case tsqlParser::REPEATABLE:
          case tsqlParser::ROBUST:
          case tsqlParser::ROOT:
          case tsqlParser::ROW:
          case tsqlParser::ROWGUID:
          case tsqlParser::ROWS:
          case tsqlParser::ROW_NUMBER:
          case tsqlParser::SAMPLE:
          case tsqlParser::SCHEMABINDING:
          case tsqlParser::SCROLL:
          case tsqlParser::SCROLL_LOCKS:
          case tsqlParser::SELF:
          case tsqlParser::SERIALIZABLE:
          case tsqlParser::SIMPLE:
          case tsqlParser::SIZE:
          case tsqlParser::SNAPSHOT:
          case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case tsqlParser::STATIC:
          case tsqlParser::STATS_STREAM:
          case tsqlParser::STDEV:
          case tsqlParser::STDEVP:
          case tsqlParser::SUM:
          case tsqlParser::TEXTIMAGE_ON:
          case tsqlParser::THROW:
          case tsqlParser::TIES:
          case tsqlParser::TIME:
          case tsqlParser::TRY:
          case tsqlParser::TYPE:
          case tsqlParser::TYPE_WARNING:
          case tsqlParser::UNBOUNDED:
          case tsqlParser::UNCOMMITTED:
          case tsqlParser::UNKNOWN:
          case tsqlParser::USING:
          case tsqlParser::VAR:
          case tsqlParser::VARP:
          case tsqlParser::VIEWS:
          case tsqlParser::VIEW_METADATA:
          case tsqlParser::WORK:
          case tsqlParser::XML:
          case tsqlParser::XMLNAMESPACES:
          case tsqlParser::ZONE:
          case tsqlParser::DOUBLE_QUOTE_ID:
          case tsqlParser::SQUARE_BRACKET_ID:
          case tsqlParser::ID: {
            setState(1665);
            r_id();
            break;
          }

          case tsqlParser::LOCAL_ID: {
            setState(1666);
            match(tsqlParser::LOCAL_ID);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1672);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx)) {
        case 1: {
          setState(1669);
          match(tsqlParser::WITH);
          setState(1670);
          match(tsqlParser::MARK);
          setState(1671);
          match(tsqlParser::STRING);
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      setState(1677);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx)) {
      case 1: {
        setState(1676);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1679);
      match(tsqlParser::COMMIT);
      setState(1680);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::TRAN

      || _la == tsqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1693);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx)) {
      case 1: {
        setState(1683);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::FORCESEEK:
          case tsqlParser::NEXT:
          case tsqlParser::NUMERIC:
          case tsqlParser::VALUE:
          case tsqlParser::ABSOLUTE:
          case tsqlParser::APPLY:
          case tsqlParser::AUTO:
          case tsqlParser::AVG:
          case tsqlParser::BASE64:
          case tsqlParser::CALLER:
          case tsqlParser::CAST:
          case tsqlParser::CATCH:
          case tsqlParser::CHECKSUM_AGG:
          case tsqlParser::COMMITTED:
          case tsqlParser::CONCAT:
          case tsqlParser::CONTROL:
          case tsqlParser::COOKIE:
          case tsqlParser::COUNT:
          case tsqlParser::COUNT_BIG:
          case tsqlParser::DATE:
          case tsqlParser::DELAY:
          case tsqlParser::DELETED:
          case tsqlParser::DENSE_RANK:
          case tsqlParser::DISABLE:
          case tsqlParser::DYNAMIC:
          case tsqlParser::ENCRYPTION:
          case tsqlParser::EXIST:
          case tsqlParser::EXPAND:
          case tsqlParser::FAST:
          case tsqlParser::FAST_FORWARD:
          case tsqlParser::FIRST:
          case tsqlParser::FIRST_VALUE:
          case tsqlParser::FOLLOWING:
          case tsqlParser::FORCE:
          case tsqlParser::FORCED:
          case tsqlParser::FORWARD_ONLY:
          case tsqlParser::FULLSCAN:
          case tsqlParser::GLOBAL:
          case tsqlParser::GROUPING:
          case tsqlParser::GROUPING_ID:
          case tsqlParser::HASH:
          case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case tsqlParser::IMPERSONATE:
          case tsqlParser::INSENSITIVE:
          case tsqlParser::INSERTED:
          case tsqlParser::ISOLATION:
          case tsqlParser::IO:
          case tsqlParser::KEEP:
          case tsqlParser::KEEPFIXED:
          case tsqlParser::KEYSET:
          case tsqlParser::LAG:
          case tsqlParser::LAST:
          case tsqlParser::LAST_VALUE:
          case tsqlParser::LEAD:
          case tsqlParser::LEVEL:
          case tsqlParser::LOCAL:
          case tsqlParser::LOCK_ESCALATION:
          case tsqlParser::LOGIN:
          case tsqlParser::LOOP:
          case tsqlParser::MARK:
          case tsqlParser::MAX:
          case tsqlParser::MAXDOP:
          case tsqlParser::MAXRECURSION:
          case tsqlParser::MIN:
          case tsqlParser::MODIFY:
          case tsqlParser::NAME:
          case tsqlParser::NOCOUNT:
          case tsqlParser::NODES:
          case tsqlParser::NOEXPAND:
          case tsqlParser::NORECOMPUTE:
          case tsqlParser::NTILE:
          case tsqlParser::NUMBER:
          case tsqlParser::OFFSET:
          case tsqlParser::ONLINE:
          case tsqlParser::ONLY:
          case tsqlParser::OPTIMISTIC:
          case tsqlParser::OPTIMIZE:
          case tsqlParser::OUT:
          case tsqlParser::OUTPUT:
          case tsqlParser::OWNER:
          case tsqlParser::PARAMETERIZATION:
          case tsqlParser::PARTITION:
          case tsqlParser::PATH:
          case tsqlParser::PRECEDING:
          case tsqlParser::PRIOR:
          case tsqlParser::PRIVILEGES:
          case tsqlParser::QUERY:
          case tsqlParser::RANGE:
          case tsqlParser::RANK:
          case tsqlParser::READONLY:
          case tsqlParser::READ_ONLY:
          case tsqlParser::RECOMPILE:
          case tsqlParser::RELATIVE:
          case tsqlParser::REMOTE:
          case tsqlParser::REPEATABLE:
          case tsqlParser::ROBUST:
          case tsqlParser::ROOT:
          case tsqlParser::ROW:
          case tsqlParser::ROWGUID:
          case tsqlParser::ROWS:
          case tsqlParser::ROW_NUMBER:
          case tsqlParser::SAMPLE:
          case tsqlParser::SCHEMABINDING:
          case tsqlParser::SCROLL:
          case tsqlParser::SCROLL_LOCKS:
          case tsqlParser::SELF:
          case tsqlParser::SERIALIZABLE:
          case tsqlParser::SIMPLE:
          case tsqlParser::SIZE:
          case tsqlParser::SNAPSHOT:
          case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case tsqlParser::STATIC:
          case tsqlParser::STATS_STREAM:
          case tsqlParser::STDEV:
          case tsqlParser::STDEVP:
          case tsqlParser::SUM:
          case tsqlParser::TEXTIMAGE_ON:
          case tsqlParser::THROW:
          case tsqlParser::TIES:
          case tsqlParser::TIME:
          case tsqlParser::TRY:
          case tsqlParser::TYPE:
          case tsqlParser::TYPE_WARNING:
          case tsqlParser::UNBOUNDED:
          case tsqlParser::UNCOMMITTED:
          case tsqlParser::UNKNOWN:
          case tsqlParser::USING:
          case tsqlParser::VAR:
          case tsqlParser::VARP:
          case tsqlParser::VIEWS:
          case tsqlParser::VIEW_METADATA:
          case tsqlParser::WORK:
          case tsqlParser::XML:
          case tsqlParser::XMLNAMESPACES:
          case tsqlParser::ZONE:
          case tsqlParser::DOUBLE_QUOTE_ID:
          case tsqlParser::SQUARE_BRACKET_ID:
          case tsqlParser::ID: {
            setState(1681);
            r_id();
            break;
          }

          case tsqlParser::LOCAL_ID: {
            setState(1682);
            match(tsqlParser::LOCAL_ID);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1691);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 228, _ctx)) {
        case 1: {
          setState(1685);
          match(tsqlParser::WITH);
          setState(1686);
          match(tsqlParser::LR_BRACKET);
          setState(1687);
          match(tsqlParser::DELAYED_DURABILITY);
          setState(1688);
          match(tsqlParser::EQUAL);
          setState(1689);
          _la = _input->LA(1);
          if (!(_la == tsqlParser::OFF

          || _la == tsqlParser::ON)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1690);
          match(tsqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      setState(1696);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx)) {
      case 1: {
        setState(1695);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1698);
      match(tsqlParser::COMMIT);
      setState(1700);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx)) {
      case 1: {
        setState(1699);
        match(tsqlParser::WORK);
        break;
      }

      default:
        break;
      }
      setState(1703);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
      case 1: {
        setState(1702);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1705);
      match(tsqlParser::ROLLBACK);
      setState(1706);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::TRAN

      || _la == tsqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1709);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx)) {
      case 1: {
        setState(1707);
        r_id();
        break;
      }

      case 2: {
        setState(1708);
        match(tsqlParser::LOCAL_ID);
        break;
      }

      default:
        break;
      }
      setState(1712);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx)) {
      case 1: {
        setState(1711);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1714);
      match(tsqlParser::ROLLBACK);
      setState(1716);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, _ctx)) {
      case 1: {
        setState(1715);
        match(tsqlParser::WORK);
        break;
      }

      default:
        break;
      }
      setState(1719);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx)) {
      case 1: {
        setState(1718);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1721);
      match(tsqlParser::SAVE);
      setState(1722);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::TRAN

      || _la == tsqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1725);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx)) {
      case 1: {
        setState(1723);
        r_id();
        break;
      }

      case 2: {
        setState(1724);
        match(tsqlParser::LOCAL_ID);
        break;
      }

      default:
        break;
      }
      setState(1728);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx)) {
      case 1: {
        setState(1727);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Go_statementContext ------------------------------------------------------------------

tsqlParser::Go_statementContext::Go_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Go_statementContext::GO() {
  return getToken(tsqlParser::GO, 0);
}

tree::TerminalNode* tsqlParser::Go_statementContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}


size_t tsqlParser::Go_statementContext::getRuleIndex() const {
  return tsqlParser::RuleGo_statement;
}


antlrcpp::Any tsqlParser::Go_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitGo_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Go_statementContext* tsqlParser::go_statement() {
  Go_statementContext *_localctx = _tracker.createInstance<Go_statementContext>(_ctx, getState());
  enterRule(_localctx, 172, tsqlParser::RuleGo_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1732);
    match(tsqlParser::GO);
    setState(1734);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::DECIMAL) {
      setState(1733);
      dynamic_cast<Go_statementContext *>(_localctx)->count = match(tsqlParser::DECIMAL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Use_statementContext ------------------------------------------------------------------

tsqlParser::Use_statementContext::Use_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Use_statementContext::USE() {
  return getToken(tsqlParser::USE, 0);
}

tsqlParser::R_idContext* tsqlParser::Use_statementContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Use_statementContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}


size_t tsqlParser::Use_statementContext::getRuleIndex() const {
  return tsqlParser::RuleUse_statement;
}


antlrcpp::Any tsqlParser::Use_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitUse_statement(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Use_statementContext* tsqlParser::use_statement() {
  Use_statementContext *_localctx = _tracker.createInstance<Use_statementContext>(_ctx, getState());
  enterRule(_localctx, 174, tsqlParser::RuleUse_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1736);
    match(tsqlParser::USE);
    setState(1737);
    dynamic_cast<Use_statementContext *>(_localctx)->database = r_id();
    setState(1739);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx)) {
    case 1: {
      setState(1738);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_clauseContext ------------------------------------------------------------------

tsqlParser::Execute_clauseContext::Execute_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Execute_clauseContext::EXECUTE() {
  return getToken(tsqlParser::EXECUTE, 0);
}

tree::TerminalNode* tsqlParser::Execute_clauseContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

tree::TerminalNode* tsqlParser::Execute_clauseContext::CALLER() {
  return getToken(tsqlParser::CALLER, 0);
}

tree::TerminalNode* tsqlParser::Execute_clauseContext::SELF() {
  return getToken(tsqlParser::SELF, 0);
}

tree::TerminalNode* tsqlParser::Execute_clauseContext::OWNER() {
  return getToken(tsqlParser::OWNER, 0);
}

tree::TerminalNode* tsqlParser::Execute_clauseContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}


size_t tsqlParser::Execute_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleExecute_clause;
}


antlrcpp::Any tsqlParser::Execute_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitExecute_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Execute_clauseContext* tsqlParser::execute_clause() {
  Execute_clauseContext *_localctx = _tracker.createInstance<Execute_clauseContext>(_ctx, getState());
  enterRule(_localctx, 176, tsqlParser::RuleExecute_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1741);
    match(tsqlParser::EXECUTE);
    setState(1742);
    match(tsqlParser::AS);
    setState(1743);
    dynamic_cast<Execute_clauseContext *>(_localctx)->clause = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::CALLER || _la == tsqlParser::OWNER

    || _la == tsqlParser::SELF || _la == tsqlParser::STRING)) {
      dynamic_cast<Execute_clauseContext *>(_localctx)->clause = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_localContext ------------------------------------------------------------------

tsqlParser::Declare_localContext::Declare_localContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Declare_localContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tsqlParser::Data_typeContext* tsqlParser::Declare_localContext::data_type() {
  return getRuleContext<tsqlParser::Data_typeContext>(0);
}

tree::TerminalNode* tsqlParser::Declare_localContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

tree::TerminalNode* tsqlParser::Declare_localContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Declare_localContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}


size_t tsqlParser::Declare_localContext::getRuleIndex() const {
  return tsqlParser::RuleDeclare_local;
}


antlrcpp::Any tsqlParser::Declare_localContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_local(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Declare_localContext* tsqlParser::declare_local() {
  Declare_localContext *_localctx = _tracker.createInstance<Declare_localContext>(_ctx, getState());
  enterRule(_localctx, 178, tsqlParser::RuleDeclare_local);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1745);
    match(tsqlParser::LOCAL_ID);
    setState(1747);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::AS) {
      setState(1746);
      match(tsqlParser::AS);
    }
    setState(1749);
    data_type();
    setState(1752);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::EQUAL) {
      setState(1750);
      match(tsqlParser::EQUAL);
      setState(1751);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_type_definitionContext ------------------------------------------------------------------

tsqlParser::Table_type_definitionContext::Table_type_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Table_type_definitionContext::TABLE() {
  return getToken(tsqlParser::TABLE, 0);
}

tree::TerminalNode* tsqlParser::Table_type_definitionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Column_def_table_constraintsContext* tsqlParser::Table_type_definitionContext::column_def_table_constraints() {
  return getRuleContext<tsqlParser::Column_def_table_constraintsContext>(0);
}

tree::TerminalNode* tsqlParser::Table_type_definitionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}


size_t tsqlParser::Table_type_definitionContext::getRuleIndex() const {
  return tsqlParser::RuleTable_type_definition;
}


antlrcpp::Any tsqlParser::Table_type_definitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTable_type_definition(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Table_type_definitionContext* tsqlParser::table_type_definition() {
  Table_type_definitionContext *_localctx = _tracker.createInstance<Table_type_definitionContext>(_ctx, getState());
  enterRule(_localctx, 180, tsqlParser::RuleTable_type_definition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1754);
    match(tsqlParser::TABLE);
    setState(1755);
    match(tsqlParser::LR_BRACKET);
    setState(1756);
    column_def_table_constraints();
    setState(1757);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_def_table_constraintsContext ------------------------------------------------------------------

tsqlParser::Column_def_table_constraintsContext::Column_def_table_constraintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::Column_def_table_constraintContext *> tsqlParser::Column_def_table_constraintsContext::column_def_table_constraint() {
  return getRuleContexts<tsqlParser::Column_def_table_constraintContext>();
}

tsqlParser::Column_def_table_constraintContext* tsqlParser::Column_def_table_constraintsContext::column_def_table_constraint(size_t i) {
  return getRuleContext<tsqlParser::Column_def_table_constraintContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Column_def_table_constraintsContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Column_def_table_constraintsContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Column_def_table_constraintsContext::getRuleIndex() const {
  return tsqlParser::RuleColumn_def_table_constraints;
}


antlrcpp::Any tsqlParser::Column_def_table_constraintsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitColumn_def_table_constraints(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Column_def_table_constraintsContext* tsqlParser::column_def_table_constraints() {
  Column_def_table_constraintsContext *_localctx = _tracker.createInstance<Column_def_table_constraintsContext>(_ctx, getState());
  enterRule(_localctx, 182, tsqlParser::RuleColumn_def_table_constraints);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1759);
    column_def_table_constraint();
    setState(1766);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1761);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::COMMA) {
          setState(1760);
          match(tsqlParser::COMMA);
        }
        setState(1763);
        column_def_table_constraint(); 
      }
      setState(1768);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_def_table_constraintContext ------------------------------------------------------------------

tsqlParser::Column_def_table_constraintContext::Column_def_table_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Column_definitionContext* tsqlParser::Column_def_table_constraintContext::column_definition() {
  return getRuleContext<tsqlParser::Column_definitionContext>(0);
}

tsqlParser::Table_constraintContext* tsqlParser::Column_def_table_constraintContext::table_constraint() {
  return getRuleContext<tsqlParser::Table_constraintContext>(0);
}


size_t tsqlParser::Column_def_table_constraintContext::getRuleIndex() const {
  return tsqlParser::RuleColumn_def_table_constraint;
}


antlrcpp::Any tsqlParser::Column_def_table_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitColumn_def_table_constraint(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Column_def_table_constraintContext* tsqlParser::column_def_table_constraint() {
  Column_def_table_constraintContext *_localctx = _tracker.createInstance<Column_def_table_constraintContext>(_ctx, getState());
  enterRule(_localctx, 184, tsqlParser::RuleColumn_def_table_constraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1771);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1769);
        column_definition();
        break;
      }

      case tsqlParser::CHECK:
      case tsqlParser::CONSTRAINT:
      case tsqlParser::FOREIGN:
      case tsqlParser::PRIMARY:
      case tsqlParser::UNIQUE: {
        enterOuterAlt(_localctx, 2);
        setState(1770);
        table_constraint();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_definitionContext ------------------------------------------------------------------

tsqlParser::Column_definitionContext::Column_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Column_definitionContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Column_definitionContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

tsqlParser::Data_typeContext* tsqlParser::Column_definitionContext::data_type() {
  return getRuleContext<tsqlParser::Data_typeContext>(0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Column_definitionContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::COLLATE() {
  return getToken(tsqlParser::COLLATE, 0);
}

tsqlParser::Null_notnullContext* tsqlParser::Column_definitionContext::null_notnull() {
  return getRuleContext<tsqlParser::Null_notnullContext>(0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::DEFAULT() {
  return getToken(tsqlParser::DEFAULT, 0);
}

tsqlParser::Constant_expressionContext* tsqlParser::Column_definitionContext::constant_expression() {
  return getRuleContext<tsqlParser::Constant_expressionContext>(0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::IDENTITY() {
  return getToken(tsqlParser::IDENTITY, 0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::ROWGUIDCOL() {
  return getToken(tsqlParser::ROWGUIDCOL, 0);
}

std::vector<tsqlParser::Column_constraintContext *> tsqlParser::Column_definitionContext::column_constraint() {
  return getRuleContexts<tsqlParser::Column_constraintContext>();
}

tsqlParser::Column_constraintContext* tsqlParser::Column_definitionContext::column_constraint(size_t i) {
  return getRuleContext<tsqlParser::Column_constraintContext>(i);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::CONSTRAINT() {
  return getToken(tsqlParser::CONSTRAINT, 0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::VALUES() {
  return getToken(tsqlParser::VALUES, 0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::COMMA() {
  return getToken(tsqlParser::COMMA, 0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::NOT() {
  return getToken(tsqlParser::NOT, 0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::FOR() {
  return getToken(tsqlParser::FOR, 0);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::REPLICATION() {
  return getToken(tsqlParser::REPLICATION, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Column_definitionContext::DECIMAL() {
  return getTokens(tsqlParser::DECIMAL);
}

tree::TerminalNode* tsqlParser::Column_definitionContext::DECIMAL(size_t i) {
  return getToken(tsqlParser::DECIMAL, i);
}


size_t tsqlParser::Column_definitionContext::getRuleIndex() const {
  return tsqlParser::RuleColumn_definition;
}


antlrcpp::Any tsqlParser::Column_definitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitColumn_definition(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Column_definitionContext* tsqlParser::column_definition() {
  Column_definitionContext *_localctx = _tracker.createInstance<Column_definitionContext>(_ctx, getState());
  enterRule(_localctx, 186, tsqlParser::RuleColumn_definition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1773);
    r_id();
    setState(1777);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::DOUBLE:
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::BIGINT:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DATETIME2:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INT:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SMALLINT:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TINYINT:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        setState(1774);
        data_type();
        break;
      }

      case tsqlParser::AS: {
        setState(1775);
        match(tsqlParser::AS);
        setState(1776);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1781);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::COLLATE) {
      setState(1779);
      match(tsqlParser::COLLATE);
      setState(1780);
      r_id();
    }
    setState(1784);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx)) {
    case 1: {
      setState(1783);
      null_notnull();
      break;
    }

    default:
      break;
    }
    setState(1809);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
    case 1: {
      setState(1788);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::CONSTRAINT) {
        setState(1786);
        match(tsqlParser::CONSTRAINT);
        setState(1787);
        dynamic_cast<Column_definitionContext *>(_localctx)->constraint = r_id();
      }
      setState(1790);
      match(tsqlParser::DEFAULT);
      setState(1791);
      constant_expression();
      setState(1794);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 251, _ctx)) {
      case 1: {
        setState(1792);
        match(tsqlParser::WITH);
        setState(1793);
        match(tsqlParser::VALUES);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(1796);
      match(tsqlParser::IDENTITY);
      setState(1802);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx)) {
      case 1: {
        setState(1797);
        match(tsqlParser::LR_BRACKET);
        setState(1798);
        dynamic_cast<Column_definitionContext *>(_localctx)->seed = match(tsqlParser::DECIMAL);
        setState(1799);
        match(tsqlParser::COMMA);
        setState(1800);
        dynamic_cast<Column_definitionContext *>(_localctx)->increment = match(tsqlParser::DECIMAL);
        setState(1801);
        match(tsqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
      setState(1807);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
      case 1: {
        setState(1804);
        match(tsqlParser::NOT);
        setState(1805);
        match(tsqlParser::FOR);
        setState(1806);
        match(tsqlParser::REPLICATION);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    setState(1812);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::ROWGUIDCOL) {
      setState(1811);
      match(tsqlParser::ROWGUIDCOL);
    }
    setState(1817);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1814);
        column_constraint(); 
      }
      setState(1819);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_constraintContext ------------------------------------------------------------------

tsqlParser::Column_constraintContext::Column_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Column_constraintContext::CHECK() {
  return getToken(tsqlParser::CHECK, 0);
}

tree::TerminalNode* tsqlParser::Column_constraintContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Search_conditionContext* tsqlParser::Column_constraintContext::search_condition() {
  return getRuleContext<tsqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* tsqlParser::Column_constraintContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Column_constraintContext::CONSTRAINT() {
  return getToken(tsqlParser::CONSTRAINT, 0);
}

tsqlParser::R_idContext* tsqlParser::Column_constraintContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tsqlParser::Null_notnullContext* tsqlParser::Column_constraintContext::null_notnull() {
  return getRuleContext<tsqlParser::Null_notnullContext>(0);
}

tree::TerminalNode* tsqlParser::Column_constraintContext::PRIMARY() {
  return getToken(tsqlParser::PRIMARY, 0);
}

tree::TerminalNode* tsqlParser::Column_constraintContext::KEY() {
  return getToken(tsqlParser::KEY, 0);
}

tree::TerminalNode* tsqlParser::Column_constraintContext::UNIQUE() {
  return getToken(tsqlParser::UNIQUE, 0);
}

tsqlParser::ClusteredContext* tsqlParser::Column_constraintContext::clustered() {
  return getRuleContext<tsqlParser::ClusteredContext>(0);
}

tsqlParser::Index_optionsContext* tsqlParser::Column_constraintContext::index_options() {
  return getRuleContext<tsqlParser::Index_optionsContext>(0);
}

tree::TerminalNode* tsqlParser::Column_constraintContext::NOT() {
  return getToken(tsqlParser::NOT, 0);
}

tree::TerminalNode* tsqlParser::Column_constraintContext::FOR() {
  return getToken(tsqlParser::FOR, 0);
}

tree::TerminalNode* tsqlParser::Column_constraintContext::REPLICATION() {
  return getToken(tsqlParser::REPLICATION, 0);
}


size_t tsqlParser::Column_constraintContext::getRuleIndex() const {
  return tsqlParser::RuleColumn_constraint;
}


antlrcpp::Any tsqlParser::Column_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitColumn_constraint(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Column_constraintContext* tsqlParser::column_constraint() {
  Column_constraintContext *_localctx = _tracker.createInstance<Column_constraintContext>(_ctx, getState());
  enterRule(_localctx, 188, tsqlParser::RuleColumn_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1822);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::CONSTRAINT) {
      setState(1820);
      match(tsqlParser::CONSTRAINT);
      setState(1821);
      r_id();
    }
    setState(1825);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::NOT

    || _la == tsqlParser::NULL_) {
      setState(1824);
      null_notnull();
    }
    setState(1848);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::PRIMARY:
      case tsqlParser::UNIQUE: {
        setState(1830);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::PRIMARY: {
            setState(1827);
            match(tsqlParser::PRIMARY);
            setState(1828);
            match(tsqlParser::KEY);
            break;
          }

          case tsqlParser::UNIQUE: {
            setState(1829);
            match(tsqlParser::UNIQUE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1833);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::CLUSTERED || _la == tsqlParser::NONCLUSTERED) {
          setState(1832);
          clustered();
        }
        setState(1836);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
        case 1: {
          setState(1835);
          index_options();
          break;
        }

        default:
          break;
        }
        break;
      }

      case tsqlParser::CHECK: {
        setState(1838);
        match(tsqlParser::CHECK);
        setState(1842);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::NOT) {
          setState(1839);
          match(tsqlParser::NOT);
          setState(1840);
          match(tsqlParser::FOR);
          setState(1841);
          match(tsqlParser::REPLICATION);
        }
        setState(1844);
        match(tsqlParser::LR_BRACKET);
        setState(1845);
        search_condition(0);
        setState(1846);
        match(tsqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_constraintContext ------------------------------------------------------------------

tsqlParser::Table_constraintContext::Table_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> tsqlParser::Table_constraintContext::LR_BRACKET() {
  return getTokens(tsqlParser::LR_BRACKET);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::LR_BRACKET(size_t i) {
  return getToken(tsqlParser::LR_BRACKET, i);
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Table_constraintContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Table_constraintContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Table_constraintContext::RR_BRACKET() {
  return getTokens(tsqlParser::RR_BRACKET);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::RR_BRACKET(size_t i) {
  return getToken(tsqlParser::RR_BRACKET, i);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::FOREIGN() {
  return getToken(tsqlParser::FOREIGN, 0);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::KEY() {
  return getToken(tsqlParser::KEY, 0);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::REFERENCES() {
  return getToken(tsqlParser::REFERENCES, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Table_constraintContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::CHECK() {
  return getToken(tsqlParser::CHECK, 0);
}

tsqlParser::Search_conditionContext* tsqlParser::Table_constraintContext::search_condition() {
  return getRuleContext<tsqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::CONSTRAINT() {
  return getToken(tsqlParser::CONSTRAINT, 0);
}

std::vector<tsqlParser::Column_name_listContext *> tsqlParser::Table_constraintContext::column_name_list() {
  return getRuleContexts<tsqlParser::Column_name_listContext>();
}

tsqlParser::Column_name_listContext* tsqlParser::Table_constraintContext::column_name_list(size_t i) {
  return getRuleContext<tsqlParser::Column_name_listContext>(i);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::PRIMARY() {
  return getToken(tsqlParser::PRIMARY, 0);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::UNIQUE() {
  return getToken(tsqlParser::UNIQUE, 0);
}

tsqlParser::ClusteredContext* tsqlParser::Table_constraintContext::clustered() {
  return getRuleContext<tsqlParser::ClusteredContext>(0);
}

std::vector<tree::TerminalNode *> tsqlParser::Table_constraintContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tsqlParser::Index_optionsContext* tsqlParser::Table_constraintContext::index_options() {
  return getRuleContext<tsqlParser::Index_optionsContext>(0);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::NOT() {
  return getToken(tsqlParser::NOT, 0);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::FOR() {
  return getToken(tsqlParser::FOR, 0);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::REPLICATION() {
  return getToken(tsqlParser::REPLICATION, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Table_constraintContext::ASC() {
  return getTokens(tsqlParser::ASC);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::ASC(size_t i) {
  return getToken(tsqlParser::ASC, i);
}

std::vector<tree::TerminalNode *> tsqlParser::Table_constraintContext::DESC() {
  return getTokens(tsqlParser::DESC);
}

tree::TerminalNode* tsqlParser::Table_constraintContext::DESC(size_t i) {
  return getToken(tsqlParser::DESC, i);
}


size_t tsqlParser::Table_constraintContext::getRuleIndex() const {
  return tsqlParser::RuleTable_constraint;
}


antlrcpp::Any tsqlParser::Table_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTable_constraint(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Table_constraintContext* tsqlParser::table_constraint() {
  Table_constraintContext *_localctx = _tracker.createInstance<Table_constraintContext>(_ctx, getState());
  enterRule(_localctx, 190, tsqlParser::RuleTable_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1852);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::CONSTRAINT) {
      setState(1850);
      match(tsqlParser::CONSTRAINT);
      setState(1851);
      r_id();
    }
    setState(1906);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::PRIMARY:
      case tsqlParser::UNIQUE: {
        setState(1857);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::PRIMARY: {
            setState(1854);
            match(tsqlParser::PRIMARY);
            setState(1855);
            match(tsqlParser::KEY);
            break;
          }

          case tsqlParser::UNIQUE: {
            setState(1856);
            match(tsqlParser::UNIQUE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1860);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::CLUSTERED || _la == tsqlParser::NONCLUSTERED) {
          setState(1859);
          clustered();
        }
        setState(1862);
        match(tsqlParser::LR_BRACKET);
        setState(1863);
        r_id();
        setState(1865);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::ASC

        || _la == tsqlParser::DESC) {
          setState(1864);
          _la = _input->LA(1);
          if (!(_la == tsqlParser::ASC

          || _la == tsqlParser::DESC)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(1874);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == tsqlParser::COMMA) {
          setState(1867);
          match(tsqlParser::COMMA);
          setState(1868);
          r_id();
          setState(1870);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == tsqlParser::ASC

          || _la == tsqlParser::DESC) {
            setState(1869);
            _la = _input->LA(1);
            if (!(_la == tsqlParser::ASC

            || _la == tsqlParser::DESC)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
          }
          setState(1876);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1877);
        match(tsqlParser::RR_BRACKET);
        setState(1879);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 270, _ctx)) {
        case 1: {
          setState(1878);
          index_options();
          break;
        }

        default:
          break;
        }
        setState(1883);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::ON) {
          setState(1881);
          match(tsqlParser::ON);
          setState(1882);
          r_id();
        }
        break;
      }

      case tsqlParser::FOREIGN: {
        setState(1885);
        match(tsqlParser::FOREIGN);
        setState(1886);
        match(tsqlParser::KEY);
        setState(1887);
        match(tsqlParser::LR_BRACKET);
        setState(1888);
        dynamic_cast<Table_constraintContext *>(_localctx)->fk = column_name_list();
        setState(1889);
        match(tsqlParser::RR_BRACKET);
        setState(1890);
        match(tsqlParser::REFERENCES);
        setState(1891);
        table_name();
        setState(1892);
        match(tsqlParser::LR_BRACKET);
        setState(1893);
        dynamic_cast<Table_constraintContext *>(_localctx)->pk = column_name_list();
        setState(1894);
        match(tsqlParser::RR_BRACKET);
        break;
      }

      case tsqlParser::CHECK: {
        setState(1896);
        match(tsqlParser::CHECK);
        setState(1900);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::NOT) {
          setState(1897);
          match(tsqlParser::NOT);
          setState(1898);
          match(tsqlParser::FOR);
          setState(1899);
          match(tsqlParser::REPLICATION);
        }
        setState(1902);
        match(tsqlParser::LR_BRACKET);
        setState(1903);
        search_condition(0);
        setState(1904);
        match(tsqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_optionsContext ------------------------------------------------------------------

tsqlParser::Index_optionsContext::Index_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Index_optionsContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

tree::TerminalNode* tsqlParser::Index_optionsContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

std::vector<tsqlParser::Index_optionContext *> tsqlParser::Index_optionsContext::index_option() {
  return getRuleContexts<tsqlParser::Index_optionContext>();
}

tsqlParser::Index_optionContext* tsqlParser::Index_optionsContext::index_option(size_t i) {
  return getRuleContext<tsqlParser::Index_optionContext>(i);
}

tree::TerminalNode* tsqlParser::Index_optionsContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Index_optionsContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Index_optionsContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Index_optionsContext::getRuleIndex() const {
  return tsqlParser::RuleIndex_options;
}


antlrcpp::Any tsqlParser::Index_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitIndex_options(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Index_optionsContext* tsqlParser::index_options() {
  Index_optionsContext *_localctx = _tracker.createInstance<Index_optionsContext>(_ctx, getState());
  enterRule(_localctx, 192, tsqlParser::RuleIndex_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1908);
    match(tsqlParser::WITH);
    setState(1909);
    match(tsqlParser::LR_BRACKET);
    setState(1910);
    index_option();
    setState(1915);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(1911);
      match(tsqlParser::COMMA);
      setState(1912);
      index_option();
      setState(1917);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1918);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_optionContext ------------------------------------------------------------------

tsqlParser::Index_optionContext::Index_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::Simple_idContext *> tsqlParser::Index_optionContext::simple_id() {
  return getRuleContexts<tsqlParser::Simple_idContext>();
}

tsqlParser::Simple_idContext* tsqlParser::Index_optionContext::simple_id(size_t i) {
  return getRuleContext<tsqlParser::Simple_idContext>(i);
}

tree::TerminalNode* tsqlParser::Index_optionContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tsqlParser::On_offContext* tsqlParser::Index_optionContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}

tree::TerminalNode* tsqlParser::Index_optionContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}


size_t tsqlParser::Index_optionContext::getRuleIndex() const {
  return tsqlParser::RuleIndex_option;
}


antlrcpp::Any tsqlParser::Index_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitIndex_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Index_optionContext* tsqlParser::index_option() {
  Index_optionContext *_localctx = _tracker.createInstance<Index_optionContext>(_ctx, getState());
  enterRule(_localctx, 194, tsqlParser::RuleIndex_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1920);
    simple_id();
    setState(1921);
    match(tsqlParser::EQUAL);
    setState(1925);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::ID: {
        setState(1922);
        simple_id();
        break;
      }

      case tsqlParser::OFF:
      case tsqlParser::ON: {
        setState(1923);
        on_off();
        break;
      }

      case tsqlParser::DECIMAL: {
        setState(1924);
        match(tsqlParser::DECIMAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_cursorContext ------------------------------------------------------------------

tsqlParser::Declare_cursorContext::Declare_cursorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Declare_cursorContext::DECLARE() {
  return getToken(tsqlParser::DECLARE, 0);
}

tsqlParser::Cursor_nameContext* tsqlParser::Declare_cursorContext::cursor_name() {
  return getRuleContext<tsqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Declare_cursorContext::CURSOR() {
  return getToken(tsqlParser::CURSOR, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Declare_cursorContext::FOR() {
  return getTokens(tsqlParser::FOR);
}

tree::TerminalNode* tsqlParser::Declare_cursorContext::FOR(size_t i) {
  return getToken(tsqlParser::FOR, i);
}

tsqlParser::Select_statementContext* tsqlParser::Declare_cursorContext::select_statement() {
  return getRuleContext<tsqlParser::Select_statementContext>(0);
}

tree::TerminalNode* tsqlParser::Declare_cursorContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tsqlParser::Declare_set_cursor_commonContext* tsqlParser::Declare_cursorContext::declare_set_cursor_common() {
  return getRuleContext<tsqlParser::Declare_set_cursor_commonContext>(0);
}

tree::TerminalNode* tsqlParser::Declare_cursorContext::INSENSITIVE() {
  return getToken(tsqlParser::INSENSITIVE, 0);
}

tree::TerminalNode* tsqlParser::Declare_cursorContext::SCROLL() {
  return getToken(tsqlParser::SCROLL, 0);
}

tree::TerminalNode* tsqlParser::Declare_cursorContext::READ() {
  return getToken(tsqlParser::READ, 0);
}

tree::TerminalNode* tsqlParser::Declare_cursorContext::ONLY() {
  return getToken(tsqlParser::ONLY, 0);
}

tree::TerminalNode* tsqlParser::Declare_cursorContext::UPDATE() {
  return getToken(tsqlParser::UPDATE, 0);
}

tree::TerminalNode* tsqlParser::Declare_cursorContext::OF() {
  return getToken(tsqlParser::OF, 0);
}

tsqlParser::Column_name_listContext* tsqlParser::Declare_cursorContext::column_name_list() {
  return getRuleContext<tsqlParser::Column_name_listContext>(0);
}


size_t tsqlParser::Declare_cursorContext::getRuleIndex() const {
  return tsqlParser::RuleDeclare_cursor;
}


antlrcpp::Any tsqlParser::Declare_cursorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_cursor(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Declare_cursorContext* tsqlParser::declare_cursor() {
  Declare_cursorContext *_localctx = _tracker.createInstance<Declare_cursorContext>(_ctx, getState());
  enterRule(_localctx, 196, tsqlParser::RuleDeclare_cursor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1927);
    match(tsqlParser::DECLARE);
    setState(1928);
    cursor_name();
    setState(1960);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx)) {
    case 1: {
      setState(1929);
      match(tsqlParser::CURSOR);
      setState(1939);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx)) {
      case 1: {
        setState(1930);
        declare_set_cursor_common();
        setState(1937);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::FOR) {
          setState(1931);
          match(tsqlParser::FOR);
          setState(1932);
          match(tsqlParser::UPDATE);
          setState(1935);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == tsqlParser::OF) {
            setState(1933);
            match(tsqlParser::OF);
            setState(1934);
            column_name_list();
          }
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(1942);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::INSENSITIVE) {
        setState(1941);
        match(tsqlParser::INSENSITIVE);
      }
      setState(1945);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::SCROLL) {
        setState(1944);
        match(tsqlParser::SCROLL);
      }
      setState(1947);
      match(tsqlParser::CURSOR);
      setState(1948);
      match(tsqlParser::FOR);
      setState(1949);
      select_statement();
      setState(1958);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::FOR) {
        setState(1950);
        match(tsqlParser::FOR);
        setState(1956);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::READ: {
            setState(1951);
            match(tsqlParser::READ);
            setState(1952);
            match(tsqlParser::ONLY);
            break;
          }

          case tsqlParser::UPDATE: {
            setState(1953);
            match(tsqlParser::UPDATE);
            break;
          }

          case tsqlParser::OF: {
            setState(1954);
            match(tsqlParser::OF);
            setState(1955);
            column_name_list();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
      }
      break;
    }

    default:
      break;
    }
    setState(1963);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx)) {
    case 1: {
      setState(1962);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_set_cursor_commonContext ------------------------------------------------------------------

tsqlParser::Declare_set_cursor_commonContext::Declare_set_cursor_commonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::FOR() {
  return getToken(tsqlParser::FOR, 0);
}

tsqlParser::Select_statementContext* tsqlParser::Declare_set_cursor_commonContext::select_statement() {
  return getRuleContext<tsqlParser::Select_statementContext>(0);
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::TYPE_WARNING() {
  return getToken(tsqlParser::TYPE_WARNING, 0);
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::LOCAL() {
  return getToken(tsqlParser::LOCAL, 0);
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::GLOBAL() {
  return getToken(tsqlParser::GLOBAL, 0);
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::FORWARD_ONLY() {
  return getToken(tsqlParser::FORWARD_ONLY, 0);
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::SCROLL() {
  return getToken(tsqlParser::SCROLL, 0);
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::STATIC() {
  return getToken(tsqlParser::STATIC, 0);
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::KEYSET() {
  return getToken(tsqlParser::KEYSET, 0);
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::DYNAMIC() {
  return getToken(tsqlParser::DYNAMIC, 0);
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::FAST_FORWARD() {
  return getToken(tsqlParser::FAST_FORWARD, 0);
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::READ_ONLY() {
  return getToken(tsqlParser::READ_ONLY, 0);
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::SCROLL_LOCKS() {
  return getToken(tsqlParser::SCROLL_LOCKS, 0);
}

tree::TerminalNode* tsqlParser::Declare_set_cursor_commonContext::OPTIMISTIC() {
  return getToken(tsqlParser::OPTIMISTIC, 0);
}


size_t tsqlParser::Declare_set_cursor_commonContext::getRuleIndex() const {
  return tsqlParser::RuleDeclare_set_cursor_common;
}


antlrcpp::Any tsqlParser::Declare_set_cursor_commonContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_set_cursor_common(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Declare_set_cursor_commonContext* tsqlParser::declare_set_cursor_common() {
  Declare_set_cursor_commonContext *_localctx = _tracker.createInstance<Declare_set_cursor_commonContext>(_ctx, getState());
  enterRule(_localctx, 198, tsqlParser::RuleDeclare_set_cursor_common);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1966);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::GLOBAL

    || _la == tsqlParser::LOCAL) {
      setState(1965);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::GLOBAL

      || _la == tsqlParser::LOCAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1969);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::FORWARD_ONLY || _la == tsqlParser::SCROLL) {
      setState(1968);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::FORWARD_ONLY || _la == tsqlParser::SCROLL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1972);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 269) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 269)) & ((1ULL << (tsqlParser::DYNAMIC - 269))
      | (1ULL << (tsqlParser::FAST_FORWARD - 269))
      | (1ULL << (tsqlParser::KEYSET - 269)))) != 0) || _la == tsqlParser::STATIC) {
      setState(1971);
      _la = _input->LA(1);
      if (!(((((_la - 269) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 269)) & ((1ULL << (tsqlParser::DYNAMIC - 269))
        | (1ULL << (tsqlParser::FAST_FORWARD - 269))
        | (1ULL << (tsqlParser::KEYSET - 269)))) != 0) || _la == tsqlParser::STATIC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1975);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 350) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 350)) & ((1ULL << (tsqlParser::OPTIMISTIC - 350))
      | (1ULL << (tsqlParser::READ_ONLY - 350))
      | (1ULL << (tsqlParser::SCROLL_LOCKS - 350)))) != 0)) {
      setState(1974);
      _la = _input->LA(1);
      if (!(((((_la - 350) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 350)) & ((1ULL << (tsqlParser::OPTIMISTIC - 350))
        | (1ULL << (tsqlParser::READ_ONLY - 350))
        | (1ULL << (tsqlParser::SCROLL_LOCKS - 350)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1978);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::TYPE_WARNING) {
      setState(1977);
      match(tsqlParser::TYPE_WARNING);
    }
    setState(1980);
    match(tsqlParser::FOR);
    setState(1981);
    select_statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fetch_cursorContext ------------------------------------------------------------------

tsqlParser::Fetch_cursorContext::Fetch_cursorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::FETCH() {
  return getToken(tsqlParser::FETCH, 0);
}

tsqlParser::Cursor_nameContext* tsqlParser::Fetch_cursorContext::cursor_name() {
  return getRuleContext<tsqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::FROM() {
  return getToken(tsqlParser::FROM, 0);
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::GLOBAL() {
  return getToken(tsqlParser::GLOBAL, 0);
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::INTO() {
  return getToken(tsqlParser::INTO, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Fetch_cursorContext::LOCAL_ID() {
  return getTokens(tsqlParser::LOCAL_ID);
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::LOCAL_ID(size_t i) {
  return getToken(tsqlParser::LOCAL_ID, i);
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::NEXT() {
  return getToken(tsqlParser::NEXT, 0);
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::PRIOR() {
  return getToken(tsqlParser::PRIOR, 0);
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::FIRST() {
  return getToken(tsqlParser::FIRST, 0);
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::LAST() {
  return getToken(tsqlParser::LAST, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Fetch_cursorContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> tsqlParser::Fetch_cursorContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::ABSOLUTE() {
  return getToken(tsqlParser::ABSOLUTE, 0);
}

tree::TerminalNode* tsqlParser::Fetch_cursorContext::RELATIVE() {
  return getToken(tsqlParser::RELATIVE, 0);
}


size_t tsqlParser::Fetch_cursorContext::getRuleIndex() const {
  return tsqlParser::RuleFetch_cursor;
}


antlrcpp::Any tsqlParser::Fetch_cursorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFetch_cursor(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Fetch_cursorContext* tsqlParser::fetch_cursor() {
  Fetch_cursorContext *_localctx = _tracker.createInstance<Fetch_cursorContext>(_ctx, getState());
  enterRule(_localctx, 200, tsqlParser::RuleFetch_cursor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1983);
    match(tsqlParser::FETCH);
    setState(1993);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 291, _ctx)) {
    case 1: {
      setState(1990);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case tsqlParser::NEXT: {
          setState(1984);
          match(tsqlParser::NEXT);
          break;
        }

        case tsqlParser::PRIOR: {
          setState(1985);
          match(tsqlParser::PRIOR);
          break;
        }

        case tsqlParser::FIRST: {
          setState(1986);
          match(tsqlParser::FIRST);
          break;
        }

        case tsqlParser::LAST: {
          setState(1987);
          match(tsqlParser::LAST);
          break;
        }

        case tsqlParser::ABSOLUTE:
        case tsqlParser::RELATIVE: {
          setState(1988);
          _la = _input->LA(1);
          if (!(_la == tsqlParser::ABSOLUTE || _la == tsqlParser::RELATIVE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1989);
          expression(0);
          break;
        }

        case tsqlParser::FROM: {
          break;
        }

      default:
        break;
      }
      setState(1992);
      match(tsqlParser::FROM);
      break;
    }

    default:
      break;
    }
    setState(1996);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 292, _ctx)) {
    case 1: {
      setState(1995);
      match(tsqlParser::GLOBAL);
      break;
    }

    default:
      break;
    }
    setState(1998);
    cursor_name();
    setState(2008);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::INTO) {
      setState(1999);
      match(tsqlParser::INTO);
      setState(2000);
      match(tsqlParser::LOCAL_ID);
      setState(2005);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(2001);
        match(tsqlParser::COMMA);
        setState(2002);
        match(tsqlParser::LOCAL_ID);
        setState(2007);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(2011);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
    case 1: {
      setState(2010);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_specialContext ------------------------------------------------------------------

tsqlParser::Set_specialContext::Set_specialContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Set_specialContext::SET() {
  return getToken(tsqlParser::SET, 0);
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Set_specialContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Set_specialContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

tsqlParser::Constant_LOCAL_IDContext* tsqlParser::Set_specialContext::constant_LOCAL_ID() {
  return getRuleContext<tsqlParser::Constant_LOCAL_IDContext>(0);
}

tsqlParser::On_offContext* tsqlParser::Set_specialContext::on_off() {
  return getRuleContext<tsqlParser::On_offContext>(0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::ISOLATION() {
  return getToken(tsqlParser::ISOLATION, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::LEVEL() {
  return getToken(tsqlParser::LEVEL, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::TRANSACTION() {
  return getToken(tsqlParser::TRANSACTION, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::READ() {
  return getToken(tsqlParser::READ, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::UNCOMMITTED() {
  return getToken(tsqlParser::UNCOMMITTED, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::COMMITTED() {
  return getToken(tsqlParser::COMMITTED, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::REPEATABLE() {
  return getToken(tsqlParser::REPEATABLE, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::SNAPSHOT() {
  return getToken(tsqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::SERIALIZABLE() {
  return getToken(tsqlParser::SERIALIZABLE, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Set_specialContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::IDENTITY_INSERT() {
  return getToken(tsqlParser::IDENTITY_INSERT, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::ANSI_NULLS() {
  return getToken(tsqlParser::ANSI_NULLS, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::QUOTED_IDENTIFIER() {
  return getToken(tsqlParser::QUOTED_IDENTIFIER, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::ANSI_PADDING() {
  return getToken(tsqlParser::ANSI_PADDING, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::STATISTICS() {
  return getToken(tsqlParser::STATISTICS, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::TIME() {
  return getToken(tsqlParser::TIME, 0);
}

tree::TerminalNode* tsqlParser::Set_specialContext::IO() {
  return getToken(tsqlParser::IO, 0);
}


size_t tsqlParser::Set_specialContext::getRuleIndex() const {
  return tsqlParser::RuleSet_special;
}


antlrcpp::Any tsqlParser::Set_specialContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSet_special(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Set_specialContext* tsqlParser::set_special() {
  Set_specialContext *_localctx = _tracker.createInstance<Set_specialContext>(_ctx, getState());
  enterRule(_localctx, 202, tsqlParser::RuleSet_special);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2060);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2013);
      match(tsqlParser::SET);
      setState(2014);
      dynamic_cast<Set_specialContext *>(_localctx)->key = r_id();
      setState(2018);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case tsqlParser::FORCESEEK:
        case tsqlParser::NEXT:
        case tsqlParser::NUMERIC:
        case tsqlParser::VALUE:
        case tsqlParser::ABSOLUTE:
        case tsqlParser::APPLY:
        case tsqlParser::AUTO:
        case tsqlParser::AVG:
        case tsqlParser::BASE64:
        case tsqlParser::CALLER:
        case tsqlParser::CAST:
        case tsqlParser::CATCH:
        case tsqlParser::CHECKSUM_AGG:
        case tsqlParser::COMMITTED:
        case tsqlParser::CONCAT:
        case tsqlParser::CONTROL:
        case tsqlParser::COOKIE:
        case tsqlParser::COUNT:
        case tsqlParser::COUNT_BIG:
        case tsqlParser::DATE:
        case tsqlParser::DELAY:
        case tsqlParser::DELETED:
        case tsqlParser::DENSE_RANK:
        case tsqlParser::DISABLE:
        case tsqlParser::DYNAMIC:
        case tsqlParser::ENCRYPTION:
        case tsqlParser::EXIST:
        case tsqlParser::EXPAND:
        case tsqlParser::FAST:
        case tsqlParser::FAST_FORWARD:
        case tsqlParser::FIRST:
        case tsqlParser::FIRST_VALUE:
        case tsqlParser::FOLLOWING:
        case tsqlParser::FORCE:
        case tsqlParser::FORCED:
        case tsqlParser::FORWARD_ONLY:
        case tsqlParser::FULLSCAN:
        case tsqlParser::GLOBAL:
        case tsqlParser::GROUPING:
        case tsqlParser::GROUPING_ID:
        case tsqlParser::HASH:
        case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
        case tsqlParser::IMPERSONATE:
        case tsqlParser::INSENSITIVE:
        case tsqlParser::INSERTED:
        case tsqlParser::ISOLATION:
        case tsqlParser::IO:
        case tsqlParser::KEEP:
        case tsqlParser::KEEPFIXED:
        case tsqlParser::KEYSET:
        case tsqlParser::LAG:
        case tsqlParser::LAST:
        case tsqlParser::LAST_VALUE:
        case tsqlParser::LEAD:
        case tsqlParser::LEVEL:
        case tsqlParser::LOCAL:
        case tsqlParser::LOCK_ESCALATION:
        case tsqlParser::LOGIN:
        case tsqlParser::LOOP:
        case tsqlParser::MARK:
        case tsqlParser::MAX:
        case tsqlParser::MAXDOP:
        case tsqlParser::MAXRECURSION:
        case tsqlParser::MIN:
        case tsqlParser::MODIFY:
        case tsqlParser::NAME:
        case tsqlParser::NOCOUNT:
        case tsqlParser::NODES:
        case tsqlParser::NOEXPAND:
        case tsqlParser::NORECOMPUTE:
        case tsqlParser::NTILE:
        case tsqlParser::NUMBER:
        case tsqlParser::OFFSET:
        case tsqlParser::ONLINE:
        case tsqlParser::ONLY:
        case tsqlParser::OPTIMISTIC:
        case tsqlParser::OPTIMIZE:
        case tsqlParser::OUT:
        case tsqlParser::OUTPUT:
        case tsqlParser::OWNER:
        case tsqlParser::PARAMETERIZATION:
        case tsqlParser::PARTITION:
        case tsqlParser::PATH:
        case tsqlParser::PRECEDING:
        case tsqlParser::PRIOR:
        case tsqlParser::PRIVILEGES:
        case tsqlParser::QUERY:
        case tsqlParser::RANGE:
        case tsqlParser::RANK:
        case tsqlParser::READONLY:
        case tsqlParser::READ_ONLY:
        case tsqlParser::RECOMPILE:
        case tsqlParser::RELATIVE:
        case tsqlParser::REMOTE:
        case tsqlParser::REPEATABLE:
        case tsqlParser::ROBUST:
        case tsqlParser::ROOT:
        case tsqlParser::ROW:
        case tsqlParser::ROWGUID:
        case tsqlParser::ROWS:
        case tsqlParser::ROW_NUMBER:
        case tsqlParser::SAMPLE:
        case tsqlParser::SCHEMABINDING:
        case tsqlParser::SCROLL:
        case tsqlParser::SCROLL_LOCKS:
        case tsqlParser::SELF:
        case tsqlParser::SERIALIZABLE:
        case tsqlParser::SIMPLE:
        case tsqlParser::SIZE:
        case tsqlParser::SNAPSHOT:
        case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case tsqlParser::STATIC:
        case tsqlParser::STATS_STREAM:
        case tsqlParser::STDEV:
        case tsqlParser::STDEVP:
        case tsqlParser::SUM:
        case tsqlParser::TEXTIMAGE_ON:
        case tsqlParser::THROW:
        case tsqlParser::TIES:
        case tsqlParser::TIME:
        case tsqlParser::TRY:
        case tsqlParser::TYPE:
        case tsqlParser::TYPE_WARNING:
        case tsqlParser::UNBOUNDED:
        case tsqlParser::UNCOMMITTED:
        case tsqlParser::UNKNOWN:
        case tsqlParser::USING:
        case tsqlParser::VAR:
        case tsqlParser::VARP:
        case tsqlParser::VIEWS:
        case tsqlParser::VIEW_METADATA:
        case tsqlParser::WORK:
        case tsqlParser::XML:
        case tsqlParser::XMLNAMESPACES:
        case tsqlParser::ZONE:
        case tsqlParser::DOUBLE_QUOTE_ID:
        case tsqlParser::SQUARE_BRACKET_ID:
        case tsqlParser::ID: {
          setState(2015);
          dynamic_cast<Set_specialContext *>(_localctx)->value = r_id();
          break;
        }

        case tsqlParser::LOCAL_ID:
        case tsqlParser::DECIMAL:
        case tsqlParser::STRING:
        case tsqlParser::BINARY:
        case tsqlParser::FLOAT:
        case tsqlParser::REAL:
        case tsqlParser::DOLLAR:
        case tsqlParser::PLUS:
        case tsqlParser::MINUS: {
          setState(2016);
          constant_LOCAL_ID();
          break;
        }

        case tsqlParser::OFF:
        case tsqlParser::ON: {
          setState(2017);
          on_off();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2021);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 297, _ctx)) {
      case 1: {
        setState(2020);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2023);
      match(tsqlParser::SET);
      setState(2024);
      dynamic_cast<Set_specialContext *>(_localctx)->set_type = match(tsqlParser::TRANSACTION);
      setState(2025);
      match(tsqlParser::ISOLATION);
      setState(2026);
      match(tsqlParser::LEVEL);
      setState(2035);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
      case 1: {
        setState(2027);
        match(tsqlParser::READ);
        setState(2028);
        match(tsqlParser::UNCOMMITTED);
        break;
      }

      case 2: {
        setState(2029);
        match(tsqlParser::READ);
        setState(2030);
        match(tsqlParser::COMMITTED);
        break;
      }

      case 3: {
        setState(2031);
        match(tsqlParser::REPEATABLE);
        setState(2032);
        match(tsqlParser::READ);
        break;
      }

      case 4: {
        setState(2033);
        match(tsqlParser::SNAPSHOT);
        break;
      }

      case 5: {
        setState(2034);
        match(tsqlParser::SERIALIZABLE);
        break;
      }

      default:
        break;
      }
      setState(2038);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx)) {
      case 1: {
        setState(2037);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2040);
      match(tsqlParser::SET);
      setState(2041);
      dynamic_cast<Set_specialContext *>(_localctx)->set_type = match(tsqlParser::IDENTITY_INSERT);
      setState(2042);
      table_name();
      setState(2043);
      on_off();
      setState(2045);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx)) {
      case 1: {
        setState(2044);
        match(tsqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2047);
      match(tsqlParser::SET);
      setState(2048);
      dynamic_cast<Set_specialContext *>(_localctx)->set_type = match(tsqlParser::ANSI_NULLS);
      setState(2049);
      on_off();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2050);
      match(tsqlParser::SET);
      setState(2051);
      dynamic_cast<Set_specialContext *>(_localctx)->set_type = match(tsqlParser::QUOTED_IDENTIFIER);
      setState(2052);
      on_off();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2053);
      match(tsqlParser::SET);
      setState(2054);
      dynamic_cast<Set_specialContext *>(_localctx)->set_type = match(tsqlParser::ANSI_PADDING);
      setState(2055);
      on_off();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2056);
      match(tsqlParser::SET);
      setState(2057);
      dynamic_cast<Set_specialContext *>(_localctx)->set_type = match(tsqlParser::STATISTICS);
      setState(2058);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::IO || _la == tsqlParser::TIME)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2059);
      on_off();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_LOCAL_IDContext ------------------------------------------------------------------

tsqlParser::Constant_LOCAL_IDContext::Constant_LOCAL_IDContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::ConstantContext* tsqlParser::Constant_LOCAL_IDContext::constant() {
  return getRuleContext<tsqlParser::ConstantContext>(0);
}

tree::TerminalNode* tsqlParser::Constant_LOCAL_IDContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}


size_t tsqlParser::Constant_LOCAL_IDContext::getRuleIndex() const {
  return tsqlParser::RuleConstant_LOCAL_ID;
}


antlrcpp::Any tsqlParser::Constant_LOCAL_IDContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitConstant_LOCAL_ID(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Constant_LOCAL_IDContext* tsqlParser::constant_LOCAL_ID() {
  Constant_LOCAL_IDContext *_localctx = _tracker.createInstance<Constant_LOCAL_IDContext>(_ctx, getState());
  enterRule(_localctx, 204, tsqlParser::RuleConstant_LOCAL_ID);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2064);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::DECIMAL:
      case tsqlParser::STRING:
      case tsqlParser::BINARY:
      case tsqlParser::FLOAT:
      case tsqlParser::REAL:
      case tsqlParser::DOLLAR:
      case tsqlParser::PLUS:
      case tsqlParser::MINUS: {
        enterOuterAlt(_localctx, 1);
        setState(2062);
        constant();
        break;
      }

      case tsqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(2063);
        match(tsqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

tsqlParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t tsqlParser::ExpressionContext::getRuleIndex() const {
  return tsqlParser::RuleExpression;
}

void tsqlParser::ExpressionContext::copyFrom(ExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Binary_operator_expressionContext ------------------------------------------------------------------

std::vector<tsqlParser::ExpressionContext *> tsqlParser::Binary_operator_expressionContext::expression() {
  return getRuleContexts<tsqlParser::ExpressionContext>();
}

tsqlParser::ExpressionContext* tsqlParser::Binary_operator_expressionContext::expression(size_t i) {
  return getRuleContext<tsqlParser::ExpressionContext>(i);
}

tree::TerminalNode* tsqlParser::Binary_operator_expressionContext::STAR() {
  return getToken(tsqlParser::STAR, 0);
}

tree::TerminalNode* tsqlParser::Binary_operator_expressionContext::DIVIDE() {
  return getToken(tsqlParser::DIVIDE, 0);
}

tree::TerminalNode* tsqlParser::Binary_operator_expressionContext::MODULE() {
  return getToken(tsqlParser::MODULE, 0);
}

tree::TerminalNode* tsqlParser::Binary_operator_expressionContext::PLUS() {
  return getToken(tsqlParser::PLUS, 0);
}

tree::TerminalNode* tsqlParser::Binary_operator_expressionContext::MINUS() {
  return getToken(tsqlParser::MINUS, 0);
}

tree::TerminalNode* tsqlParser::Binary_operator_expressionContext::BIT_AND() {
  return getToken(tsqlParser::BIT_AND, 0);
}

tree::TerminalNode* tsqlParser::Binary_operator_expressionContext::BIT_XOR() {
  return getToken(tsqlParser::BIT_XOR, 0);
}

tree::TerminalNode* tsqlParser::Binary_operator_expressionContext::BIT_OR() {
  return getToken(tsqlParser::BIT_OR, 0);
}

tsqlParser::Comparison_operatorContext* tsqlParser::Binary_operator_expressionContext::comparison_operator() {
  return getRuleContext<tsqlParser::Comparison_operatorContext>(0);
}

tsqlParser::Binary_operator_expressionContext::Binary_operator_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Binary_operator_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBinary_operator_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Unary_operator_expressionContext ------------------------------------------------------------------

tsqlParser::ExpressionContext* tsqlParser::Unary_operator_expressionContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Unary_operator_expressionContext::BIT_NOT() {
  return getToken(tsqlParser::BIT_NOT, 0);
}

tree::TerminalNode* tsqlParser::Unary_operator_expressionContext::PLUS() {
  return getToken(tsqlParser::PLUS, 0);
}

tree::TerminalNode* tsqlParser::Unary_operator_expressionContext::MINUS() {
  return getToken(tsqlParser::MINUS, 0);
}

tsqlParser::Unary_operator_expressionContext::Unary_operator_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Unary_operator_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitUnary_operator_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Function_call_expressionContext ------------------------------------------------------------------

tsqlParser::Function_callContext* tsqlParser::Function_call_expressionContext::function_call() {
  return getRuleContext<tsqlParser::Function_callContext>(0);
}

tsqlParser::ExpressionContext* tsqlParser::Function_call_expressionContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Function_call_expressionContext::COLLATE() {
  return getToken(tsqlParser::COLLATE, 0);
}

tsqlParser::R_idContext* tsqlParser::Function_call_expressionContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tsqlParser::Function_call_expressionContext::Function_call_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Function_call_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFunction_call_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Conversion_expressionContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Conversion_expressionContext::AT() {
  return getToken(tsqlParser::AT, 0);
}

tree::TerminalNode* tsqlParser::Conversion_expressionContext::TIME() {
  return getToken(tsqlParser::TIME, 0);
}

tree::TerminalNode* tsqlParser::Conversion_expressionContext::ZONE() {
  return getToken(tsqlParser::ZONE, 0);
}

std::vector<tsqlParser::ExpressionContext *> tsqlParser::Conversion_expressionContext::expression() {
  return getRuleContexts<tsqlParser::ExpressionContext>();
}

tsqlParser::ExpressionContext* tsqlParser::Conversion_expressionContext::expression(size_t i) {
  return getRuleContext<tsqlParser::ExpressionContext>(i);
}

tsqlParser::Conversion_expressionContext::Conversion_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Conversion_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitConversion_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Case_expressionContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Case_expressionContext::CASE() {
  return getToken(tsqlParser::CASE, 0);
}

tree::TerminalNode* tsqlParser::Case_expressionContext::END() {
  return getToken(tsqlParser::END, 0);
}

std::vector<tsqlParser::ExpressionContext *> tsqlParser::Case_expressionContext::expression() {
  return getRuleContexts<tsqlParser::ExpressionContext>();
}

tsqlParser::ExpressionContext* tsqlParser::Case_expressionContext::expression(size_t i) {
  return getRuleContext<tsqlParser::ExpressionContext>(i);
}

std::vector<tsqlParser::Switch_sectionContext *> tsqlParser::Case_expressionContext::switch_section() {
  return getRuleContexts<tsqlParser::Switch_sectionContext>();
}

tsqlParser::Switch_sectionContext* tsqlParser::Case_expressionContext::switch_section(size_t i) {
  return getRuleContext<tsqlParser::Switch_sectionContext>(i);
}

tree::TerminalNode* tsqlParser::Case_expressionContext::ELSE() {
  return getToken(tsqlParser::ELSE, 0);
}

std::vector<tsqlParser::Switch_search_condition_sectionContext *> tsqlParser::Case_expressionContext::switch_search_condition_section() {
  return getRuleContexts<tsqlParser::Switch_search_condition_sectionContext>();
}

tsqlParser::Switch_search_condition_sectionContext* tsqlParser::Case_expressionContext::switch_search_condition_section(size_t i) {
  return getRuleContext<tsqlParser::Switch_search_condition_sectionContext>(i);
}

tsqlParser::Case_expressionContext::Case_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Case_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCase_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Column_ref_expressionContext ------------------------------------------------------------------

tsqlParser::Full_column_nameContext* tsqlParser::Column_ref_expressionContext::full_column_name() {
  return getRuleContext<tsqlParser::Full_column_nameContext>(0);
}

tsqlParser::Column_ref_expressionContext::Column_ref_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Column_ref_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitColumn_ref_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- String_agg_expressionContext ------------------------------------------------------------------

tsqlParser::String_aggContext* tsqlParser::String_agg_expressionContext::string_agg() {
  return getRuleContext<tsqlParser::String_aggContext>(0);
}

tsqlParser::String_agg_expressionContext::String_agg_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::String_agg_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitString_agg_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Percentile_cont_expressionContext ------------------------------------------------------------------

tsqlParser::Percentile_contContext* tsqlParser::Percentile_cont_expressionContext::percentile_cont() {
  return getRuleContext<tsqlParser::Percentile_contContext>(0);
}

tsqlParser::Percentile_cont_expressionContext::Percentile_cont_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Percentile_cont_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitPercentile_cont_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Primitive_expressionContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Primitive_expressionContext::DEFAULT() {
  return getToken(tsqlParser::DEFAULT, 0);
}

tree::TerminalNode* tsqlParser::Primitive_expressionContext::NULL_() {
  return getToken(tsqlParser::NULL_, 0);
}

tree::TerminalNode* tsqlParser::Primitive_expressionContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tsqlParser::ConstantContext* tsqlParser::Primitive_expressionContext::constant() {
  return getRuleContext<tsqlParser::ConstantContext>(0);
}

tsqlParser::Primitive_expressionContext::Primitive_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Primitive_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitPrimitive_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bracket_expressionContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Bracket_expressionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Bracket_expressionContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Bracket_expressionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::Bracket_expressionContext::Bracket_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Bracket_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBracket_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Subquery_expressionContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Subquery_expressionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::SubqueryContext* tsqlParser::Subquery_expressionContext::subquery() {
  return getRuleContext<tsqlParser::SubqueryContext>(0);
}

tree::TerminalNode* tsqlParser::Subquery_expressionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::Subquery_expressionContext::Subquery_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Subquery_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSubquery_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Over_clause_expressionContext ------------------------------------------------------------------

tsqlParser::Over_clauseContext* tsqlParser::Over_clause_expressionContext::over_clause() {
  return getRuleContext<tsqlParser::Over_clauseContext>(0);
}

tsqlParser::Over_clause_expressionContext::Over_clause_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Over_clause_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOver_clause_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Xml_method_expressionContext ------------------------------------------------------------------

tsqlParser::ExpressionContext* tsqlParser::Xml_method_expressionContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Xml_method_expressionContext::DOT() {
  return getToken(tsqlParser::DOT, 0);
}

tsqlParser::Xml_method_callContext* tsqlParser::Xml_method_expressionContext::xml_method_call() {
  return getRuleContext<tsqlParser::Xml_method_callContext>(0);
}

tsqlParser::Xml_method_expressionContext::Xml_method_expressionContext(ExpressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Xml_method_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitXml_method_expression(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::ExpressionContext* tsqlParser::expression() {
   return expression(0);
}

tsqlParser::ExpressionContext* tsqlParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  tsqlParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  tsqlParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 206;
  enterRecursionRule(_localctx, 206, tsqlParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2113);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<Primitive_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(2067);
      match(tsqlParser::DEFAULT);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<Primitive_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2068);
      match(tsqlParser::NULL_);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<Primitive_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2069);
      match(tsqlParser::LOCAL_ID);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<Primitive_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2070);
      constant();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<Function_call_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2071);
      function_call();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<Case_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2072);
      match(tsqlParser::CASE);
      setState(2073);
      dynamic_cast<Case_expressionContext *>(_localctx)->caseExpr = expression(0);
      setState(2075); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2074);
        switch_section();
        setState(2077); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == tsqlParser::WHEN);
      setState(2081);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::ELSE) {
        setState(2079);
        match(tsqlParser::ELSE);
        setState(2080);
        dynamic_cast<Case_expressionContext *>(_localctx)->elseExpr = expression(0);
      }
      setState(2083);
      match(tsqlParser::END);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<Case_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2085);
      match(tsqlParser::CASE);
      setState(2087); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2086);
        switch_search_condition_section();
        setState(2089); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == tsqlParser::WHEN);
      setState(2093);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::ELSE) {
        setState(2091);
        match(tsqlParser::ELSE);
        setState(2092);
        dynamic_cast<Case_expressionContext *>(_localctx)->elseExpr = expression(0);
      }
      setState(2095);
      match(tsqlParser::END);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<Column_ref_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2097);
      full_column_name();
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<Bracket_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2098);
      match(tsqlParser::LR_BRACKET);
      setState(2099);
      expression(0);
      setState(2100);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<Subquery_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2102);
      match(tsqlParser::LR_BRACKET);
      setState(2103);
      subquery();
      setState(2104);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<Unary_operator_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2106);
      dynamic_cast<Unary_operator_expressionContext *>(_localctx)->op = match(tsqlParser::BIT_NOT);
      setState(2107);
      expression(9);
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<Unary_operator_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2108);
      dynamic_cast<Unary_operator_expressionContext *>(_localctx)->op = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::PLUS

      || _la == tsqlParser::MINUS)) {
        dynamic_cast<Unary_operator_expressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2109);
      expression(7);
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<Over_clause_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2110);
      over_clause();
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<Percentile_cont_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2111);
      percentile_cont();
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<String_agg_expressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2112);
      string_agg();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(2138);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(2136);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 308, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<Conversion_expressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(2115);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(2116);
          match(tsqlParser::AT);
          setState(2117);
          match(tsqlParser::TIME);
          setState(2118);
          match(tsqlParser::ZONE);
          setState(2119);
          dynamic_cast<Conversion_expressionContext *>(_localctx)->right = expression(16);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<Binary_operator_expressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(2120);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(2121);
          dynamic_cast<Binary_operator_expressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 477) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 477)) & ((1ULL << (tsqlParser::STAR - 477))
            | (1ULL << (tsqlParser::DIVIDE - 477))
            | (1ULL << (tsqlParser::MODULE - 477)))) != 0))) {
            dynamic_cast<Binary_operator_expressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2122);
          dynamic_cast<Binary_operator_expressionContext *>(_localctx)->right = expression(9);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<Binary_operator_expressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(2123);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(2124);
          dynamic_cast<Binary_operator_expressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 480) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 480)) & ((1ULL << (tsqlParser::PLUS - 480))
            | (1ULL << (tsqlParser::MINUS - 480))
            | (1ULL << (tsqlParser::BIT_OR - 480))
            | (1ULL << (tsqlParser::BIT_AND - 480))
            | (1ULL << (tsqlParser::BIT_XOR - 480)))) != 0))) {
            dynamic_cast<Binary_operator_expressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2125);
          dynamic_cast<Binary_operator_expressionContext *>(_localctx)->right = expression(7);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<Binary_operator_expressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(2126);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(2127);
          comparison_operator();
          setState(2128);
          dynamic_cast<Binary_operator_expressionContext *>(_localctx)->right = expression(6);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<Function_call_expressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(2130);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(2131);
          match(tsqlParser::COLLATE);
          setState(2132);
          r_id();
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<Xml_method_expressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(2133);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(2134);
          match(tsqlParser::DOT);
          setState(2135);
          xml_method_call();
          break;
        }

        default:
          break;
        } 
      }
      setState(2140);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Xml_method_callContext ------------------------------------------------------------------

tsqlParser::Xml_method_callContext::Xml_method_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Simple_xml_method_nameContext* tsqlParser::Xml_method_callContext::simple_xml_method_name() {
  return getRuleContext<tsqlParser::Simple_xml_method_nameContext>(0);
}

std::vector<tree::TerminalNode *> tsqlParser::Xml_method_callContext::LR_BRACKET() {
  return getTokens(tsqlParser::LR_BRACKET);
}

tree::TerminalNode* tsqlParser::Xml_method_callContext::LR_BRACKET(size_t i) {
  return getToken(tsqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> tsqlParser::Xml_method_callContext::RR_BRACKET() {
  return getTokens(tsqlParser::RR_BRACKET);
}

tree::TerminalNode* tsqlParser::Xml_method_callContext::RR_BRACKET(size_t i) {
  return getToken(tsqlParser::RR_BRACKET, i);
}

tsqlParser::Expression_listContext* tsqlParser::Xml_method_callContext::expression_list() {
  return getRuleContext<tsqlParser::Expression_listContext>(0);
}

tree::TerminalNode* tsqlParser::Xml_method_callContext::NODES() {
  return getToken(tsqlParser::NODES, 0);
}

tree::TerminalNode* tsqlParser::Xml_method_callContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Xml_method_callContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Xml_method_callContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}


size_t tsqlParser::Xml_method_callContext::getRuleIndex() const {
  return tsqlParser::RuleXml_method_call;
}


antlrcpp::Any tsqlParser::Xml_method_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitXml_method_call(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Xml_method_callContext* tsqlParser::xml_method_call() {
  Xml_method_callContext *_localctx = _tracker.createInstance<Xml_method_callContext>(_ctx, getState());
  enterRule(_localctx, 208, tsqlParser::RuleXml_method_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2160);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::VALUE:
      case tsqlParser::EXIST:
      case tsqlParser::QUERY: {
        enterOuterAlt(_localctx, 1);
        setState(2141);
        simple_xml_method_name();
        setState(2142);
        match(tsqlParser::LR_BRACKET);
        setState(2144);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << tsqlParser::CASE)
          | (1ULL << tsqlParser::COALESCE)
          | (1ULL << tsqlParser::CONVERT)
          | (1ULL << tsqlParser::CURRENT_TIMESTAMP)
          | (1ULL << tsqlParser::CURRENT_USER)
          | (1ULL << tsqlParser::DEFAULT))) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & ((1ULL << (tsqlParser::EXP - 66))
          | (1ULL << (tsqlParser::FORCESEEK - 66))
          | (1ULL << (tsqlParser::IDENTITY - 66))
          | (1ULL << (tsqlParser::IIF - 66))
          | (1ULL << (tsqlParser::LEFT - 66))
          | (1ULL << (tsqlParser::LOG - 66))
          | (1ULL << (tsqlParser::LOG10 - 66))
          | (1ULL << (tsqlParser::NEXT - 66))
          | (1ULL << (tsqlParser::NULL_ - 66))
          | (1ULL << (tsqlParser::NULLIF - 66))
          | (1ULL << (tsqlParser::NUMERIC - 66))
          | (1ULL << (tsqlParser::OVER - 66)))) != 0) || ((((_la - 152) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 152)) & ((1ULL << (tsqlParser::RIGHT - 152))
          | (1ULL << (tsqlParser::SESSION_USER - 152))
          | (1ULL << (tsqlParser::SIGN - 152))
          | (1ULL << (tsqlParser::SYSTEM_USER - 152))
          | (1ULL << (tsqlParser::TRY_CAST - 152))
          | (1ULL << (tsqlParser::TRY_CONVERT - 152))
          | (1ULL << (tsqlParser::TRY_PARSE - 152))
          | (1ULL << (tsqlParser::VALUE - 152))
          | (1ULL << (tsqlParser::ABSOLUTE - 152))
          | (1ULL << (tsqlParser::APPLY - 152)))) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & ((1ULL << (tsqlParser::AUTO - 217))
          | (1ULL << (tsqlParser::AVG - 217))
          | (1ULL << (tsqlParser::BASE64 - 217))
          | (1ULL << (tsqlParser::BINARY_CHECKSUM - 217))
          | (1ULL << (tsqlParser::CALLER - 217))
          | (1ULL << (tsqlParser::CAST - 217))
          | (1ULL << (tsqlParser::CATCH - 217))
          | (1ULL << (tsqlParser::CEILING - 217))
          | (1ULL << (tsqlParser::CHECKSUM - 217))
          | (1ULL << (tsqlParser::CHECKSUM_AGG - 217))
          | (1ULL << (tsqlParser::COMMITTED - 217))
          | (1ULL << (tsqlParser::CONCAT - 217))
          | (1ULL << (tsqlParser::CONTROL - 217))
          | (1ULL << (tsqlParser::COOKIE - 217))
          | (1ULL << (tsqlParser::COS - 217))
          | (1ULL << (tsqlParser::COUNT - 217))
          | (1ULL << (tsqlParser::COUNT_BIG - 217))
          | (1ULL << (tsqlParser::DATE - 217))
          | (1ULL << (tsqlParser::DATEADD - 217))
          | (1ULL << (tsqlParser::DATEDIFF - 217))
          | (1ULL << (tsqlParser::DATENAME - 217))
          | (1ULL << (tsqlParser::DATEPART - 217))
          | (1ULL << (tsqlParser::DATETIMEOFFSETFROMPARTS - 217))
          | (1ULL << (tsqlParser::DELAY - 217))
          | (1ULL << (tsqlParser::DELETED - 217))
          | (1ULL << (tsqlParser::DENSE_RANK - 217))
          | (1ULL << (tsqlParser::DISABLE - 217))
          | (1ULL << (tsqlParser::DYNAMIC - 217))
          | (1ULL << (tsqlParser::ENCRYPTION - 217))
          | (1ULL << (tsqlParser::EXIST - 217))
          | (1ULL << (tsqlParser::EXPAND - 217))
          | (1ULL << (tsqlParser::FAST - 217))
          | (1ULL << (tsqlParser::FAST_FORWARD - 217)))) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & ((1ULL << (tsqlParser::FIRST - 281))
          | (1ULL << (tsqlParser::FIRST_VALUE - 281))
          | (1ULL << (tsqlParser::FLOOR - 281))
          | (1ULL << (tsqlParser::FOLLOWING - 281))
          | (1ULL << (tsqlParser::FORCE - 281))
          | (1ULL << (tsqlParser::FORCED - 281))
          | (1ULL << (tsqlParser::FORWARD_ONLY - 281))
          | (1ULL << (tsqlParser::FULLSCAN - 281))
          | (1ULL << (tsqlParser::GLOBAL - 281))
          | (1ULL << (tsqlParser::GROUPING - 281))
          | (1ULL << (tsqlParser::GROUPING_ID - 281))
          | (1ULL << (tsqlParser::HASH - 281))
          | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 281))
          | (1ULL << (tsqlParser::IMPERSONATE - 281))
          | (1ULL << (tsqlParser::INSENSITIVE - 281))
          | (1ULL << (tsqlParser::INSERTED - 281))
          | (1ULL << (tsqlParser::ISOLATION - 281))
          | (1ULL << (tsqlParser::IO - 281))
          | (1ULL << (tsqlParser::KEEP - 281))
          | (1ULL << (tsqlParser::KEEPFIXED - 281))
          | (1ULL << (tsqlParser::KEYSET - 281))
          | (1ULL << (tsqlParser::LAG - 281))
          | (1ULL << (tsqlParser::LAST - 281))
          | (1ULL << (tsqlParser::LAST_VALUE - 281))
          | (1ULL << (tsqlParser::LEAD - 281))
          | (1ULL << (tsqlParser::LEVEL - 281))
          | (1ULL << (tsqlParser::LOCAL - 281))
          | (1ULL << (tsqlParser::LOCK_ESCALATION - 281))
          | (1ULL << (tsqlParser::LOGIN - 281))
          | (1ULL << (tsqlParser::LOOP - 281))
          | (1ULL << (tsqlParser::MARK - 281))
          | (1ULL << (tsqlParser::MAX - 281))
          | (1ULL << (tsqlParser::MAXDOP - 281))
          | (1ULL << (tsqlParser::MAXRECURSION - 281))
          | (1ULL << (tsqlParser::MIN - 281))
          | (1ULL << (tsqlParser::MIN_ACTIVE_ROWVERSION - 281))
          | (1ULL << (tsqlParser::MODIFY - 281))
          | (1ULL << (tsqlParser::NAME - 281))
          | (1ULL << (tsqlParser::NOCOUNT - 281))
          | (1ULL << (tsqlParser::NODES - 281))
          | (1ULL << (tsqlParser::NOEXPAND - 281))
          | (1ULL << (tsqlParser::NORECOMPUTE - 281))
          | (1ULL << (tsqlParser::NTILE - 281))
          | (1ULL << (tsqlParser::NUMBER - 281)))) != 0) || ((((_la - 347) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 347)) & ((1ULL << (tsqlParser::OFFSET - 347))
          | (1ULL << (tsqlParser::ONLINE - 347))
          | (1ULL << (tsqlParser::ONLY - 347))
          | (1ULL << (tsqlParser::OPTIMISTIC - 347))
          | (1ULL << (tsqlParser::OPTIMIZE - 347))
          | (1ULL << (tsqlParser::OUT - 347))
          | (1ULL << (tsqlParser::OUTPUT - 347))
          | (1ULL << (tsqlParser::OWNER - 347))
          | (1ULL << (tsqlParser::PARAMETERIZATION - 347))
          | (1ULL << (tsqlParser::PARSE - 347))
          | (1ULL << (tsqlParser::PARTITION - 347))
          | (1ULL << (tsqlParser::PATH - 347))
          | (1ULL << (tsqlParser::PERCENTILE_CONT - 347))
          | (1ULL << (tsqlParser::POWER - 347))
          | (1ULL << (tsqlParser::PRECEDING - 347))
          | (1ULL << (tsqlParser::PRIOR - 347))
          | (1ULL << (tsqlParser::PRIVILEGES - 347))
          | (1ULL << (tsqlParser::QUERY - 347))
          | (1ULL << (tsqlParser::RANGE - 347))
          | (1ULL << (tsqlParser::RANK - 347))
          | (1ULL << (tsqlParser::READONLY - 347))
          | (1ULL << (tsqlParser::READ_ONLY - 347))
          | (1ULL << (tsqlParser::RECOMPILE - 347))
          | (1ULL << (tsqlParser::RELATIVE - 347))
          | (1ULL << (tsqlParser::REMOTE - 347))
          | (1ULL << (tsqlParser::REPEATABLE - 347))
          | (1ULL << (tsqlParser::ROBUST - 347))
          | (1ULL << (tsqlParser::ROOT - 347))
          | (1ULL << (tsqlParser::ROUND - 347))
          | (1ULL << (tsqlParser::ROW - 347))
          | (1ULL << (tsqlParser::ROWGUID - 347))
          | (1ULL << (tsqlParser::ROWS - 347))
          | (1ULL << (tsqlParser::ROW_NUMBER - 347))
          | (1ULL << (tsqlParser::SAMPLE - 347))
          | (1ULL << (tsqlParser::SCHEMABINDING - 347))
          | (1ULL << (tsqlParser::SCROLL - 347))
          | (1ULL << (tsqlParser::SCROLL_LOCKS - 347))
          | (1ULL << (tsqlParser::SELF - 347))
          | (1ULL << (tsqlParser::SERIALIZABLE - 347))
          | (1ULL << (tsqlParser::SIMPLE - 347))
          | (1ULL << (tsqlParser::SIN - 347))
          | (1ULL << (tsqlParser::SIZE - 347))
          | (1ULL << (tsqlParser::SNAPSHOT - 347))
          | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 347))
          | (1ULL << (tsqlParser::STATIC - 347))
          | (1ULL << (tsqlParser::STATS_STREAM - 347))
          | (1ULL << (tsqlParser::STDEV - 347))
          | (1ULL << (tsqlParser::STDEVP - 347))
          | (1ULL << (tsqlParser::STRING_AGG - 347))
          | (1ULL << (tsqlParser::STRING_SPLIT - 347))
          | (1ULL << (tsqlParser::SUM - 347)))) != 0) || ((((_la - 411) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 411)) & ((1ULL << (tsqlParser::SQRT - 411))
          | (1ULL << (tsqlParser::SQUARE - 411))
          | (1ULL << (tsqlParser::TAN - 411))
          | (1ULL << (tsqlParser::TEXTIMAGE_ON - 411))
          | (1ULL << (tsqlParser::THROW - 411))
          | (1ULL << (tsqlParser::TIES - 411))
          | (1ULL << (tsqlParser::TIME - 411))
          | (1ULL << (tsqlParser::TRY - 411))
          | (1ULL << (tsqlParser::TYPE - 411))
          | (1ULL << (tsqlParser::TYPE_WARNING - 411))
          | (1ULL << (tsqlParser::UNBOUNDED - 411))
          | (1ULL << (tsqlParser::UNCOMMITTED - 411))
          | (1ULL << (tsqlParser::UNKNOWN - 411))
          | (1ULL << (tsqlParser::USING - 411))
          | (1ULL << (tsqlParser::VAR - 411))
          | (1ULL << (tsqlParser::VARP - 411))
          | (1ULL << (tsqlParser::VIEWS - 411))
          | (1ULL << (tsqlParser::VIEW_METADATA - 411))
          | (1ULL << (tsqlParser::WORK - 411))
          | (1ULL << (tsqlParser::XML - 411))
          | (1ULL << (tsqlParser::XMLNAMESPACES - 411))
          | (1ULL << (tsqlParser::ZONE - 411))
          | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 411))
          | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 411))
          | (1ULL << (tsqlParser::LOCAL_ID - 411))
          | (1ULL << (tsqlParser::DECIMAL - 411))
          | (1ULL << (tsqlParser::ID - 411))
          | (1ULL << (tsqlParser::STRING - 411))
          | (1ULL << (tsqlParser::BINARY - 411))
          | (1ULL << (tsqlParser::FLOAT - 411))
          | (1ULL << (tsqlParser::REAL - 411))
          | (1ULL << (tsqlParser::DOLLAR - 411))
          | (1ULL << (tsqlParser::LR_BRACKET - 411)))) != 0) || ((((_la - 480) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 480)) & ((1ULL << (tsqlParser::PLUS - 480))
          | (1ULL << (tsqlParser::MINUS - 480))
          | (1ULL << (tsqlParser::BIT_NOT - 480)))) != 0)) {
          setState(2143);
          expression_list();
        }
        setState(2146);
        match(tsqlParser::RR_BRACKET);
        break;
      }

      case tsqlParser::NODES: {
        enterOuterAlt(_localctx, 2);
        setState(2148);
        match(tsqlParser::NODES);
        setState(2149);
        match(tsqlParser::LR_BRACKET);
        setState(2151);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << tsqlParser::CASE)
          | (1ULL << tsqlParser::COALESCE)
          | (1ULL << tsqlParser::CONVERT)
          | (1ULL << tsqlParser::CURRENT_TIMESTAMP)
          | (1ULL << tsqlParser::CURRENT_USER)
          | (1ULL << tsqlParser::DEFAULT))) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & ((1ULL << (tsqlParser::EXP - 66))
          | (1ULL << (tsqlParser::FORCESEEK - 66))
          | (1ULL << (tsqlParser::IDENTITY - 66))
          | (1ULL << (tsqlParser::IIF - 66))
          | (1ULL << (tsqlParser::LEFT - 66))
          | (1ULL << (tsqlParser::LOG - 66))
          | (1ULL << (tsqlParser::LOG10 - 66))
          | (1ULL << (tsqlParser::NEXT - 66))
          | (1ULL << (tsqlParser::NULL_ - 66))
          | (1ULL << (tsqlParser::NULLIF - 66))
          | (1ULL << (tsqlParser::NUMERIC - 66))
          | (1ULL << (tsqlParser::OVER - 66)))) != 0) || ((((_la - 152) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 152)) & ((1ULL << (tsqlParser::RIGHT - 152))
          | (1ULL << (tsqlParser::SESSION_USER - 152))
          | (1ULL << (tsqlParser::SIGN - 152))
          | (1ULL << (tsqlParser::SYSTEM_USER - 152))
          | (1ULL << (tsqlParser::TRY_CAST - 152))
          | (1ULL << (tsqlParser::TRY_CONVERT - 152))
          | (1ULL << (tsqlParser::TRY_PARSE - 152))
          | (1ULL << (tsqlParser::VALUE - 152))
          | (1ULL << (tsqlParser::ABSOLUTE - 152))
          | (1ULL << (tsqlParser::APPLY - 152)))) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & ((1ULL << (tsqlParser::AUTO - 217))
          | (1ULL << (tsqlParser::AVG - 217))
          | (1ULL << (tsqlParser::BASE64 - 217))
          | (1ULL << (tsqlParser::BINARY_CHECKSUM - 217))
          | (1ULL << (tsqlParser::CALLER - 217))
          | (1ULL << (tsqlParser::CAST - 217))
          | (1ULL << (tsqlParser::CATCH - 217))
          | (1ULL << (tsqlParser::CEILING - 217))
          | (1ULL << (tsqlParser::CHECKSUM - 217))
          | (1ULL << (tsqlParser::CHECKSUM_AGG - 217))
          | (1ULL << (tsqlParser::COMMITTED - 217))
          | (1ULL << (tsqlParser::CONCAT - 217))
          | (1ULL << (tsqlParser::CONTROL - 217))
          | (1ULL << (tsqlParser::COOKIE - 217))
          | (1ULL << (tsqlParser::COS - 217))
          | (1ULL << (tsqlParser::COUNT - 217))
          | (1ULL << (tsqlParser::COUNT_BIG - 217))
          | (1ULL << (tsqlParser::DATE - 217))
          | (1ULL << (tsqlParser::DATEADD - 217))
          | (1ULL << (tsqlParser::DATEDIFF - 217))
          | (1ULL << (tsqlParser::DATENAME - 217))
          | (1ULL << (tsqlParser::DATEPART - 217))
          | (1ULL << (tsqlParser::DATETIMEOFFSETFROMPARTS - 217))
          | (1ULL << (tsqlParser::DELAY - 217))
          | (1ULL << (tsqlParser::DELETED - 217))
          | (1ULL << (tsqlParser::DENSE_RANK - 217))
          | (1ULL << (tsqlParser::DISABLE - 217))
          | (1ULL << (tsqlParser::DYNAMIC - 217))
          | (1ULL << (tsqlParser::ENCRYPTION - 217))
          | (1ULL << (tsqlParser::EXIST - 217))
          | (1ULL << (tsqlParser::EXPAND - 217))
          | (1ULL << (tsqlParser::FAST - 217))
          | (1ULL << (tsqlParser::FAST_FORWARD - 217)))) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & ((1ULL << (tsqlParser::FIRST - 281))
          | (1ULL << (tsqlParser::FIRST_VALUE - 281))
          | (1ULL << (tsqlParser::FLOOR - 281))
          | (1ULL << (tsqlParser::FOLLOWING - 281))
          | (1ULL << (tsqlParser::FORCE - 281))
          | (1ULL << (tsqlParser::FORCED - 281))
          | (1ULL << (tsqlParser::FORWARD_ONLY - 281))
          | (1ULL << (tsqlParser::FULLSCAN - 281))
          | (1ULL << (tsqlParser::GLOBAL - 281))
          | (1ULL << (tsqlParser::GROUPING - 281))
          | (1ULL << (tsqlParser::GROUPING_ID - 281))
          | (1ULL << (tsqlParser::HASH - 281))
          | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 281))
          | (1ULL << (tsqlParser::IMPERSONATE - 281))
          | (1ULL << (tsqlParser::INSENSITIVE - 281))
          | (1ULL << (tsqlParser::INSERTED - 281))
          | (1ULL << (tsqlParser::ISOLATION - 281))
          | (1ULL << (tsqlParser::IO - 281))
          | (1ULL << (tsqlParser::KEEP - 281))
          | (1ULL << (tsqlParser::KEEPFIXED - 281))
          | (1ULL << (tsqlParser::KEYSET - 281))
          | (1ULL << (tsqlParser::LAG - 281))
          | (1ULL << (tsqlParser::LAST - 281))
          | (1ULL << (tsqlParser::LAST_VALUE - 281))
          | (1ULL << (tsqlParser::LEAD - 281))
          | (1ULL << (tsqlParser::LEVEL - 281))
          | (1ULL << (tsqlParser::LOCAL - 281))
          | (1ULL << (tsqlParser::LOCK_ESCALATION - 281))
          | (1ULL << (tsqlParser::LOGIN - 281))
          | (1ULL << (tsqlParser::LOOP - 281))
          | (1ULL << (tsqlParser::MARK - 281))
          | (1ULL << (tsqlParser::MAX - 281))
          | (1ULL << (tsqlParser::MAXDOP - 281))
          | (1ULL << (tsqlParser::MAXRECURSION - 281))
          | (1ULL << (tsqlParser::MIN - 281))
          | (1ULL << (tsqlParser::MIN_ACTIVE_ROWVERSION - 281))
          | (1ULL << (tsqlParser::MODIFY - 281))
          | (1ULL << (tsqlParser::NAME - 281))
          | (1ULL << (tsqlParser::NOCOUNT - 281))
          | (1ULL << (tsqlParser::NODES - 281))
          | (1ULL << (tsqlParser::NOEXPAND - 281))
          | (1ULL << (tsqlParser::NORECOMPUTE - 281))
          | (1ULL << (tsqlParser::NTILE - 281))
          | (1ULL << (tsqlParser::NUMBER - 281)))) != 0) || ((((_la - 347) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 347)) & ((1ULL << (tsqlParser::OFFSET - 347))
          | (1ULL << (tsqlParser::ONLINE - 347))
          | (1ULL << (tsqlParser::ONLY - 347))
          | (1ULL << (tsqlParser::OPTIMISTIC - 347))
          | (1ULL << (tsqlParser::OPTIMIZE - 347))
          | (1ULL << (tsqlParser::OUT - 347))
          | (1ULL << (tsqlParser::OUTPUT - 347))
          | (1ULL << (tsqlParser::OWNER - 347))
          | (1ULL << (tsqlParser::PARAMETERIZATION - 347))
          | (1ULL << (tsqlParser::PARSE - 347))
          | (1ULL << (tsqlParser::PARTITION - 347))
          | (1ULL << (tsqlParser::PATH - 347))
          | (1ULL << (tsqlParser::PERCENTILE_CONT - 347))
          | (1ULL << (tsqlParser::POWER - 347))
          | (1ULL << (tsqlParser::PRECEDING - 347))
          | (1ULL << (tsqlParser::PRIOR - 347))
          | (1ULL << (tsqlParser::PRIVILEGES - 347))
          | (1ULL << (tsqlParser::QUERY - 347))
          | (1ULL << (tsqlParser::RANGE - 347))
          | (1ULL << (tsqlParser::RANK - 347))
          | (1ULL << (tsqlParser::READONLY - 347))
          | (1ULL << (tsqlParser::READ_ONLY - 347))
          | (1ULL << (tsqlParser::RECOMPILE - 347))
          | (1ULL << (tsqlParser::RELATIVE - 347))
          | (1ULL << (tsqlParser::REMOTE - 347))
          | (1ULL << (tsqlParser::REPEATABLE - 347))
          | (1ULL << (tsqlParser::ROBUST - 347))
          | (1ULL << (tsqlParser::ROOT - 347))
          | (1ULL << (tsqlParser::ROUND - 347))
          | (1ULL << (tsqlParser::ROW - 347))
          | (1ULL << (tsqlParser::ROWGUID - 347))
          | (1ULL << (tsqlParser::ROWS - 347))
          | (1ULL << (tsqlParser::ROW_NUMBER - 347))
          | (1ULL << (tsqlParser::SAMPLE - 347))
          | (1ULL << (tsqlParser::SCHEMABINDING - 347))
          | (1ULL << (tsqlParser::SCROLL - 347))
          | (1ULL << (tsqlParser::SCROLL_LOCKS - 347))
          | (1ULL << (tsqlParser::SELF - 347))
          | (1ULL << (tsqlParser::SERIALIZABLE - 347))
          | (1ULL << (tsqlParser::SIMPLE - 347))
          | (1ULL << (tsqlParser::SIN - 347))
          | (1ULL << (tsqlParser::SIZE - 347))
          | (1ULL << (tsqlParser::SNAPSHOT - 347))
          | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 347))
          | (1ULL << (tsqlParser::STATIC - 347))
          | (1ULL << (tsqlParser::STATS_STREAM - 347))
          | (1ULL << (tsqlParser::STDEV - 347))
          | (1ULL << (tsqlParser::STDEVP - 347))
          | (1ULL << (tsqlParser::STRING_AGG - 347))
          | (1ULL << (tsqlParser::STRING_SPLIT - 347))
          | (1ULL << (tsqlParser::SUM - 347)))) != 0) || ((((_la - 411) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 411)) & ((1ULL << (tsqlParser::SQRT - 411))
          | (1ULL << (tsqlParser::SQUARE - 411))
          | (1ULL << (tsqlParser::TAN - 411))
          | (1ULL << (tsqlParser::TEXTIMAGE_ON - 411))
          | (1ULL << (tsqlParser::THROW - 411))
          | (1ULL << (tsqlParser::TIES - 411))
          | (1ULL << (tsqlParser::TIME - 411))
          | (1ULL << (tsqlParser::TRY - 411))
          | (1ULL << (tsqlParser::TYPE - 411))
          | (1ULL << (tsqlParser::TYPE_WARNING - 411))
          | (1ULL << (tsqlParser::UNBOUNDED - 411))
          | (1ULL << (tsqlParser::UNCOMMITTED - 411))
          | (1ULL << (tsqlParser::UNKNOWN - 411))
          | (1ULL << (tsqlParser::USING - 411))
          | (1ULL << (tsqlParser::VAR - 411))
          | (1ULL << (tsqlParser::VARP - 411))
          | (1ULL << (tsqlParser::VIEWS - 411))
          | (1ULL << (tsqlParser::VIEW_METADATA - 411))
          | (1ULL << (tsqlParser::WORK - 411))
          | (1ULL << (tsqlParser::XML - 411))
          | (1ULL << (tsqlParser::XMLNAMESPACES - 411))
          | (1ULL << (tsqlParser::ZONE - 411))
          | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 411))
          | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 411))
          | (1ULL << (tsqlParser::LOCAL_ID - 411))
          | (1ULL << (tsqlParser::DECIMAL - 411))
          | (1ULL << (tsqlParser::ID - 411))
          | (1ULL << (tsqlParser::STRING - 411))
          | (1ULL << (tsqlParser::BINARY - 411))
          | (1ULL << (tsqlParser::FLOAT - 411))
          | (1ULL << (tsqlParser::REAL - 411))
          | (1ULL << (tsqlParser::DOLLAR - 411))
          | (1ULL << (tsqlParser::LR_BRACKET - 411)))) != 0) || ((((_la - 480) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 480)) & ((1ULL << (tsqlParser::PLUS - 480))
          | (1ULL << (tsqlParser::MINUS - 480))
          | (1ULL << (tsqlParser::BIT_NOT - 480)))) != 0)) {
          setState(2150);
          expression_list();
        }
        setState(2153);
        match(tsqlParser::RR_BRACKET);
        setState(2154);
        match(tsqlParser::AS);
        setState(2155);
        dynamic_cast<Xml_method_callContext *>(_localctx)->table = r_id();
        setState(2156);
        match(tsqlParser::LR_BRACKET);
        setState(2157);
        dynamic_cast<Xml_method_callContext *>(_localctx)->column = r_id();
        setState(2158);
        match(tsqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_xml_method_nameContext ------------------------------------------------------------------

tsqlParser::Simple_xml_method_nameContext::Simple_xml_method_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Simple_xml_method_nameContext::QUERY() {
  return getToken(tsqlParser::QUERY, 0);
}

tree::TerminalNode* tsqlParser::Simple_xml_method_nameContext::VALUE() {
  return getToken(tsqlParser::VALUE, 0);
}

tree::TerminalNode* tsqlParser::Simple_xml_method_nameContext::EXIST() {
  return getToken(tsqlParser::EXIST, 0);
}


size_t tsqlParser::Simple_xml_method_nameContext::getRuleIndex() const {
  return tsqlParser::RuleSimple_xml_method_name;
}


antlrcpp::Any tsqlParser::Simple_xml_method_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSimple_xml_method_name(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Simple_xml_method_nameContext* tsqlParser::simple_xml_method_name() {
  Simple_xml_method_nameContext *_localctx = _tracker.createInstance<Simple_xml_method_nameContext>(_ctx, getState());
  enterRule(_localctx, 210, tsqlParser::RuleSimple_xml_method_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2162);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::VALUE || _la == tsqlParser::EXIST || _la == tsqlParser::QUERY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_expressionContext ------------------------------------------------------------------

tsqlParser::Constant_expressionContext::Constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Constant_expressionContext::NULL_() {
  return getToken(tsqlParser::NULL_, 0);
}

tsqlParser::ConstantContext* tsqlParser::Constant_expressionContext::constant() {
  return getRuleContext<tsqlParser::ConstantContext>(0);
}

tsqlParser::Function_callContext* tsqlParser::Constant_expressionContext::function_call() {
  return getRuleContext<tsqlParser::Function_callContext>(0);
}

tree::TerminalNode* tsqlParser::Constant_expressionContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* tsqlParser::Constant_expressionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Constant_expressionContext* tsqlParser::Constant_expressionContext::constant_expression() {
  return getRuleContext<tsqlParser::Constant_expressionContext>(0);
}

tree::TerminalNode* tsqlParser::Constant_expressionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}


size_t tsqlParser::Constant_expressionContext::getRuleIndex() const {
  return tsqlParser::RuleConstant_expression;
}


antlrcpp::Any tsqlParser::Constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitConstant_expression(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Constant_expressionContext* tsqlParser::constant_expression() {
  Constant_expressionContext *_localctx = _tracker.createInstance<Constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 212, tsqlParser::RuleConstant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2172);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::NULL_: {
        enterOuterAlt(_localctx, 1);
        setState(2164);
        match(tsqlParser::NULL_);
        break;
      }

      case tsqlParser::DECIMAL:
      case tsqlParser::STRING:
      case tsqlParser::BINARY:
      case tsqlParser::FLOAT:
      case tsqlParser::REAL:
      case tsqlParser::DOLLAR:
      case tsqlParser::PLUS:
      case tsqlParser::MINUS: {
        enterOuterAlt(_localctx, 2);
        setState(2165);
        constant();
        break;
      }

      case tsqlParser::COALESCE:
      case tsqlParser::CONVERT:
      case tsqlParser::CURRENT_TIMESTAMP:
      case tsqlParser::CURRENT_USER:
      case tsqlParser::EXP:
      case tsqlParser::FORCESEEK:
      case tsqlParser::IDENTITY:
      case tsqlParser::IIF:
      case tsqlParser::LEFT:
      case tsqlParser::LOG:
      case tsqlParser::LOG10:
      case tsqlParser::NEXT:
      case tsqlParser::NULLIF:
      case tsqlParser::NUMERIC:
      case tsqlParser::RIGHT:
      case tsqlParser::SESSION_USER:
      case tsqlParser::SIGN:
      case tsqlParser::SYSTEM_USER:
      case tsqlParser::TRY_CAST:
      case tsqlParser::TRY_CONVERT:
      case tsqlParser::TRY_PARSE:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::BINARY_CHECKSUM:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CEILING:
      case tsqlParser::CHECKSUM:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COS:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DATEADD:
      case tsqlParser::DATEDIFF:
      case tsqlParser::DATENAME:
      case tsqlParser::DATEPART:
      case tsqlParser::DATETIMEOFFSETFROMPARTS:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FLOOR:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MIN_ACTIVE_ROWVERSION:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARSE:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::POWER:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROUND:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIN:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::STRING_SPLIT:
      case tsqlParser::SUM:
      case tsqlParser::SQRT:
      case tsqlParser::SQUARE:
      case tsqlParser::TAN:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        enterOuterAlt(_localctx, 3);
        setState(2166);
        function_call();
        break;
      }

      case tsqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 4);
        setState(2167);
        match(tsqlParser::LOCAL_ID);
        break;
      }

      case tsqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 5);
        setState(2168);
        match(tsqlParser::LR_BRACKET);
        setState(2169);
        constant_expression();
        setState(2170);
        match(tsqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubqueryContext ------------------------------------------------------------------

tsqlParser::SubqueryContext::SubqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Select_statementContext* tsqlParser::SubqueryContext::select_statement() {
  return getRuleContext<tsqlParser::Select_statementContext>(0);
}


size_t tsqlParser::SubqueryContext::getRuleIndex() const {
  return tsqlParser::RuleSubquery;
}


antlrcpp::Any tsqlParser::SubqueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSubquery(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::SubqueryContext* tsqlParser::subquery() {
  SubqueryContext *_localctx = _tracker.createInstance<SubqueryContext>(_ctx, getState());
  enterRule(_localctx, 214, tsqlParser::RuleSubquery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2174);
    select_statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_expressionContext ------------------------------------------------------------------

tsqlParser::With_expressionContext::With_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::With_expressionContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

std::vector<tsqlParser::Common_table_expressionContext *> tsqlParser::With_expressionContext::common_table_expression() {
  return getRuleContexts<tsqlParser::Common_table_expressionContext>();
}

tsqlParser::Common_table_expressionContext* tsqlParser::With_expressionContext::common_table_expression(size_t i) {
  return getRuleContext<tsqlParser::Common_table_expressionContext>(i);
}

tree::TerminalNode* tsqlParser::With_expressionContext::XMLNAMESPACES() {
  return getToken(tsqlParser::XMLNAMESPACES, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::With_expressionContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::With_expressionContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::With_expressionContext::getRuleIndex() const {
  return tsqlParser::RuleWith_expression;
}


antlrcpp::Any tsqlParser::With_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitWith_expression(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::With_expressionContext* tsqlParser::with_expression() {
  With_expressionContext *_localctx = _tracker.createInstance<With_expressionContext>(_ctx, getState());
  enterRule(_localctx, 216, tsqlParser::RuleWith_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2176);
    match(tsqlParser::WITH);
    setState(2179);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 314, _ctx)) {
    case 1: {
      setState(2177);
      match(tsqlParser::XMLNAMESPACES);
      setState(2178);
      match(tsqlParser::COMMA);
      break;
    }

    default:
      break;
    }
    setState(2181);
    common_table_expression();
    setState(2186);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(2182);
      match(tsqlParser::COMMA);
      setState(2183);
      common_table_expression();
      setState(2188);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_table_expressionContext ------------------------------------------------------------------

tsqlParser::Common_table_expressionContext::Common_table_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Common_table_expressionContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Common_table_expressionContext::LR_BRACKET() {
  return getTokens(tsqlParser::LR_BRACKET);
}

tree::TerminalNode* tsqlParser::Common_table_expressionContext::LR_BRACKET(size_t i) {
  return getToken(tsqlParser::LR_BRACKET, i);
}

tsqlParser::Select_statementContext* tsqlParser::Common_table_expressionContext::select_statement() {
  return getRuleContext<tsqlParser::Select_statementContext>(0);
}

std::vector<tree::TerminalNode *> tsqlParser::Common_table_expressionContext::RR_BRACKET() {
  return getTokens(tsqlParser::RR_BRACKET);
}

tree::TerminalNode* tsqlParser::Common_table_expressionContext::RR_BRACKET(size_t i) {
  return getToken(tsqlParser::RR_BRACKET, i);
}

tsqlParser::R_idContext* tsqlParser::Common_table_expressionContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tsqlParser::Column_name_listContext* tsqlParser::Common_table_expressionContext::column_name_list() {
  return getRuleContext<tsqlParser::Column_name_listContext>(0);
}


size_t tsqlParser::Common_table_expressionContext::getRuleIndex() const {
  return tsqlParser::RuleCommon_table_expression;
}


antlrcpp::Any tsqlParser::Common_table_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCommon_table_expression(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Common_table_expressionContext* tsqlParser::common_table_expression() {
  Common_table_expressionContext *_localctx = _tracker.createInstance<Common_table_expressionContext>(_ctx, getState());
  enterRule(_localctx, 218, tsqlParser::RuleCommon_table_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2189);
    dynamic_cast<Common_table_expressionContext *>(_localctx)->expression_name = r_id();
    setState(2194);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::LR_BRACKET) {
      setState(2190);
      match(tsqlParser::LR_BRACKET);
      setState(2191);
      column_name_list();
      setState(2192);
      match(tsqlParser::RR_BRACKET);
    }
    setState(2196);
    match(tsqlParser::AS);
    setState(2197);
    match(tsqlParser::LR_BRACKET);
    setState(2198);
    select_statement();
    setState(2199);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_elemContext ------------------------------------------------------------------

tsqlParser::Update_elemContext::Update_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::ExpressionContext* tsqlParser::Update_elemContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tsqlParser::Full_column_nameContext* tsqlParser::Update_elemContext::full_column_name() {
  return getRuleContext<tsqlParser::Full_column_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Update_elemContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tsqlParser::Assignment_operatorContext* tsqlParser::Update_elemContext::assignment_operator() {
  return getRuleContext<tsqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* tsqlParser::Update_elemContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* tsqlParser::Update_elemContext::DOT() {
  return getToken(tsqlParser::DOT, 0);
}

tree::TerminalNode* tsqlParser::Update_elemContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Expression_listContext* tsqlParser::Update_elemContext::expression_list() {
  return getRuleContext<tsqlParser::Expression_listContext>(0);
}

tree::TerminalNode* tsqlParser::Update_elemContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Update_elemContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Update_elemContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}


size_t tsqlParser::Update_elemContext::getRuleIndex() const {
  return tsqlParser::RuleUpdate_elem;
}


antlrcpp::Any tsqlParser::Update_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitUpdate_elem(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Update_elemContext* tsqlParser::update_elem() {
  Update_elemContext *_localctx = _tracker.createInstance<Update_elemContext>(_ctx, getState());
  enterRule(_localctx, 220, tsqlParser::RuleUpdate_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2217);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2203);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case tsqlParser::FORCESEEK:
        case tsqlParser::NEXT:
        case tsqlParser::NUMERIC:
        case tsqlParser::VALUE:
        case tsqlParser::ABSOLUTE:
        case tsqlParser::APPLY:
        case tsqlParser::AUTO:
        case tsqlParser::AVG:
        case tsqlParser::BASE64:
        case tsqlParser::CALLER:
        case tsqlParser::CAST:
        case tsqlParser::CATCH:
        case tsqlParser::CHECKSUM_AGG:
        case tsqlParser::COMMITTED:
        case tsqlParser::CONCAT:
        case tsqlParser::CONTROL:
        case tsqlParser::COOKIE:
        case tsqlParser::COUNT:
        case tsqlParser::COUNT_BIG:
        case tsqlParser::DATE:
        case tsqlParser::DELAY:
        case tsqlParser::DELETED:
        case tsqlParser::DENSE_RANK:
        case tsqlParser::DISABLE:
        case tsqlParser::DYNAMIC:
        case tsqlParser::ENCRYPTION:
        case tsqlParser::EXIST:
        case tsqlParser::EXPAND:
        case tsqlParser::FAST:
        case tsqlParser::FAST_FORWARD:
        case tsqlParser::FIRST:
        case tsqlParser::FIRST_VALUE:
        case tsqlParser::FOLLOWING:
        case tsqlParser::FORCE:
        case tsqlParser::FORCED:
        case tsqlParser::FORWARD_ONLY:
        case tsqlParser::FULLSCAN:
        case tsqlParser::GLOBAL:
        case tsqlParser::GROUPING:
        case tsqlParser::GROUPING_ID:
        case tsqlParser::HASH:
        case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
        case tsqlParser::IMPERSONATE:
        case tsqlParser::INSENSITIVE:
        case tsqlParser::INSERTED:
        case tsqlParser::ISOLATION:
        case tsqlParser::IO:
        case tsqlParser::KEEP:
        case tsqlParser::KEEPFIXED:
        case tsqlParser::KEYSET:
        case tsqlParser::LAG:
        case tsqlParser::LAST:
        case tsqlParser::LAST_VALUE:
        case tsqlParser::LEAD:
        case tsqlParser::LEVEL:
        case tsqlParser::LOCAL:
        case tsqlParser::LOCK_ESCALATION:
        case tsqlParser::LOGIN:
        case tsqlParser::LOOP:
        case tsqlParser::MARK:
        case tsqlParser::MAX:
        case tsqlParser::MAXDOP:
        case tsqlParser::MAXRECURSION:
        case tsqlParser::MIN:
        case tsqlParser::MODIFY:
        case tsqlParser::NAME:
        case tsqlParser::NOCOUNT:
        case tsqlParser::NODES:
        case tsqlParser::NOEXPAND:
        case tsqlParser::NORECOMPUTE:
        case tsqlParser::NTILE:
        case tsqlParser::NUMBER:
        case tsqlParser::OFFSET:
        case tsqlParser::ONLINE:
        case tsqlParser::ONLY:
        case tsqlParser::OPTIMISTIC:
        case tsqlParser::OPTIMIZE:
        case tsqlParser::OUT:
        case tsqlParser::OUTPUT:
        case tsqlParser::OWNER:
        case tsqlParser::PARAMETERIZATION:
        case tsqlParser::PARTITION:
        case tsqlParser::PATH:
        case tsqlParser::PRECEDING:
        case tsqlParser::PRIOR:
        case tsqlParser::PRIVILEGES:
        case tsqlParser::QUERY:
        case tsqlParser::RANGE:
        case tsqlParser::RANK:
        case tsqlParser::READONLY:
        case tsqlParser::READ_ONLY:
        case tsqlParser::RECOMPILE:
        case tsqlParser::RELATIVE:
        case tsqlParser::REMOTE:
        case tsqlParser::REPEATABLE:
        case tsqlParser::ROBUST:
        case tsqlParser::ROOT:
        case tsqlParser::ROW:
        case tsqlParser::ROWGUID:
        case tsqlParser::ROWS:
        case tsqlParser::ROW_NUMBER:
        case tsqlParser::SAMPLE:
        case tsqlParser::SCHEMABINDING:
        case tsqlParser::SCROLL:
        case tsqlParser::SCROLL_LOCKS:
        case tsqlParser::SELF:
        case tsqlParser::SERIALIZABLE:
        case tsqlParser::SIMPLE:
        case tsqlParser::SIZE:
        case tsqlParser::SNAPSHOT:
        case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case tsqlParser::STATIC:
        case tsqlParser::STATS_STREAM:
        case tsqlParser::STDEV:
        case tsqlParser::STDEVP:
        case tsqlParser::SUM:
        case tsqlParser::TEXTIMAGE_ON:
        case tsqlParser::THROW:
        case tsqlParser::TIES:
        case tsqlParser::TIME:
        case tsqlParser::TRY:
        case tsqlParser::TYPE:
        case tsqlParser::TYPE_WARNING:
        case tsqlParser::UNBOUNDED:
        case tsqlParser::UNCOMMITTED:
        case tsqlParser::UNKNOWN:
        case tsqlParser::USING:
        case tsqlParser::VAR:
        case tsqlParser::VARP:
        case tsqlParser::VIEWS:
        case tsqlParser::VIEW_METADATA:
        case tsqlParser::WORK:
        case tsqlParser::XML:
        case tsqlParser::XMLNAMESPACES:
        case tsqlParser::ZONE:
        case tsqlParser::DOUBLE_QUOTE_ID:
        case tsqlParser::SQUARE_BRACKET_ID:
        case tsqlParser::ID: {
          setState(2201);
          full_column_name();
          break;
        }

        case tsqlParser::LOCAL_ID: {
          setState(2202);
          dynamic_cast<Update_elemContext *>(_localctx)->name = match(tsqlParser::LOCAL_ID);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2207);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case tsqlParser::EQUAL: {
          setState(2205);
          match(tsqlParser::EQUAL);
          break;
        }

        case tsqlParser::PLUS_ASSIGN:
        case tsqlParser::MINUS_ASSIGN:
        case tsqlParser::MULT_ASSIGN:
        case tsqlParser::DIV_ASSIGN:
        case tsqlParser::MOD_ASSIGN:
        case tsqlParser::AND_ASSIGN:
        case tsqlParser::XOR_ASSIGN:
        case tsqlParser::OR_ASSIGN: {
          setState(2206);
          assignment_operator();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2209);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2210);
      dynamic_cast<Update_elemContext *>(_localctx)->udt_column_name = r_id();
      setState(2211);
      match(tsqlParser::DOT);
      setState(2212);
      dynamic_cast<Update_elemContext *>(_localctx)->method_name = r_id();
      setState(2213);
      match(tsqlParser::LR_BRACKET);
      setState(2214);
      expression_list();
      setState(2215);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Search_condition_listContext ------------------------------------------------------------------

tsqlParser::Search_condition_listContext::Search_condition_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::Search_conditionContext *> tsqlParser::Search_condition_listContext::search_condition() {
  return getRuleContexts<tsqlParser::Search_conditionContext>();
}

tsqlParser::Search_conditionContext* tsqlParser::Search_condition_listContext::search_condition(size_t i) {
  return getRuleContext<tsqlParser::Search_conditionContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Search_condition_listContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Search_condition_listContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Search_condition_listContext::getRuleIndex() const {
  return tsqlParser::RuleSearch_condition_list;
}


antlrcpp::Any tsqlParser::Search_condition_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSearch_condition_list(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Search_condition_listContext* tsqlParser::search_condition_list() {
  Search_condition_listContext *_localctx = _tracker.createInstance<Search_condition_listContext>(_ctx, getState());
  enterRule(_localctx, 222, tsqlParser::RuleSearch_condition_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2219);
    search_condition(0);
    setState(2224);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(2220);
      match(tsqlParser::COMMA);
      setState(2221);
      search_condition(0);
      setState(2226);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Search_conditionContext ------------------------------------------------------------------

tsqlParser::Search_conditionContext::Search_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t tsqlParser::Search_conditionContext::getRuleIndex() const {
  return tsqlParser::RuleSearch_condition;
}

void tsqlParser::Search_conditionContext::copyFrom(Search_conditionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Search_cond_orContext ------------------------------------------------------------------

std::vector<tsqlParser::Search_conditionContext *> tsqlParser::Search_cond_orContext::search_condition() {
  return getRuleContexts<tsqlParser::Search_conditionContext>();
}

tsqlParser::Search_conditionContext* tsqlParser::Search_cond_orContext::search_condition(size_t i) {
  return getRuleContext<tsqlParser::Search_conditionContext>(i);
}

tree::TerminalNode* tsqlParser::Search_cond_orContext::OR() {
  return getToken(tsqlParser::OR, 0);
}

tsqlParser::Search_cond_orContext::Search_cond_orContext(Search_conditionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Search_cond_orContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSearch_cond_or(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Search_cond_predContext ------------------------------------------------------------------

tsqlParser::PredicateContext* tsqlParser::Search_cond_predContext::predicate() {
  return getRuleContext<tsqlParser::PredicateContext>(0);
}

tsqlParser::Search_cond_predContext::Search_cond_predContext(Search_conditionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Search_cond_predContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSearch_cond_pred(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Search_cond_andContext ------------------------------------------------------------------

std::vector<tsqlParser::Search_conditionContext *> tsqlParser::Search_cond_andContext::search_condition() {
  return getRuleContexts<tsqlParser::Search_conditionContext>();
}

tsqlParser::Search_conditionContext* tsqlParser::Search_cond_andContext::search_condition(size_t i) {
  return getRuleContext<tsqlParser::Search_conditionContext>(i);
}

tree::TerminalNode* tsqlParser::Search_cond_andContext::AND() {
  return getToken(tsqlParser::AND, 0);
}

tsqlParser::Search_cond_andContext::Search_cond_andContext(Search_conditionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Search_cond_andContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSearch_cond_and(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Search_conditionContext* tsqlParser::search_condition() {
   return search_condition(0);
}

tsqlParser::Search_conditionContext* tsqlParser::search_condition(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  tsqlParser::Search_conditionContext *_localctx = _tracker.createInstance<Search_conditionContext>(_ctx, parentState);
  tsqlParser::Search_conditionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 224;
  enterRecursionRule(_localctx, 224, tsqlParser::RuleSearch_condition, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    _localctx = _tracker.createInstance<Search_cond_predContext>(_localctx);
    _ctx = _localctx;
    previousContext = _localctx;

    setState(2228);
    predicate();
    _ctx->stop = _input->LT(-1);
    setState(2238);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(2236);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<Search_cond_andContext>(_tracker.createInstance<Search_conditionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleSearch_condition);
          setState(2230);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(2231);
          dynamic_cast<Search_cond_andContext *>(_localctx)->op = match(tsqlParser::AND);
          setState(2232);
          dynamic_cast<Search_cond_andContext *>(_localctx)->right = search_condition(4);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<Search_cond_orContext>(_tracker.createInstance<Search_conditionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleSearch_condition);
          setState(2233);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(2234);
          dynamic_cast<Search_cond_orContext *>(_localctx)->op = match(tsqlParser::OR);
          setState(2235);
          dynamic_cast<Search_cond_orContext *>(_localctx)->right = search_condition(3);
          break;
        }

        default:
          break;
        } 
      }
      setState(2240);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

tsqlParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t tsqlParser::PredicateContext::getRuleIndex() const {
  return tsqlParser::RulePredicate;
}

void tsqlParser::PredicateContext::copyFrom(PredicateContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Binary_in_expressionContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Binary_in_expressionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Binary_in_expressionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Binary_in_expressionContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Binary_in_expressionContext::IN() {
  return getToken(tsqlParser::IN, 0);
}

tsqlParser::SubqueryContext* tsqlParser::Binary_in_expressionContext::subquery() {
  return getRuleContext<tsqlParser::SubqueryContext>(0);
}

tsqlParser::Expression_listContext* tsqlParser::Binary_in_expressionContext::expression_list() {
  return getRuleContext<tsqlParser::Expression_listContext>(0);
}

tree::TerminalNode* tsqlParser::Binary_in_expressionContext::NOT() {
  return getToken(tsqlParser::NOT, 0);
}

tsqlParser::Binary_in_expressionContext::Binary_in_expressionContext(PredicateContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Binary_in_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBinary_in_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Unary_operator_expression2Context ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Unary_operator_expression2Context::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Unary_operator_expression2Context::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Unary_operator_expression2Context::EXISTS() {
  return getToken(tsqlParser::EXISTS, 0);
}

tsqlParser::SubqueryContext* tsqlParser::Unary_operator_expression2Context::subquery() {
  return getRuleContext<tsqlParser::SubqueryContext>(0);
}

tsqlParser::Unary_operator_expression2Context::Unary_operator_expression2Context(PredicateContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Unary_operator_expression2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitUnary_operator_expression2(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Binary_mod_expressionContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Binary_mod_expressionContext::AND() {
  return getToken(tsqlParser::AND, 0);
}

std::vector<tsqlParser::ExpressionContext *> tsqlParser::Binary_mod_expressionContext::expression() {
  return getRuleContexts<tsqlParser::ExpressionContext>();
}

tsqlParser::ExpressionContext* tsqlParser::Binary_mod_expressionContext::expression(size_t i) {
  return getRuleContext<tsqlParser::ExpressionContext>(i);
}

tree::TerminalNode* tsqlParser::Binary_mod_expressionContext::BETWEEN() {
  return getToken(tsqlParser::BETWEEN, 0);
}

tree::TerminalNode* tsqlParser::Binary_mod_expressionContext::NOT() {
  return getToken(tsqlParser::NOT, 0);
}

tree::TerminalNode* tsqlParser::Binary_mod_expressionContext::LIKE() {
  return getToken(tsqlParser::LIKE, 0);
}

tree::TerminalNode* tsqlParser::Binary_mod_expressionContext::ESCAPE() {
  return getToken(tsqlParser::ESCAPE, 0);
}

tsqlParser::Binary_mod_expressionContext::Binary_mod_expressionContext(PredicateContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Binary_mod_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBinary_mod_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Unary_operator_expression3Context ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Unary_operator_expression3Context::NOT() {
  return getToken(tsqlParser::NOT, 0);
}

tsqlParser::PredicateContext* tsqlParser::Unary_operator_expression3Context::predicate() {
  return getRuleContext<tsqlParser::PredicateContext>(0);
}

tsqlParser::Unary_operator_expression3Context::Unary_operator_expression3Context(PredicateContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Unary_operator_expression3Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitUnary_operator_expression3(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bracket_search_expressionContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Bracket_search_expressionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Search_conditionContext* tsqlParser::Bracket_search_expressionContext::search_condition() {
  return getRuleContext<tsqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* tsqlParser::Bracket_search_expressionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::Bracket_search_expressionContext::Bracket_search_expressionContext(PredicateContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Bracket_search_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBracket_search_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Sublink_expressionContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Sublink_expressionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::SubqueryContext* tsqlParser::Sublink_expressionContext::subquery() {
  return getRuleContext<tsqlParser::SubqueryContext>(0);
}

tree::TerminalNode* tsqlParser::Sublink_expressionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Sublink_expressionContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tsqlParser::Comparison_operatorContext* tsqlParser::Sublink_expressionContext::comparison_operator() {
  return getRuleContext<tsqlParser::Comparison_operatorContext>(0);
}

tree::TerminalNode* tsqlParser::Sublink_expressionContext::ALL() {
  return getToken(tsqlParser::ALL, 0);
}

tree::TerminalNode* tsqlParser::Sublink_expressionContext::SOME() {
  return getToken(tsqlParser::SOME, 0);
}

tree::TerminalNode* tsqlParser::Sublink_expressionContext::ANY() {
  return getToken(tsqlParser::ANY, 0);
}

tsqlParser::Sublink_expressionContext::Sublink_expressionContext(PredicateContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Sublink_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSublink_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Binary_operator_expression3Context ------------------------------------------------------------------

tsqlParser::ExpressionContext* tsqlParser::Binary_operator_expression3Context::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Binary_operator_expression3Context::IS() {
  return getToken(tsqlParser::IS, 0);
}

tsqlParser::Null_notnullContext* tsqlParser::Binary_operator_expression3Context::null_notnull() {
  return getRuleContext<tsqlParser::Null_notnullContext>(0);
}

tsqlParser::Binary_operator_expression3Context::Binary_operator_expression3Context(PredicateContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Binary_operator_expression3Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBinary_operator_expression3(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Binary_operator_expression2Context ------------------------------------------------------------------

std::vector<tsqlParser::ExpressionContext *> tsqlParser::Binary_operator_expression2Context::expression() {
  return getRuleContexts<tsqlParser::ExpressionContext>();
}

tsqlParser::ExpressionContext* tsqlParser::Binary_operator_expression2Context::expression(size_t i) {
  return getRuleContext<tsqlParser::ExpressionContext>(i);
}

tsqlParser::Comparison_operatorContext* tsqlParser::Binary_operator_expression2Context::comparison_operator() {
  return getRuleContext<tsqlParser::Comparison_operatorContext>(0);
}

tsqlParser::Binary_operator_expression2Context::Binary_operator_expression2Context(PredicateContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Binary_operator_expression2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBinary_operator_expression2(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decimal_expressionContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Decimal_expressionContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tsqlParser::Decimal_expressionContext::Decimal_expressionContext(PredicateContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Decimal_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDecimal_expression(this);
  else
    return visitor->visitChildren(this);
}
tsqlParser::PredicateContext* tsqlParser::predicate() {
  PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
  enterRule(_localctx, 226, tsqlParser::RulePredicate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2299);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx)) {
    case 1: {
      _localctx = dynamic_cast<PredicateContext *>(_tracker.createInstance<tsqlParser::Unary_operator_expression3Context>(_localctx));
      enterOuterAlt(_localctx, 1);
      setState(2241);
      dynamic_cast<Unary_operator_expression3Context *>(_localctx)->op = match(tsqlParser::NOT);
      setState(2242);
      dynamic_cast<Unary_operator_expression3Context *>(_localctx)->expr = predicate();
      break;
    }

    case 2: {
      _localctx = dynamic_cast<PredicateContext *>(_tracker.createInstance<tsqlParser::Unary_operator_expression2Context>(_localctx));
      enterOuterAlt(_localctx, 2);
      setState(2243);
      dynamic_cast<Unary_operator_expression2Context *>(_localctx)->op = match(tsqlParser::EXISTS);
      setState(2244);
      match(tsqlParser::LR_BRACKET);
      setState(2245);
      dynamic_cast<Unary_operator_expression2Context *>(_localctx)->expr = subquery();
      setState(2246);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      _localctx = dynamic_cast<PredicateContext *>(_tracker.createInstance<tsqlParser::Binary_operator_expression2Context>(_localctx));
      enterOuterAlt(_localctx, 3);
      setState(2248);
      dynamic_cast<Binary_operator_expression2Context *>(_localctx)->left = expression(0);
      setState(2249);
      dynamic_cast<Binary_operator_expression2Context *>(_localctx)->op = comparison_operator();
      setState(2250);
      dynamic_cast<Binary_operator_expression2Context *>(_localctx)->right = expression(0);
      break;
    }

    case 4: {
      _localctx = dynamic_cast<PredicateContext *>(_tracker.createInstance<tsqlParser::Sublink_expressionContext>(_localctx));
      enterOuterAlt(_localctx, 4);
      setState(2252);
      dynamic_cast<Sublink_expressionContext *>(_localctx)->test_expr = expression(0);
      setState(2253);
      dynamic_cast<Sublink_expressionContext *>(_localctx)->op = comparison_operator();
      setState(2254);
      dynamic_cast<Sublink_expressionContext *>(_localctx)->pref = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::ALL

      || _la == tsqlParser::ANY || _la == tsqlParser::SOME)) {
        dynamic_cast<Sublink_expressionContext *>(_localctx)->pref = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2255);
      match(tsqlParser::LR_BRACKET);
      setState(2256);
      subquery();
      setState(2257);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 5: {
      _localctx = dynamic_cast<PredicateContext *>(_tracker.createInstance<tsqlParser::Binary_mod_expressionContext>(_localctx));
      enterOuterAlt(_localctx, 5);
      setState(2259);
      dynamic_cast<Binary_mod_expressionContext *>(_localctx)->left = expression(0);
      setState(2261);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::NOT) {
        setState(2260);
        match(tsqlParser::NOT);
      }
      setState(2263);
      dynamic_cast<Binary_mod_expressionContext *>(_localctx)->op = match(tsqlParser::BETWEEN);
      setState(2264);
      dynamic_cast<Binary_mod_expressionContext *>(_localctx)->right_1 = expression(0);
      setState(2265);
      match(tsqlParser::AND);
      setState(2266);
      dynamic_cast<Binary_mod_expressionContext *>(_localctx)->right_2 = expression(0);
      break;
    }

    case 6: {
      _localctx = dynamic_cast<PredicateContext *>(_tracker.createInstance<tsqlParser::Binary_in_expressionContext>(_localctx));
      enterOuterAlt(_localctx, 6);
      setState(2268);
      dynamic_cast<Binary_in_expressionContext *>(_localctx)->left = expression(0);
      setState(2270);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::NOT) {
        setState(2269);
        match(tsqlParser::NOT);
      }
      setState(2272);
      dynamic_cast<Binary_in_expressionContext *>(_localctx)->op = match(tsqlParser::IN);
      setState(2273);
      match(tsqlParser::LR_BRACKET);
      setState(2276);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 325, _ctx)) {
      case 1: {
        setState(2274);
        subquery();
        break;
      }

      case 2: {
        setState(2275);
        expression_list();
        break;
      }

      default:
        break;
      }
      setState(2278);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 7: {
      _localctx = dynamic_cast<PredicateContext *>(_tracker.createInstance<tsqlParser::Binary_mod_expressionContext>(_localctx));
      enterOuterAlt(_localctx, 7);
      setState(2280);
      dynamic_cast<Binary_mod_expressionContext *>(_localctx)->left = expression(0);
      setState(2282);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::NOT) {
        setState(2281);
        match(tsqlParser::NOT);
      }
      setState(2284);
      dynamic_cast<Binary_mod_expressionContext *>(_localctx)->op = match(tsqlParser::LIKE);
      setState(2285);
      dynamic_cast<Binary_mod_expressionContext *>(_localctx)->right_1 = expression(0);
      setState(2288);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 327, _ctx)) {
      case 1: {
        setState(2286);
        match(tsqlParser::ESCAPE);
        setState(2287);
        dynamic_cast<Binary_mod_expressionContext *>(_localctx)->right_2 = expression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 8: {
      _localctx = dynamic_cast<PredicateContext *>(_tracker.createInstance<tsqlParser::Binary_operator_expression3Context>(_localctx));
      enterOuterAlt(_localctx, 8);
      setState(2290);
      dynamic_cast<Binary_operator_expression3Context *>(_localctx)->left = expression(0);
      setState(2291);
      dynamic_cast<Binary_operator_expression3Context *>(_localctx)->op = match(tsqlParser::IS);
      setState(2292);
      dynamic_cast<Binary_operator_expression3Context *>(_localctx)->right = null_notnull();
      break;
    }

    case 9: {
      _localctx = dynamic_cast<PredicateContext *>(_tracker.createInstance<tsqlParser::Bracket_search_expressionContext>(_localctx));
      enterOuterAlt(_localctx, 9);
      setState(2294);
      match(tsqlParser::LR_BRACKET);
      setState(2295);
      search_condition(0);
      setState(2296);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 10: {
      _localctx = dynamic_cast<PredicateContext *>(_tracker.createInstance<tsqlParser::Decimal_expressionContext>(_localctx));
      enterOuterAlt(_localctx, 10);
      setState(2298);
      match(tsqlParser::DECIMAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Query_expressionContext ------------------------------------------------------------------

tsqlParser::Query_expressionContext::Query_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t tsqlParser::Query_expressionContext::getRuleIndex() const {
  return tsqlParser::RuleQuery_expression;
}

void tsqlParser::Query_expressionContext::copyFrom(Query_expressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Bracket_query_expressionContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Bracket_query_expressionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Query_expressionContext* tsqlParser::Bracket_query_expressionContext::query_expression() {
  return getRuleContext<tsqlParser::Query_expressionContext>(0);
}

tree::TerminalNode* tsqlParser::Bracket_query_expressionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::Bracket_query_expressionContext::Bracket_query_expressionContext(Query_expressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Bracket_query_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBracket_query_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Query_specification_expressionContext ------------------------------------------------------------------

tsqlParser::Query_specificationContext* tsqlParser::Query_specification_expressionContext::query_specification() {
  return getRuleContext<tsqlParser::Query_specificationContext>(0);
}

tsqlParser::Query_specification_expressionContext::Query_specification_expressionContext(Query_expressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Query_specification_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitQuery_specification_expression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Union_query_expressionContext ------------------------------------------------------------------

std::vector<tsqlParser::Query_expressionContext *> tsqlParser::Union_query_expressionContext::query_expression() {
  return getRuleContexts<tsqlParser::Query_expressionContext>();
}

tsqlParser::Query_expressionContext* tsqlParser::Union_query_expressionContext::query_expression(size_t i) {
  return getRuleContext<tsqlParser::Query_expressionContext>(i);
}

tsqlParser::Union_opContext* tsqlParser::Union_query_expressionContext::union_op() {
  return getRuleContext<tsqlParser::Union_opContext>(0);
}

tsqlParser::Union_query_expressionContext::Union_query_expressionContext(Query_expressionContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Union_query_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitUnion_query_expression(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Query_expressionContext* tsqlParser::query_expression() {
   return query_expression(0);
}

tsqlParser::Query_expressionContext* tsqlParser::query_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  tsqlParser::Query_expressionContext *_localctx = _tracker.createInstance<Query_expressionContext>(_ctx, parentState);
  tsqlParser::Query_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 228;
  enterRecursionRule(_localctx, 228, tsqlParser::RuleQuery_expression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2307);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::LR_BRACKET: {
        _localctx = _tracker.createInstance<Bracket_query_expressionContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;

        setState(2302);
        match(tsqlParser::LR_BRACKET);
        setState(2303);
        query_expression(0);
        setState(2304);
        match(tsqlParser::RR_BRACKET);
        break;
      }

      case tsqlParser::SELECT: {
        _localctx = _tracker.createInstance<Query_specification_expressionContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(2306);
        query_specification();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(2315);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<Union_query_expressionContext>(_tracker.createInstance<Query_expressionContext>(parentContext, parentState));
        _localctx = newContext;
        newContext->left = previousContext;
        pushNewRecursionContext(newContext, startState, RuleQuery_expression);
        setState(2309);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(2310);
        dynamic_cast<Union_query_expressionContext *>(_localctx)->op = union_op();
        setState(2311);
        dynamic_cast<Union_query_expressionContext *>(_localctx)->right = query_expression(3); 
      }
      setState(2317);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Union_opContext ------------------------------------------------------------------

tsqlParser::Union_opContext::Union_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Union_opContext::UNION() {
  return getToken(tsqlParser::UNION, 0);
}

tree::TerminalNode* tsqlParser::Union_opContext::EXCEPT() {
  return getToken(tsqlParser::EXCEPT, 0);
}

tree::TerminalNode* tsqlParser::Union_opContext::INTERSECT() {
  return getToken(tsqlParser::INTERSECT, 0);
}

tree::TerminalNode* tsqlParser::Union_opContext::ALL() {
  return getToken(tsqlParser::ALL, 0);
}


size_t tsqlParser::Union_opContext::getRuleIndex() const {
  return tsqlParser::RuleUnion_op;
}


antlrcpp::Any tsqlParser::Union_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitUnion_op(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Union_opContext* tsqlParser::union_op() {
  Union_opContext *_localctx = _tracker.createInstance<Union_opContext>(_ctx, getState());
  enterRule(_localctx, 230, tsqlParser::RuleUnion_op);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2324);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::UNION: {
        setState(2318);
        match(tsqlParser::UNION);
        setState(2320);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::ALL) {
          setState(2319);
          match(tsqlParser::ALL);
        }
        break;
      }

      case tsqlParser::EXCEPT: {
        setState(2322);
        match(tsqlParser::EXCEPT);
        break;
      }

      case tsqlParser::INTERSECT: {
        setState(2323);
        match(tsqlParser::INTERSECT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cross_apply_expressionContext ------------------------------------------------------------------

tsqlParser::Cross_apply_expressionContext::Cross_apply_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Cross_apply_expressionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Cross_apply_expressionContext* tsqlParser::Cross_apply_expressionContext::cross_apply_expression() {
  return getRuleContext<tsqlParser::Cross_apply_expressionContext>(0);
}

tree::TerminalNode* tsqlParser::Cross_apply_expressionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::Query_expressionContext* tsqlParser::Cross_apply_expressionContext::query_expression() {
  return getRuleContext<tsqlParser::Query_expressionContext>(0);
}

tsqlParser::ExpressionContext* tsqlParser::Cross_apply_expressionContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tsqlParser::Table_value_constructorContext* tsqlParser::Cross_apply_expressionContext::table_value_constructor() {
  return getRuleContext<tsqlParser::Table_value_constructorContext>(0);
}


size_t tsqlParser::Cross_apply_expressionContext::getRuleIndex() const {
  return tsqlParser::RuleCross_apply_expression;
}


antlrcpp::Any tsqlParser::Cross_apply_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCross_apply_expression(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Cross_apply_expressionContext* tsqlParser::cross_apply_expression() {
  Cross_apply_expressionContext *_localctx = _tracker.createInstance<Cross_apply_expressionContext>(_ctx, getState());
  enterRule(_localctx, 232, tsqlParser::RuleCross_apply_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2333);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 333, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2326);
      match(tsqlParser::LR_BRACKET);
      setState(2327);
      cross_apply_expression();
      setState(2328);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2330);
      query_expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2331);
      expression(0);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2332);
      table_value_constructor();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Query_specificationContext ------------------------------------------------------------------

tsqlParser::Query_specificationContext::Query_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Query_specificationContext::SELECT() {
  return getToken(tsqlParser::SELECT, 0);
}

tsqlParser::Select_listContext* tsqlParser::Query_specificationContext::select_list() {
  return getRuleContext<tsqlParser::Select_listContext>(0);
}

tsqlParser::Top_clauseContext* tsqlParser::Query_specificationContext::top_clause() {
  return getRuleContext<tsqlParser::Top_clauseContext>(0);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::INTO() {
  return getToken(tsqlParser::INTO, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Query_specificationContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::FROM() {
  return getToken(tsqlParser::FROM, 0);
}

tsqlParser::Table_sourcesContext* tsqlParser::Query_specificationContext::table_sources() {
  return getRuleContext<tsqlParser::Table_sourcesContext>(0);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::CROSS() {
  return getToken(tsqlParser::CROSS, 0);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::APPLY() {
  return getToken(tsqlParser::APPLY, 0);
}

tsqlParser::Cross_apply_expressionContext* tsqlParser::Query_specificationContext::cross_apply_expression() {
  return getRuleContext<tsqlParser::Cross_apply_expressionContext>(0);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::WHERE() {
  return getToken(tsqlParser::WHERE, 0);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::GROUP() {
  return getToken(tsqlParser::GROUP, 0);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::BY() {
  return getToken(tsqlParser::BY, 0);
}

std::vector<tsqlParser::Group_by_itemContext *> tsqlParser::Query_specificationContext::group_by_item() {
  return getRuleContexts<tsqlParser::Group_by_itemContext>();
}

tsqlParser::Group_by_itemContext* tsqlParser::Query_specificationContext::group_by_item(size_t i) {
  return getRuleContext<tsqlParser::Group_by_itemContext>(i);
}

tsqlParser::Group_by_grouping_setsContext* tsqlParser::Query_specificationContext::group_by_grouping_sets() {
  return getRuleContext<tsqlParser::Group_by_grouping_setsContext>(0);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::HAVING() {
  return getToken(tsqlParser::HAVING, 0);
}

std::vector<tsqlParser::Search_conditionContext *> tsqlParser::Query_specificationContext::search_condition() {
  return getRuleContexts<tsqlParser::Search_conditionContext>();
}

tsqlParser::Search_conditionContext* tsqlParser::Query_specificationContext::search_condition(size_t i) {
  return getRuleContext<tsqlParser::Search_conditionContext>(i);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::CUBE() {
  return getToken(tsqlParser::CUBE, 0);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::ROLLUP() {
  return getToken(tsqlParser::ROLLUP, 0);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::ALL() {
  return getToken(tsqlParser::ALL, 0);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::DISTINCT() {
  return getToken(tsqlParser::DISTINCT, 0);
}

tsqlParser::Output_dml_list_elemContext* tsqlParser::Query_specificationContext::output_dml_list_elem() {
  return getRuleContext<tsqlParser::Output_dml_list_elemContext>(0);
}

std::vector<tree::TerminalNode *> tsqlParser::Query_specificationContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Query_specificationContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Query_specificationContext::getRuleIndex() const {
  return tsqlParser::RuleQuery_specification;
}


antlrcpp::Any tsqlParser::Query_specificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitQuery_specification(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Query_specificationContext* tsqlParser::query_specification() {
  Query_specificationContext *_localctx = _tracker.createInstance<Query_specificationContext>(_ctx, getState());
  enterRule(_localctx, 234, tsqlParser::RuleQuery_specification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2335);
    match(tsqlParser::SELECT);
    setState(2337);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::ALL

    || _la == tsqlParser::DISTINCT) {
      setState(2336);
      dynamic_cast<Query_specificationContext *>(_localctx)->pref = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::ALL

      || _la == tsqlParser::DISTINCT)) {
        dynamic_cast<Query_specificationContext *>(_localctx)->pref = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2340);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::TOP) {
      setState(2339);
      top_clause();
    }
    setState(2342);
    select_list();
    setState(2345);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx)) {
    case 1: {
      setState(2343);
      match(tsqlParser::INTO);
      setState(2344);
      table_name();
      break;
    }

    default:
      break;
    }
    setState(2349);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 337, _ctx)) {
    case 1: {
      setState(2347);
      match(tsqlParser::FROM);
      setState(2348);
      table_sources();
      break;
    }

    default:
      break;
    }
    setState(2357);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
    case 1: {
      setState(2351);
      match(tsqlParser::CROSS);
      setState(2352);
      match(tsqlParser::APPLY);
      setState(2353);
      cross_apply_expression();
      setState(2355);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx)) {
      case 1: {
        setState(2354);
        output_dml_list_elem();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    setState(2361);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx)) {
    case 1: {
      setState(2359);
      match(tsqlParser::WHERE);
      setState(2360);
      dynamic_cast<Query_specificationContext *>(_localctx)->where = search_condition(0);
      break;
    }

    default:
      break;
    }
    setState(2373);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx)) {
    case 1: {
      setState(2363);
      match(tsqlParser::GROUP);
      setState(2364);
      match(tsqlParser::BY);
      setState(2365);
      group_by_item();
      setState(2370);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2366);
          match(tsqlParser::COMMA);
          setState(2367);
          group_by_item(); 
        }
        setState(2372);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx);
      }
      break;
    }

    default:
      break;
    }
    setState(2376);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
    case 1: {
      setState(2375);
      group_by_grouping_sets();
      break;
    }

    default:
      break;
    }
    setState(2380);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
    case 1: {
      setState(2378);
      match(tsqlParser::WITH);
      setState(2379);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::CUBE || _la == tsqlParser::ROLLUP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(2384);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 345, _ctx)) {
    case 1: {
      setState(2382);
      match(tsqlParser::HAVING);
      setState(2383);
      dynamic_cast<Query_specificationContext *>(_localctx)->having = search_condition(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_by_grouping_setsContext ------------------------------------------------------------------

tsqlParser::Group_by_grouping_setsContext::Group_by_grouping_setsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Group_by_grouping_setsContext::GROUP() {
  return getToken(tsqlParser::GROUP, 0);
}

tree::TerminalNode* tsqlParser::Group_by_grouping_setsContext::BY() {
  return getToken(tsqlParser::BY, 0);
}

tree::TerminalNode* tsqlParser::Group_by_grouping_setsContext::GROUPING() {
  return getToken(tsqlParser::GROUPING, 0);
}

tree::TerminalNode* tsqlParser::Group_by_grouping_setsContext::SETS() {
  return getToken(tsqlParser::SETS, 0);
}

tree::TerminalNode* tsqlParser::Group_by_grouping_setsContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

std::vector<tsqlParser::Grouping_setContext *> tsqlParser::Group_by_grouping_setsContext::grouping_set() {
  return getRuleContexts<tsqlParser::Grouping_setContext>();
}

tsqlParser::Grouping_setContext* tsqlParser::Group_by_grouping_setsContext::grouping_set(size_t i) {
  return getRuleContext<tsqlParser::Grouping_setContext>(i);
}

tree::TerminalNode* tsqlParser::Group_by_grouping_setsContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Group_by_grouping_setsContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Group_by_grouping_setsContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Group_by_grouping_setsContext::getRuleIndex() const {
  return tsqlParser::RuleGroup_by_grouping_sets;
}


antlrcpp::Any tsqlParser::Group_by_grouping_setsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitGroup_by_grouping_sets(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Group_by_grouping_setsContext* tsqlParser::group_by_grouping_sets() {
  Group_by_grouping_setsContext *_localctx = _tracker.createInstance<Group_by_grouping_setsContext>(_ctx, getState());
  enterRule(_localctx, 236, tsqlParser::RuleGroup_by_grouping_sets);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2386);
    match(tsqlParser::GROUP);
    setState(2387);
    match(tsqlParser::BY);
    setState(2388);
    match(tsqlParser::GROUPING);
    setState(2389);
    match(tsqlParser::SETS);
    setState(2390);
    match(tsqlParser::LR_BRACKET);
    setState(2391);
    grouping_set();
    setState(2396);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(2392);
      match(tsqlParser::COMMA);
      setState(2393);
      grouping_set();
      setState(2398);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2399);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Grouping_setContext ------------------------------------------------------------------

tsqlParser::Grouping_setContext::Grouping_setContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Grouping_setContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Grouping_setContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tsqlParser::Group_by_itemContext *> tsqlParser::Grouping_setContext::group_by_item() {
  return getRuleContexts<tsqlParser::Group_by_itemContext>();
}

tsqlParser::Group_by_itemContext* tsqlParser::Grouping_setContext::group_by_item(size_t i) {
  return getRuleContext<tsqlParser::Group_by_itemContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Grouping_setContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Grouping_setContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Grouping_setContext::getRuleIndex() const {
  return tsqlParser::RuleGrouping_set;
}


antlrcpp::Any tsqlParser::Grouping_setContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitGrouping_set(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Grouping_setContext* tsqlParser::grouping_set() {
  Grouping_setContext *_localctx = _tracker.createInstance<Grouping_setContext>(_ctx, getState());
  enterRule(_localctx, 238, tsqlParser::RuleGrouping_set);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2415);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 348, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2401);
      match(tsqlParser::LR_BRACKET);
      setState(2402);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2403);
      group_by_item();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2404);
      match(tsqlParser::LR_BRACKET);
      setState(2405);
      group_by_item();
      setState(2410);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(2406);
        match(tsqlParser::COMMA);
        setState(2407);
        group_by_item();
        setState(2412);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2413);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_clauseContext ------------------------------------------------------------------

tsqlParser::Top_clauseContext::Top_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Top_clauseContext::TOP() {
  return getToken(tsqlParser::TOP, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Top_clauseContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Top_clauseContext::PERCENT() {
  return getToken(tsqlParser::PERCENT, 0);
}

tree::TerminalNode* tsqlParser::Top_clauseContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

tree::TerminalNode* tsqlParser::Top_clauseContext::TIES() {
  return getToken(tsqlParser::TIES, 0);
}


size_t tsqlParser::Top_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleTop_clause;
}


antlrcpp::Any tsqlParser::Top_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTop_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Top_clauseContext* tsqlParser::top_clause() {
  Top_clauseContext *_localctx = _tracker.createInstance<Top_clauseContext>(_ctx, getState());
  enterRule(_localctx, 240, tsqlParser::RuleTop_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2417);
    match(tsqlParser::TOP);
    setState(2418);
    expression(0);
    setState(2420);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::PERCENT) {
      setState(2419);
      match(tsqlParser::PERCENT);
    }
    setState(2424);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WITH) {
      setState(2422);
      match(tsqlParser::WITH);
      setState(2423);
      match(tsqlParser::TIES);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_clause_dmContext ------------------------------------------------------------------

tsqlParser::Top_clause_dmContext::Top_clause_dmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Top_clause_dmContext::TOP() {
  return getToken(tsqlParser::TOP, 0);
}

tree::TerminalNode* tsqlParser::Top_clause_dmContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Top_clause_dmContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Top_clause_dmContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Top_clause_dmContext::PERCENT() {
  return getToken(tsqlParser::PERCENT, 0);
}


size_t tsqlParser::Top_clause_dmContext::getRuleIndex() const {
  return tsqlParser::RuleTop_clause_dm;
}


antlrcpp::Any tsqlParser::Top_clause_dmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTop_clause_dm(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Top_clause_dmContext* tsqlParser::top_clause_dm() {
  Top_clause_dmContext *_localctx = _tracker.createInstance<Top_clause_dmContext>(_ctx, getState());
  enterRule(_localctx, 242, tsqlParser::RuleTop_clause_dm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2426);
    match(tsqlParser::TOP);
    setState(2427);
    match(tsqlParser::LR_BRACKET);
    setState(2428);
    expression(0);
    setState(2429);
    match(tsqlParser::RR_BRACKET);
    setState(2431);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::PERCENT) {
      setState(2430);
      match(tsqlParser::PERCENT);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_clauseContext ------------------------------------------------------------------

tsqlParser::Order_by_clauseContext::Order_by_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Order_by_clauseContext::ORDER() {
  return getToken(tsqlParser::ORDER, 0);
}

tree::TerminalNode* tsqlParser::Order_by_clauseContext::BY() {
  return getToken(tsqlParser::BY, 0);
}

std::vector<tsqlParser::Order_by_expressionContext *> tsqlParser::Order_by_clauseContext::order_by_expression() {
  return getRuleContexts<tsqlParser::Order_by_expressionContext>();
}

tsqlParser::Order_by_expressionContext* tsqlParser::Order_by_clauseContext::order_by_expression(size_t i) {
  return getRuleContext<tsqlParser::Order_by_expressionContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Order_by_clauseContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Order_by_clauseContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::Order_by_clauseContext::OFFSET() {
  return getToken(tsqlParser::OFFSET, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Order_by_clauseContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Order_by_clauseContext::ROW() {
  return getToken(tsqlParser::ROW, 0);
}

tree::TerminalNode* tsqlParser::Order_by_clauseContext::ROWS() {
  return getToken(tsqlParser::ROWS, 0);
}

tsqlParser::Fetch_expressionContext* tsqlParser::Order_by_clauseContext::fetch_expression() {
  return getRuleContext<tsqlParser::Fetch_expressionContext>(0);
}


size_t tsqlParser::Order_by_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleOrder_by_clause;
}


antlrcpp::Any tsqlParser::Order_by_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOrder_by_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Order_by_clauseContext* tsqlParser::order_by_clause() {
  Order_by_clauseContext *_localctx = _tracker.createInstance<Order_by_clauseContext>(_ctx, getState());
  enterRule(_localctx, 244, tsqlParser::RuleOrder_by_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2433);
    match(tsqlParser::ORDER);
    setState(2434);
    match(tsqlParser::BY);
    setState(2435);
    order_by_expression();
    setState(2440);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 352, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2436);
        match(tsqlParser::COMMA);
        setState(2437);
        order_by_expression(); 
      }
      setState(2442);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 352, _ctx);
    }
    setState(2449);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 354, _ctx)) {
    case 1: {
      setState(2443);
      match(tsqlParser::OFFSET);
      setState(2444);
      dynamic_cast<Order_by_clauseContext *>(_localctx)->offset = expression(0);
      setState(2445);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::ROW

      || _la == tsqlParser::ROWS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2447);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 353, _ctx)) {
      case 1: {
        setState(2446);
        fetch_expression();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fetch_expressionContext ------------------------------------------------------------------

tsqlParser::Fetch_expressionContext::Fetch_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Fetch_expressionContext::FETCH() {
  return getToken(tsqlParser::FETCH, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Fetch_expressionContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Fetch_expressionContext::ONLY() {
  return getToken(tsqlParser::ONLY, 0);
}

tree::TerminalNode* tsqlParser::Fetch_expressionContext::FIRST() {
  return getToken(tsqlParser::FIRST, 0);
}

tree::TerminalNode* tsqlParser::Fetch_expressionContext::NEXT() {
  return getToken(tsqlParser::NEXT, 0);
}

tree::TerminalNode* tsqlParser::Fetch_expressionContext::ROW() {
  return getToken(tsqlParser::ROW, 0);
}

tree::TerminalNode* tsqlParser::Fetch_expressionContext::ROWS() {
  return getToken(tsqlParser::ROWS, 0);
}


size_t tsqlParser::Fetch_expressionContext::getRuleIndex() const {
  return tsqlParser::RuleFetch_expression;
}


antlrcpp::Any tsqlParser::Fetch_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFetch_expression(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Fetch_expressionContext* tsqlParser::fetch_expression() {
  Fetch_expressionContext *_localctx = _tracker.createInstance<Fetch_expressionContext>(_ctx, getState());
  enterRule(_localctx, 246, tsqlParser::RuleFetch_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2451);
    match(tsqlParser::FETCH);
    setState(2452);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::NEXT || _la == tsqlParser::FIRST)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2453);
    expression(0);
    setState(2454);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::ROW

    || _la == tsqlParser::ROWS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2455);
    match(tsqlParser::ONLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_clauseContext ------------------------------------------------------------------

tsqlParser::For_clauseContext::For_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::For_clauseContext::FOR() {
  return getToken(tsqlParser::FOR, 0);
}

tree::TerminalNode* tsqlParser::For_clauseContext::BROWSE() {
  return getToken(tsqlParser::BROWSE, 0);
}

tree::TerminalNode* tsqlParser::For_clauseContext::XML() {
  return getToken(tsqlParser::XML, 0);
}

tree::TerminalNode* tsqlParser::For_clauseContext::AUTO() {
  return getToken(tsqlParser::AUTO, 0);
}

tsqlParser::Xml_common_directivesContext* tsqlParser::For_clauseContext::xml_common_directives() {
  return getRuleContext<tsqlParser::Xml_common_directivesContext>(0);
}

tree::TerminalNode* tsqlParser::For_clauseContext::PATH() {
  return getToken(tsqlParser::PATH, 0);
}

tree::TerminalNode* tsqlParser::For_clauseContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::For_clauseContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}

tree::TerminalNode* tsqlParser::For_clauseContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}


size_t tsqlParser::For_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleFor_clause;
}


antlrcpp::Any tsqlParser::For_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFor_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::For_clauseContext* tsqlParser::for_clause() {
  For_clauseContext *_localctx = _tracker.createInstance<For_clauseContext>(_ctx, getState());
  enterRule(_localctx, 248, tsqlParser::RuleFor_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2476);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 358, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2457);
      match(tsqlParser::FOR);
      setState(2458);
      match(tsqlParser::BROWSE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2459);
      match(tsqlParser::FOR);
      setState(2460);
      match(tsqlParser::XML);
      setState(2461);
      match(tsqlParser::AUTO);
      setState(2463);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 355, _ctx)) {
      case 1: {
        setState(2462);
        xml_common_directives();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2465);
      match(tsqlParser::FOR);
      setState(2466);
      match(tsqlParser::XML);
      setState(2467);
      match(tsqlParser::PATH);
      setState(2471);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 356, _ctx)) {
      case 1: {
        setState(2468);
        match(tsqlParser::LR_BRACKET);
        setState(2469);
        match(tsqlParser::STRING);
        setState(2470);
        match(tsqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
      setState(2474);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 357, _ctx)) {
      case 1: {
        setState(2473);
        xml_common_directives();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_common_directivesContext ------------------------------------------------------------------

tsqlParser::Xml_common_directivesContext::Xml_common_directivesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Xml_common_directivesContext::COMMA() {
  return getToken(tsqlParser::COMMA, 0);
}

tree::TerminalNode* tsqlParser::Xml_common_directivesContext::BINARY() {
  return getToken(tsqlParser::BINARY, 0);
}

tree::TerminalNode* tsqlParser::Xml_common_directivesContext::BASE64() {
  return getToken(tsqlParser::BASE64, 0);
}

tree::TerminalNode* tsqlParser::Xml_common_directivesContext::TYPE() {
  return getToken(tsqlParser::TYPE, 0);
}

tree::TerminalNode* tsqlParser::Xml_common_directivesContext::ROOT() {
  return getToken(tsqlParser::ROOT, 0);
}


size_t tsqlParser::Xml_common_directivesContext::getRuleIndex() const {
  return tsqlParser::RuleXml_common_directives;
}


antlrcpp::Any tsqlParser::Xml_common_directivesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitXml_common_directives(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Xml_common_directivesContext* tsqlParser::xml_common_directives() {
  Xml_common_directivesContext *_localctx = _tracker.createInstance<Xml_common_directivesContext>(_ctx, getState());
  enterRule(_localctx, 250, tsqlParser::RuleXml_common_directives);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2478);
    match(tsqlParser::COMMA);
    setState(2483);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::BINARY: {
        setState(2479);
        match(tsqlParser::BINARY);
        setState(2480);
        match(tsqlParser::BASE64);
        break;
      }

      case tsqlParser::TYPE: {
        setState(2481);
        match(tsqlParser::TYPE);
        break;
      }

      case tsqlParser::ROOT: {
        setState(2482);
        match(tsqlParser::ROOT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_expressionContext ------------------------------------------------------------------

tsqlParser::Order_by_expressionContext::Order_by_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::ExpressionContext* tsqlParser::Order_by_expressionContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Order_by_expressionContext::ASC() {
  return getToken(tsqlParser::ASC, 0);
}

tree::TerminalNode* tsqlParser::Order_by_expressionContext::DESC() {
  return getToken(tsqlParser::DESC, 0);
}


size_t tsqlParser::Order_by_expressionContext::getRuleIndex() const {
  return tsqlParser::RuleOrder_by_expression;
}


antlrcpp::Any tsqlParser::Order_by_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOrder_by_expression(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Order_by_expressionContext* tsqlParser::order_by_expression() {
  Order_by_expressionContext *_localctx = _tracker.createInstance<Order_by_expressionContext>(_ctx, getState());
  enterRule(_localctx, 252, tsqlParser::RuleOrder_by_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2485);
    expression(0);
    setState(2487);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 360, _ctx)) {
    case 1: {
      setState(2486);
      dynamic_cast<Order_by_expressionContext *>(_localctx)->direction = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::ASC

      || _la == tsqlParser::DESC)) {
        dynamic_cast<Order_by_expressionContext *>(_localctx)->direction = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_by_itemContext ------------------------------------------------------------------

tsqlParser::Group_by_itemContext::Group_by_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::ExpressionContext* tsqlParser::Group_by_itemContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}


size_t tsqlParser::Group_by_itemContext::getRuleIndex() const {
  return tsqlParser::RuleGroup_by_item;
}


antlrcpp::Any tsqlParser::Group_by_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitGroup_by_item(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Group_by_itemContext* tsqlParser::group_by_item() {
  Group_by_itemContext *_localctx = _tracker.createInstance<Group_by_itemContext>(_ctx, getState());
  enterRule(_localctx, 254, tsqlParser::RuleGroup_by_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2489);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Option_clauseContext ------------------------------------------------------------------

tsqlParser::Option_clauseContext::Option_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Option_clauseContext::OPTION() {
  return getToken(tsqlParser::OPTION, 0);
}

tree::TerminalNode* tsqlParser::Option_clauseContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

std::vector<tsqlParser::OptionContext *> tsqlParser::Option_clauseContext::option() {
  return getRuleContexts<tsqlParser::OptionContext>();
}

tsqlParser::OptionContext* tsqlParser::Option_clauseContext::option(size_t i) {
  return getRuleContext<tsqlParser::OptionContext>(i);
}

tree::TerminalNode* tsqlParser::Option_clauseContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Option_clauseContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Option_clauseContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Option_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleOption_clause;
}


antlrcpp::Any tsqlParser::Option_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOption_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Option_clauseContext* tsqlParser::option_clause() {
  Option_clauseContext *_localctx = _tracker.createInstance<Option_clauseContext>(_ctx, getState());
  enterRule(_localctx, 256, tsqlParser::RuleOption_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2491);
    match(tsqlParser::OPTION);
    setState(2492);
    match(tsqlParser::LR_BRACKET);
    setState(2493);
    option();
    setState(2498);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(2494);
      match(tsqlParser::COMMA);
      setState(2495);
      option();
      setState(2500);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2501);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionContext ------------------------------------------------------------------

tsqlParser::OptionContext::OptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::OptionContext::FAST() {
  return getToken(tsqlParser::FAST, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::GROUP() {
  return getToken(tsqlParser::GROUP, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::HASH() {
  return getToken(tsqlParser::HASH, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::ORDER() {
  return getToken(tsqlParser::ORDER, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::UNION() {
  return getToken(tsqlParser::UNION, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::MERGE() {
  return getToken(tsqlParser::MERGE, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::CONCAT() {
  return getToken(tsqlParser::CONCAT, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::JOIN() {
  return getToken(tsqlParser::JOIN, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::LOOP() {
  return getToken(tsqlParser::LOOP, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::EXPAND() {
  return getToken(tsqlParser::EXPAND, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::VIEWS() {
  return getToken(tsqlParser::VIEWS, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::FORCE() {
  return getToken(tsqlParser::FORCE, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX() {
  return getToken(tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::KEEP() {
  return getToken(tsqlParser::KEEP, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::PLAN() {
  return getToken(tsqlParser::PLAN, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::KEEPFIXED() {
  return getToken(tsqlParser::KEEPFIXED, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::MAXDOP() {
  return getToken(tsqlParser::MAXDOP, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::MAXRECURSION() {
  return getToken(tsqlParser::MAXRECURSION, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::OPTIMIZE() {
  return getToken(tsqlParser::OPTIMIZE, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::FOR() {
  return getToken(tsqlParser::FOR, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

std::vector<tsqlParser::Optimize_for_argContext *> tsqlParser::OptionContext::optimize_for_arg() {
  return getRuleContexts<tsqlParser::Optimize_for_argContext>();
}

tsqlParser::Optimize_for_argContext* tsqlParser::OptionContext::optimize_for_arg(size_t i) {
  return getRuleContext<tsqlParser::Optimize_for_argContext>(i);
}

tree::TerminalNode* tsqlParser::OptionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::OptionContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::OptionContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::OptionContext::UNKNOWN() {
  return getToken(tsqlParser::UNKNOWN, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::PARAMETERIZATION() {
  return getToken(tsqlParser::PARAMETERIZATION, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::SIMPLE() {
  return getToken(tsqlParser::SIMPLE, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::FORCED() {
  return getToken(tsqlParser::FORCED, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::RECOMPILE() {
  return getToken(tsqlParser::RECOMPILE, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::ROBUST() {
  return getToken(tsqlParser::ROBUST, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::USE() {
  return getToken(tsqlParser::USE, 0);
}

tree::TerminalNode* tsqlParser::OptionContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}


size_t tsqlParser::OptionContext::getRuleIndex() const {
  return tsqlParser::RuleOption;
}


antlrcpp::Any tsqlParser::OptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOption(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::OptionContext* tsqlParser::option() {
  OptionContext *_localctx = _tracker.createInstance<OptionContext>(_ctx, getState());
  enterRule(_localctx, 258, tsqlParser::RuleOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2548);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 363, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2503);
      match(tsqlParser::FAST);
      setState(2504);
      dynamic_cast<OptionContext *>(_localctx)->number_rows = match(tsqlParser::DECIMAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2505);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::ORDER || _la == tsqlParser::HASH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2506);
      match(tsqlParser::GROUP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2507);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::MERGE || _la == tsqlParser::CONCAT

      || _la == tsqlParser::HASH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2508);
      match(tsqlParser::UNION);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2509);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::MERGE || _la == tsqlParser::HASH

      || _la == tsqlParser::LOOP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2510);
      match(tsqlParser::JOIN);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2511);
      match(tsqlParser::EXPAND);
      setState(2512);
      match(tsqlParser::VIEWS);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2513);
      match(tsqlParser::FORCE);
      setState(2514);
      match(tsqlParser::ORDER);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2515);
      match(tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2516);
      match(tsqlParser::KEEP);
      setState(2517);
      match(tsqlParser::PLAN);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2518);
      match(tsqlParser::KEEPFIXED);
      setState(2519);
      match(tsqlParser::PLAN);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2520);
      match(tsqlParser::MAXDOP);
      setState(2521);
      dynamic_cast<OptionContext *>(_localctx)->number_of_processors = match(tsqlParser::DECIMAL);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2522);
      match(tsqlParser::MAXRECURSION);
      setState(2523);
      dynamic_cast<OptionContext *>(_localctx)->number_recursion = match(tsqlParser::DECIMAL);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2524);
      match(tsqlParser::OPTIMIZE);
      setState(2525);
      match(tsqlParser::FOR);
      setState(2526);
      match(tsqlParser::LR_BRACKET);
      setState(2527);
      optimize_for_arg();
      setState(2532);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(2528);
        match(tsqlParser::COMMA);
        setState(2529);
        optimize_for_arg();
        setState(2534);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2535);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(2537);
      match(tsqlParser::OPTIMIZE);
      setState(2538);
      match(tsqlParser::FOR);
      setState(2539);
      match(tsqlParser::UNKNOWN);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(2540);
      match(tsqlParser::PARAMETERIZATION);
      setState(2541);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::FORCED || _la == tsqlParser::SIMPLE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(2542);
      match(tsqlParser::RECOMPILE);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(2543);
      match(tsqlParser::ROBUST);
      setState(2544);
      match(tsqlParser::PLAN);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(2545);
      match(tsqlParser::USE);
      setState(2546);
      match(tsqlParser::PLAN);
      setState(2547);
      match(tsqlParser::STRING);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Optimize_for_argContext ------------------------------------------------------------------

tsqlParser::Optimize_for_argContext::Optimize_for_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Optimize_for_argContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* tsqlParser::Optimize_for_argContext::UNKNOWN() {
  return getToken(tsqlParser::UNKNOWN, 0);
}

tree::TerminalNode* tsqlParser::Optimize_for_argContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tsqlParser::ConstantContext* tsqlParser::Optimize_for_argContext::constant() {
  return getRuleContext<tsqlParser::ConstantContext>(0);
}


size_t tsqlParser::Optimize_for_argContext::getRuleIndex() const {
  return tsqlParser::RuleOptimize_for_arg;
}


antlrcpp::Any tsqlParser::Optimize_for_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOptimize_for_arg(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Optimize_for_argContext* tsqlParser::optimize_for_arg() {
  Optimize_for_argContext *_localctx = _tracker.createInstance<Optimize_for_argContext>(_ctx, getState());
  enterRule(_localctx, 260, tsqlParser::RuleOptimize_for_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2550);
    match(tsqlParser::LOCAL_ID);
    setState(2554);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::UNKNOWN: {
        setState(2551);
        match(tsqlParser::UNKNOWN);
        break;
      }

      case tsqlParser::EQUAL: {
        setState(2552);
        match(tsqlParser::EQUAL);
        setState(2553);
        constant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_listContext ------------------------------------------------------------------

tsqlParser::Select_listContext::Select_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::Select_list_elemContext *> tsqlParser::Select_listContext::select_list_elem() {
  return getRuleContexts<tsqlParser::Select_list_elemContext>();
}

tsqlParser::Select_list_elemContext* tsqlParser::Select_listContext::select_list_elem(size_t i) {
  return getRuleContext<tsqlParser::Select_list_elemContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Select_listContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Select_listContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Select_listContext::getRuleIndex() const {
  return tsqlParser::RuleSelect_list;
}


antlrcpp::Any tsqlParser::Select_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSelect_list(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Select_listContext* tsqlParser::select_list() {
  Select_listContext *_localctx = _tracker.createInstance<Select_listContext>(_ctx, getState());
  enterRule(_localctx, 262, tsqlParser::RuleSelect_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2556);
    select_list_elem();
    setState(2561);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 365, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2557);
        match(tsqlParser::COMMA);
        setState(2558);
        select_list_elem(); 
      }
      setState(2563);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 365, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_list_elemContext ------------------------------------------------------------------

tsqlParser::Select_list_elemContext::Select_list_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::A_starContext* tsqlParser::Select_list_elemContext::a_star() {
  return getRuleContext<tsqlParser::A_starContext>(0);
}

tree::TerminalNode* tsqlParser::Select_list_elemContext::DOLLAR() {
  return getToken(tsqlParser::DOLLAR, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Select_list_elemContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Select_list_elemContext::DOT() {
  return getToken(tsqlParser::DOT, 0);
}

tree::TerminalNode* tsqlParser::Select_list_elemContext::IDENTITY() {
  return getToken(tsqlParser::IDENTITY, 0);
}

tree::TerminalNode* tsqlParser::Select_list_elemContext::ROWGUID() {
  return getToken(tsqlParser::ROWGUID, 0);
}

tree::TerminalNode* tsqlParser::Select_list_elemContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Select_list_elemContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tsqlParser::Column_aliasContext* tsqlParser::Select_list_elemContext::column_alias() {
  return getRuleContext<tsqlParser::Column_aliasContext>(0);
}

tree::TerminalNode* tsqlParser::Select_list_elemContext::AS() {
  return getToken(tsqlParser::AS, 0);
}


size_t tsqlParser::Select_list_elemContext::getRuleIndex() const {
  return tsqlParser::RuleSelect_list_elem;
}


antlrcpp::Any tsqlParser::Select_list_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSelect_list_elem(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Select_list_elemContext* tsqlParser::select_list_elem() {
  Select_list_elemContext *_localctx = _tracker.createInstance<Select_list_elemContext>(_ctx, getState());
  enterRule(_localctx, 264, tsqlParser::RuleSelect_list_elem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2585);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 370, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2567);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & ((1ULL << (tsqlParser::FORCESEEK - 73))
        | (1ULL << (tsqlParser::NEXT - 73))
        | (1ULL << (tsqlParser::NUMERIC - 73)))) != 0) || ((((_la - 196) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 196)) & ((1ULL << (tsqlParser::VALUE - 196))
        | (1ULL << (tsqlParser::ABSOLUTE - 196))
        | (1ULL << (tsqlParser::APPLY - 196))
        | (1ULL << (tsqlParser::AUTO - 196))
        | (1ULL << (tsqlParser::AVG - 196))
        | (1ULL << (tsqlParser::BASE64 - 196))
        | (1ULL << (tsqlParser::CALLER - 196))
        | (1ULL << (tsqlParser::CAST - 196))
        | (1ULL << (tsqlParser::CATCH - 196))
        | (1ULL << (tsqlParser::CHECKSUM_AGG - 196))
        | (1ULL << (tsqlParser::COMMITTED - 196))
        | (1ULL << (tsqlParser::CONCAT - 196))
        | (1ULL << (tsqlParser::CONTROL - 196))
        | (1ULL << (tsqlParser::COOKIE - 196))
        | (1ULL << (tsqlParser::COUNT - 196))
        | (1ULL << (tsqlParser::COUNT_BIG - 196))
        | (1ULL << (tsqlParser::DATE - 196)))) != 0) || ((((_la - 261) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 261)) & ((1ULL << (tsqlParser::DELAY - 261))
        | (1ULL << (tsqlParser::DELETED - 261))
        | (1ULL << (tsqlParser::DENSE_RANK - 261))
        | (1ULL << (tsqlParser::DISABLE - 261))
        | (1ULL << (tsqlParser::DYNAMIC - 261))
        | (1ULL << (tsqlParser::ENCRYPTION - 261))
        | (1ULL << (tsqlParser::EXIST - 261))
        | (1ULL << (tsqlParser::EXPAND - 261))
        | (1ULL << (tsqlParser::FAST - 261))
        | (1ULL << (tsqlParser::FAST_FORWARD - 261))
        | (1ULL << (tsqlParser::FIRST - 261))
        | (1ULL << (tsqlParser::FIRST_VALUE - 261))
        | (1ULL << (tsqlParser::FOLLOWING - 261))
        | (1ULL << (tsqlParser::FORCE - 261))
        | (1ULL << (tsqlParser::FORCED - 261))
        | (1ULL << (tsqlParser::FORWARD_ONLY - 261))
        | (1ULL << (tsqlParser::FULLSCAN - 261))
        | (1ULL << (tsqlParser::GLOBAL - 261))
        | (1ULL << (tsqlParser::GROUPING - 261))
        | (1ULL << (tsqlParser::GROUPING_ID - 261))
        | (1ULL << (tsqlParser::HASH - 261))
        | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 261))
        | (1ULL << (tsqlParser::IMPERSONATE - 261))
        | (1ULL << (tsqlParser::INSENSITIVE - 261))
        | (1ULL << (tsqlParser::INSERTED - 261))
        | (1ULL << (tsqlParser::ISOLATION - 261))
        | (1ULL << (tsqlParser::IO - 261))
        | (1ULL << (tsqlParser::KEEP - 261))
        | (1ULL << (tsqlParser::KEEPFIXED - 261))
        | (1ULL << (tsqlParser::KEYSET - 261))
        | (1ULL << (tsqlParser::LAG - 261))
        | (1ULL << (tsqlParser::LAST - 261))
        | (1ULL << (tsqlParser::LAST_VALUE - 261))
        | (1ULL << (tsqlParser::LEAD - 261))
        | (1ULL << (tsqlParser::LEVEL - 261))
        | (1ULL << (tsqlParser::LOCAL - 261))
        | (1ULL << (tsqlParser::LOCK_ESCALATION - 261))
        | (1ULL << (tsqlParser::LOGIN - 261))
        | (1ULL << (tsqlParser::LOOP - 261))
        | (1ULL << (tsqlParser::MARK - 261))
        | (1ULL << (tsqlParser::MAX - 261))
        | (1ULL << (tsqlParser::MAXDOP - 261))
        | (1ULL << (tsqlParser::MAXRECURSION - 261)))) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 328)) & ((1ULL << (tsqlParser::MIN - 328))
        | (1ULL << (tsqlParser::MODIFY - 328))
        | (1ULL << (tsqlParser::NAME - 328))
        | (1ULL << (tsqlParser::NOCOUNT - 328))
        | (1ULL << (tsqlParser::NODES - 328))
        | (1ULL << (tsqlParser::NOEXPAND - 328))
        | (1ULL << (tsqlParser::NORECOMPUTE - 328))
        | (1ULL << (tsqlParser::NTILE - 328))
        | (1ULL << (tsqlParser::NUMBER - 328))
        | (1ULL << (tsqlParser::OFFSET - 328))
        | (1ULL << (tsqlParser::ONLINE - 328))
        | (1ULL << (tsqlParser::ONLY - 328))
        | (1ULL << (tsqlParser::OPTIMISTIC - 328))
        | (1ULL << (tsqlParser::OPTIMIZE - 328))
        | (1ULL << (tsqlParser::OUT - 328))
        | (1ULL << (tsqlParser::OUTPUT - 328))
        | (1ULL << (tsqlParser::OWNER - 328))
        | (1ULL << (tsqlParser::PARAMETERIZATION - 328))
        | (1ULL << (tsqlParser::PARTITION - 328))
        | (1ULL << (tsqlParser::PATH - 328))
        | (1ULL << (tsqlParser::PRECEDING - 328))
        | (1ULL << (tsqlParser::PRIOR - 328))
        | (1ULL << (tsqlParser::PRIVILEGES - 328))
        | (1ULL << (tsqlParser::QUERY - 328))
        | (1ULL << (tsqlParser::RANGE - 328))
        | (1ULL << (tsqlParser::RANK - 328))
        | (1ULL << (tsqlParser::READONLY - 328))
        | (1ULL << (tsqlParser::READ_ONLY - 328))
        | (1ULL << (tsqlParser::RECOMPILE - 328))
        | (1ULL << (tsqlParser::RELATIVE - 328))
        | (1ULL << (tsqlParser::REMOTE - 328))
        | (1ULL << (tsqlParser::REPEATABLE - 328))
        | (1ULL << (tsqlParser::ROBUST - 328))
        | (1ULL << (tsqlParser::ROOT - 328))
        | (1ULL << (tsqlParser::ROW - 328))
        | (1ULL << (tsqlParser::ROWGUID - 328))
        | (1ULL << (tsqlParser::ROWS - 328))
        | (1ULL << (tsqlParser::ROW_NUMBER - 328))
        | (1ULL << (tsqlParser::SAMPLE - 328))
        | (1ULL << (tsqlParser::SCHEMABINDING - 328))
        | (1ULL << (tsqlParser::SCROLL - 328))
        | (1ULL << (tsqlParser::SCROLL_LOCKS - 328)))) != 0) || ((((_la - 393) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 393)) & ((1ULL << (tsqlParser::SELF - 393))
        | (1ULL << (tsqlParser::SERIALIZABLE - 393))
        | (1ULL << (tsqlParser::SIMPLE - 393))
        | (1ULL << (tsqlParser::SIZE - 393))
        | (1ULL << (tsqlParser::SNAPSHOT - 393))
        | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 393))
        | (1ULL << (tsqlParser::STATIC - 393))
        | (1ULL << (tsqlParser::STATS_STREAM - 393))
        | (1ULL << (tsqlParser::STDEV - 393))
        | (1ULL << (tsqlParser::STDEVP - 393))
        | (1ULL << (tsqlParser::SUM - 393))
        | (1ULL << (tsqlParser::TEXTIMAGE_ON - 393))
        | (1ULL << (tsqlParser::THROW - 393))
        | (1ULL << (tsqlParser::TIES - 393))
        | (1ULL << (tsqlParser::TIME - 393))
        | (1ULL << (tsqlParser::TRY - 393))
        | (1ULL << (tsqlParser::TYPE - 393))
        | (1ULL << (tsqlParser::TYPE_WARNING - 393))
        | (1ULL << (tsqlParser::UNBOUNDED - 393))
        | (1ULL << (tsqlParser::UNCOMMITTED - 393))
        | (1ULL << (tsqlParser::UNKNOWN - 393))
        | (1ULL << (tsqlParser::USING - 393))
        | (1ULL << (tsqlParser::VAR - 393))
        | (1ULL << (tsqlParser::VARP - 393))
        | (1ULL << (tsqlParser::VIEWS - 393))
        | (1ULL << (tsqlParser::VIEW_METADATA - 393))
        | (1ULL << (tsqlParser::WORK - 393))
        | (1ULL << (tsqlParser::XML - 393))
        | (1ULL << (tsqlParser::XMLNAMESPACES - 393))
        | (1ULL << (tsqlParser::ZONE - 393))
        | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 393))
        | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 393))
        | (1ULL << (tsqlParser::ID - 393)))) != 0)) {
        setState(2564);
        table_name();
        setState(2565);
        match(tsqlParser::DOT);
      }
      setState(2572);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case tsqlParser::STAR: {
          setState(2569);
          a_star();
          break;
        }

        case tsqlParser::DOLLAR: {
          setState(2570);
          match(tsqlParser::DOLLAR);
          setState(2571);
          _la = _input->LA(1);
          if (!(_la == tsqlParser::IDENTITY || _la == tsqlParser::ROWGUID)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2574);
      dynamic_cast<Select_list_elemContext *>(_localctx)->alias = column_alias();
      setState(2575);
      match(tsqlParser::EQUAL);
      setState(2576);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2578);
      expression(0);
      setState(2583);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 369, _ctx)) {
      case 1: {
        setState(2580);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::AS) {
          setState(2579);
          match(tsqlParser::AS);
        }
        setState(2582);
        dynamic_cast<Select_list_elemContext *>(_localctx)->alias = column_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_sourcesContext ------------------------------------------------------------------

tsqlParser::Table_sourcesContext::Table_sourcesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::Table_sourceContext *> tsqlParser::Table_sourcesContext::table_source() {
  return getRuleContexts<tsqlParser::Table_sourceContext>();
}

tsqlParser::Table_sourceContext* tsqlParser::Table_sourcesContext::table_source(size_t i) {
  return getRuleContext<tsqlParser::Table_sourceContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Table_sourcesContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Table_sourcesContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Table_sourcesContext::getRuleIndex() const {
  return tsqlParser::RuleTable_sources;
}


antlrcpp::Any tsqlParser::Table_sourcesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTable_sources(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Table_sourcesContext* tsqlParser::table_sources() {
  Table_sourcesContext *_localctx = _tracker.createInstance<Table_sourcesContext>(_ctx, getState());
  enterRule(_localctx, 266, tsqlParser::RuleTable_sources);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2587);
    table_source(0);
    setState(2592);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 371, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2588);
        match(tsqlParser::COMMA);
        setState(2589);
        table_source(0); 
      }
      setState(2594);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 371, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_sourceContext ------------------------------------------------------------------

tsqlParser::Table_sourceContext::Table_sourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t tsqlParser::Table_sourceContext::getRuleIndex() const {
  return tsqlParser::RuleTable_source;
}

void tsqlParser::Table_sourceContext::copyFrom(Table_sourceContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Cross_joinContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Cross_joinContext::JOIN() {
  return getToken(tsqlParser::JOIN, 0);
}

std::vector<tsqlParser::Table_sourceContext *> tsqlParser::Cross_joinContext::table_source() {
  return getRuleContexts<tsqlParser::Table_sourceContext>();
}

tsqlParser::Table_sourceContext* tsqlParser::Cross_joinContext::table_source(size_t i) {
  return getRuleContext<tsqlParser::Table_sourceContext>(i);
}

tree::TerminalNode* tsqlParser::Cross_joinContext::CROSS() {
  return getToken(tsqlParser::CROSS, 0);
}

tsqlParser::Cross_joinContext::Cross_joinContext(Table_sourceContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Cross_joinContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCross_join(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Table_source_item_joinContext ------------------------------------------------------------------

tsqlParser::Table_source_itemContext* tsqlParser::Table_source_item_joinContext::table_source_item() {
  return getRuleContext<tsqlParser::Table_source_itemContext>(0);
}

tsqlParser::Table_source_item_joinContext::Table_source_item_joinContext(Table_sourceContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Table_source_item_joinContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTable_source_item_join(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Standard_joinContext ------------------------------------------------------------------

tsqlParser::Join_typeContext* tsqlParser::Standard_joinContext::join_type() {
  return getRuleContext<tsqlParser::Join_typeContext>(0);
}

tree::TerminalNode* tsqlParser::Standard_joinContext::JOIN() {
  return getToken(tsqlParser::JOIN, 0);
}

tree::TerminalNode* tsqlParser::Standard_joinContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

tsqlParser::Search_conditionContext* tsqlParser::Standard_joinContext::search_condition() {
  return getRuleContext<tsqlParser::Search_conditionContext>(0);
}

std::vector<tsqlParser::Table_sourceContext *> tsqlParser::Standard_joinContext::table_source() {
  return getRuleContexts<tsqlParser::Table_sourceContext>();
}

tsqlParser::Table_sourceContext* tsqlParser::Standard_joinContext::table_source(size_t i) {
  return getRuleContext<tsqlParser::Table_sourceContext>(i);
}

tsqlParser::Standard_joinContext::Standard_joinContext(Table_sourceContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Standard_joinContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitStandard_join(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_joinContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Apply_joinContext::APPLY() {
  return getToken(tsqlParser::APPLY, 0);
}

std::vector<tsqlParser::Table_sourceContext *> tsqlParser::Apply_joinContext::table_source() {
  return getRuleContexts<tsqlParser::Table_sourceContext>();
}

tsqlParser::Table_sourceContext* tsqlParser::Apply_joinContext::table_source(size_t i) {
  return getRuleContext<tsqlParser::Table_sourceContext>(i);
}

tree::TerminalNode* tsqlParser::Apply_joinContext::CROSS() {
  return getToken(tsqlParser::CROSS, 0);
}

tree::TerminalNode* tsqlParser::Apply_joinContext::OUTER() {
  return getToken(tsqlParser::OUTER, 0);
}

tsqlParser::Apply_joinContext::Apply_joinContext(Table_sourceContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Apply_joinContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitApply_join(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bracket_table_sourceContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Bracket_table_sourceContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Table_sourceContext* tsqlParser::Bracket_table_sourceContext::table_source() {
  return getRuleContext<tsqlParser::Table_sourceContext>(0);
}

tree::TerminalNode* tsqlParser::Bracket_table_sourceContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::Bracket_table_sourceContext::Bracket_table_sourceContext(Table_sourceContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Bracket_table_sourceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBracket_table_source(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Table_sourceContext* tsqlParser::table_source() {
   return table_source(0);
}

tsqlParser::Table_sourceContext* tsqlParser::table_source(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  tsqlParser::Table_sourceContext *_localctx = _tracker.createInstance<Table_sourceContext>(_ctx, parentState);
  tsqlParser::Table_sourceContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 268;
  enterRecursionRule(_localctx, 268, tsqlParser::RuleTable_source, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2601);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 372, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<Bracket_table_sourceContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(2596);
      match(tsqlParser::LR_BRACKET);
      setState(2597);
      table_source(0);
      setState(2598);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<Table_source_item_joinContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(2600);
      table_source_item();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(2620);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(2618);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 373, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<Cross_joinContext>(_tracker.createInstance<Table_sourceContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleTable_source);
          setState(2603);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(2604);
          dynamic_cast<Cross_joinContext *>(_localctx)->op = match(tsqlParser::CROSS);
          setState(2605);
          match(tsqlParser::JOIN);
          setState(2606);
          dynamic_cast<Cross_joinContext *>(_localctx)->right = table_source(4);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<Apply_joinContext>(_tracker.createInstance<Table_sourceContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleTable_source);
          setState(2607);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(2608);
          dynamic_cast<Apply_joinContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == tsqlParser::CROSS || _la == tsqlParser::OUTER)) {
            dynamic_cast<Apply_joinContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2609);
          match(tsqlParser::APPLY);
          setState(2610);
          dynamic_cast<Apply_joinContext *>(_localctx)->right = table_source(3);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<Standard_joinContext>(_tracker.createInstance<Table_sourceContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleTable_source);
          setState(2611);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(2612);
          join_type();
          setState(2613);
          match(tsqlParser::JOIN);
          setState(2614);
          dynamic_cast<Standard_joinContext *>(_localctx)->right = table_source(0);
          setState(2615);
          match(tsqlParser::ON);
          setState(2616);
          search_condition(0);
          break;
        }

        default:
          break;
        } 
      }
      setState(2622);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Table_source_itemContext ------------------------------------------------------------------

tsqlParser::Table_source_itemContext::Table_source_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t tsqlParser::Table_source_itemContext::getRuleIndex() const {
  return tsqlParser::RuleTable_source_item;
}

void tsqlParser::Table_source_itemContext::copyFrom(Table_source_itemContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Table_source_item_simpleContext ------------------------------------------------------------------

tsqlParser::Rowset_functionContext* tsqlParser::Table_source_item_simpleContext::rowset_function() {
  return getRuleContext<tsqlParser::Rowset_functionContext>(0);
}

tsqlParser::Table_aliasContext* tsqlParser::Table_source_item_simpleContext::table_alias() {
  return getRuleContext<tsqlParser::Table_aliasContext>(0);
}

tsqlParser::Change_tableContext* tsqlParser::Table_source_item_simpleContext::change_table() {
  return getRuleContext<tsqlParser::Change_tableContext>(0);
}

tsqlParser::Function_callContext* tsqlParser::Table_source_item_simpleContext::function_call() {
  return getRuleContext<tsqlParser::Function_callContext>(0);
}

tree::TerminalNode* tsqlParser::Table_source_item_simpleContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tsqlParser::Table_source_item_simpleContext::Table_source_item_simpleContext(Table_source_itemContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Table_source_item_simpleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTable_source_item_simple(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Table_source_item_complexContext ------------------------------------------------------------------

tsqlParser::Derived_tableContext* tsqlParser::Table_source_item_complexContext::derived_table() {
  return getRuleContext<tsqlParser::Derived_tableContext>(0);
}

tsqlParser::Table_aliasContext* tsqlParser::Table_source_item_complexContext::table_alias() {
  return getRuleContext<tsqlParser::Table_aliasContext>(0);
}

tsqlParser::Column_alias_listContext* tsqlParser::Table_source_item_complexContext::column_alias_list() {
  return getRuleContext<tsqlParser::Column_alias_listContext>(0);
}

tree::TerminalNode* tsqlParser::Table_source_item_complexContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* tsqlParser::Table_source_item_complexContext::DOT() {
  return getToken(tsqlParser::DOT, 0);
}

tsqlParser::Function_callContext* tsqlParser::Table_source_item_complexContext::function_call() {
  return getRuleContext<tsqlParser::Function_callContext>(0);
}

tsqlParser::Table_source_item_complexContext::Table_source_item_complexContext(Table_source_itemContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Table_source_item_complexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTable_source_item_complex(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Table_source_item_nameContext ------------------------------------------------------------------

tsqlParser::Table_nameContext* tsqlParser::Table_source_item_nameContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tsqlParser::Tablesample_clauseContext* tsqlParser::Table_source_item_nameContext::tablesample_clause() {
  return getRuleContext<tsqlParser::Tablesample_clauseContext>(0);
}

tsqlParser::Table_aliasContext* tsqlParser::Table_source_item_nameContext::table_alias() {
  return getRuleContext<tsqlParser::Table_aliasContext>(0);
}

tsqlParser::With_table_hintsContext* tsqlParser::Table_source_item_nameContext::with_table_hints() {
  return getRuleContext<tsqlParser::With_table_hintsContext>(0);
}

tsqlParser::Table_source_item_nameContext::Table_source_item_nameContext(Table_source_itemContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Table_source_item_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTable_source_item_name(this);
  else
    return visitor->visitChildren(this);
}
tsqlParser::Table_source_itemContext* tsqlParser::table_source_item() {
  Table_source_itemContext *_localctx = _tracker.createInstance<Table_source_itemContext>(_ctx, getState());
  enterRule(_localctx, 270, tsqlParser::RuleTable_source_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2665);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 386, _ctx)) {
    case 1: {
      _localctx = dynamic_cast<Table_source_itemContext *>(_tracker.createInstance<tsqlParser::Table_source_item_nameContext>(_localctx));
      enterOuterAlt(_localctx, 1);
      setState(2623);
      table_name();
      setState(2625);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 375, _ctx)) {
      case 1: {
        setState(2624);
        tablesample_clause();
        break;
      }

      default:
        break;
      }
      setState(2628);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 376, _ctx)) {
      case 1: {
        setState(2627);
        table_alias();
        break;
      }

      default:
        break;
      }
      setState(2631);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 377, _ctx)) {
      case 1: {
        setState(2630);
        with_table_hints();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      _localctx = dynamic_cast<Table_source_itemContext *>(_tracker.createInstance<tsqlParser::Table_source_item_simpleContext>(_localctx));
      enterOuterAlt(_localctx, 2);
      setState(2633);
      rowset_function();
      setState(2635);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 378, _ctx)) {
      case 1: {
        setState(2634);
        table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      _localctx = dynamic_cast<Table_source_itemContext *>(_tracker.createInstance<tsqlParser::Table_source_item_complexContext>(_localctx));
      enterOuterAlt(_localctx, 3);
      setState(2637);
      derived_table();
      setState(2642);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 380, _ctx)) {
      case 1: {
        setState(2638);
        table_alias();
        setState(2640);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 379, _ctx)) {
        case 1: {
          setState(2639);
          column_alias_list();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      _localctx = dynamic_cast<Table_source_itemContext *>(_tracker.createInstance<tsqlParser::Table_source_item_simpleContext>(_localctx));
      enterOuterAlt(_localctx, 4);
      setState(2644);
      change_table();
      setState(2646);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 381, _ctx)) {
      case 1: {
        setState(2645);
        table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      _localctx = dynamic_cast<Table_source_itemContext *>(_tracker.createInstance<tsqlParser::Table_source_item_simpleContext>(_localctx));
      enterOuterAlt(_localctx, 5);
      setState(2648);
      function_call();
      setState(2650);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 382, _ctx)) {
      case 1: {
        setState(2649);
        table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      _localctx = dynamic_cast<Table_source_itemContext *>(_tracker.createInstance<tsqlParser::Table_source_item_simpleContext>(_localctx));
      enterOuterAlt(_localctx, 6);
      setState(2652);
      match(tsqlParser::LOCAL_ID);
      setState(2654);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 383, _ctx)) {
      case 1: {
        setState(2653);
        table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      _localctx = dynamic_cast<Table_source_itemContext *>(_tracker.createInstance<tsqlParser::Table_source_item_complexContext>(_localctx));
      enterOuterAlt(_localctx, 7);
      setState(2656);
      match(tsqlParser::LOCAL_ID);
      setState(2657);
      match(tsqlParser::DOT);
      setState(2658);
      function_call();
      setState(2663);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 385, _ctx)) {
      case 1: {
        setState(2659);
        table_alias();
        setState(2661);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 384, _ctx)) {
        case 1: {
          setState(2660);
          column_alias_list();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tablesample_clauseContext ------------------------------------------------------------------

tsqlParser::Tablesample_clauseContext::Tablesample_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Tablesample_clauseContext::TABLESAMPLE() {
  return getToken(tsqlParser::TABLESAMPLE, 0);
}

tree::TerminalNode* tsqlParser::Tablesample_clauseContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Sample_numberContext* tsqlParser::Tablesample_clauseContext::sample_number() {
  return getRuleContext<tsqlParser::Sample_numberContext>(0);
}

tree::TerminalNode* tsqlParser::Tablesample_clauseContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Tablesample_clauseContext::SYSTEM() {
  return getToken(tsqlParser::SYSTEM, 0);
}

tree::TerminalNode* tsqlParser::Tablesample_clauseContext::REPEATABLE() {
  return getToken(tsqlParser::REPEATABLE, 0);
}

tree::TerminalNode* tsqlParser::Tablesample_clauseContext::PERCENT() {
  return getToken(tsqlParser::PERCENT, 0);
}

tree::TerminalNode* tsqlParser::Tablesample_clauseContext::ROWS() {
  return getToken(tsqlParser::ROWS, 0);
}

tsqlParser::Repeat_seedContext* tsqlParser::Tablesample_clauseContext::repeat_seed() {
  return getRuleContext<tsqlParser::Repeat_seedContext>(0);
}


size_t tsqlParser::Tablesample_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleTablesample_clause;
}


antlrcpp::Any tsqlParser::Tablesample_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTablesample_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Tablesample_clauseContext* tsqlParser::tablesample_clause() {
  Tablesample_clauseContext *_localctx = _tracker.createInstance<Tablesample_clauseContext>(_ctx, getState());
  enterRule(_localctx, 272, tsqlParser::RuleTablesample_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2667);
    match(tsqlParser::TABLESAMPLE);
    setState(2669);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::SYSTEM) {
      setState(2668);
      match(tsqlParser::SYSTEM);
    }
    setState(2671);
    match(tsqlParser::LR_BRACKET);
    setState(2672);
    sample_number();
    setState(2674);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::PERCENT || _la == tsqlParser::ROWS) {
      setState(2673);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::PERCENT || _la == tsqlParser::ROWS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2676);
    match(tsqlParser::RR_BRACKET);
    setState(2679);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 389, _ctx)) {
    case 1: {
      setState(2677);
      match(tsqlParser::REPEATABLE);

      setState(2678);
      repeat_seed();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sample_numberContext ------------------------------------------------------------------

tsqlParser::Sample_numberContext::Sample_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Sample_numberContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}


size_t tsqlParser::Sample_numberContext::getRuleIndex() const {
  return tsqlParser::RuleSample_number;
}


antlrcpp::Any tsqlParser::Sample_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSample_number(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Sample_numberContext* tsqlParser::sample_number() {
  Sample_numberContext *_localctx = _tracker.createInstance<Sample_numberContext>(_ctx, getState());
  enterRule(_localctx, 274, tsqlParser::RuleSample_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2681);
    match(tsqlParser::DECIMAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Repeat_seedContext ------------------------------------------------------------------

tsqlParser::Repeat_seedContext::Repeat_seedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Repeat_seedContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}


size_t tsqlParser::Repeat_seedContext::getRuleIndex() const {
  return tsqlParser::RuleRepeat_seed;
}


antlrcpp::Any tsqlParser::Repeat_seedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitRepeat_seed(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Repeat_seedContext* tsqlParser::repeat_seed() {
  Repeat_seedContext *_localctx = _tracker.createInstance<Repeat_seedContext>(_ctx, getState());
  enterRule(_localctx, 276, tsqlParser::RuleRepeat_seed);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2683);
    match(tsqlParser::DECIMAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_aliasContext ------------------------------------------------------------------

tsqlParser::Table_aliasContext::Table_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::R_idContext* tsqlParser::Table_aliasContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Table_aliasContext::AS() {
  return getToken(tsqlParser::AS, 0);
}


size_t tsqlParser::Table_aliasContext::getRuleIndex() const {
  return tsqlParser::RuleTable_alias;
}


antlrcpp::Any tsqlParser::Table_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTable_alias(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Table_aliasContext* tsqlParser::table_alias() {
  Table_aliasContext *_localctx = _tracker.createInstance<Table_aliasContext>(_ctx, getState());
  enterRule(_localctx, 278, tsqlParser::RuleTable_alias);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2686);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::AS) {
      setState(2685);
      match(tsqlParser::AS);
    }
    setState(2688);
    r_id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Change_tableContext ------------------------------------------------------------------

tsqlParser::Change_tableContext::Change_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Change_tableContext::CHANGETABLE() {
  return getToken(tsqlParser::CHANGETABLE, 0);
}

tree::TerminalNode* tsqlParser::Change_tableContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Change_tableContext::CHANGES() {
  return getToken(tsqlParser::CHANGES, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Change_tableContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Change_tableContext::COMMA() {
  return getToken(tsqlParser::COMMA, 0);
}

tree::TerminalNode* tsqlParser::Change_tableContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Change_tableContext::NULL_() {
  return getToken(tsqlParser::NULL_, 0);
}

tree::TerminalNode* tsqlParser::Change_tableContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tree::TerminalNode* tsqlParser::Change_tableContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}


size_t tsqlParser::Change_tableContext::getRuleIndex() const {
  return tsqlParser::RuleChange_table;
}


antlrcpp::Any tsqlParser::Change_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitChange_table(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Change_tableContext* tsqlParser::change_table() {
  Change_tableContext *_localctx = _tracker.createInstance<Change_tableContext>(_ctx, getState());
  enterRule(_localctx, 280, tsqlParser::RuleChange_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2690);
    match(tsqlParser::CHANGETABLE);
    setState(2691);
    match(tsqlParser::LR_BRACKET);
    setState(2692);
    match(tsqlParser::CHANGES);
    setState(2693);
    table_name();
    setState(2694);
    match(tsqlParser::COMMA);
    setState(2695);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::NULL_ || _la == tsqlParser::LOCAL_ID

    || _la == tsqlParser::DECIMAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2696);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_typeContext ------------------------------------------------------------------

tsqlParser::Join_typeContext::Join_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Join_typeContext::LEFT() {
  return getToken(tsqlParser::LEFT, 0);
}

tree::TerminalNode* tsqlParser::Join_typeContext::RIGHT() {
  return getToken(tsqlParser::RIGHT, 0);
}

tree::TerminalNode* tsqlParser::Join_typeContext::FULL() {
  return getToken(tsqlParser::FULL, 0);
}

tree::TerminalNode* tsqlParser::Join_typeContext::INNER() {
  return getToken(tsqlParser::INNER, 0);
}

tree::TerminalNode* tsqlParser::Join_typeContext::OUTER() {
  return getToken(tsqlParser::OUTER, 0);
}

tree::TerminalNode* tsqlParser::Join_typeContext::LOOP() {
  return getToken(tsqlParser::LOOP, 0);
}

tree::TerminalNode* tsqlParser::Join_typeContext::HASH() {
  return getToken(tsqlParser::HASH, 0);
}

tree::TerminalNode* tsqlParser::Join_typeContext::MERGE() {
  return getToken(tsqlParser::MERGE, 0);
}

tree::TerminalNode* tsqlParser::Join_typeContext::REMOTE() {
  return getToken(tsqlParser::REMOTE, 0);
}


size_t tsqlParser::Join_typeContext::getRuleIndex() const {
  return tsqlParser::RuleJoin_type;
}


antlrcpp::Any tsqlParser::Join_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitJoin_type(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Join_typeContext* tsqlParser::join_type() {
  Join_typeContext *_localctx = _tracker.createInstance<Join_typeContext>(_ctx, getState());
  enterRule(_localctx, 282, tsqlParser::RuleJoin_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2705);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::INNER:
      case tsqlParser::JOIN:
      case tsqlParser::MERGE:
      case tsqlParser::HASH:
      case tsqlParser::LOOP:
      case tsqlParser::REMOTE: {
        setState(2699);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::INNER) {
          setState(2698);
          match(tsqlParser::INNER);
        }
        break;
      }

      case tsqlParser::FULL:
      case tsqlParser::LEFT:
      case tsqlParser::RIGHT: {
        setState(2701);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::FULL

        || _la == tsqlParser::LEFT || _la == tsqlParser::RIGHT)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2703);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::OUTER) {
          setState(2702);
          match(tsqlParser::OUTER);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2708);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::MERGE || _la == tsqlParser::HASH

    || _la == tsqlParser::LOOP || _la == tsqlParser::REMOTE) {
      setState(2707);
      dynamic_cast<Join_typeContext *>(_localctx)->join_hint = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::MERGE || _la == tsqlParser::HASH

      || _la == tsqlParser::LOOP || _la == tsqlParser::REMOTE)) {
        dynamic_cast<Join_typeContext *>(_localctx)->join_hint = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_name_with_hintContext ------------------------------------------------------------------

tsqlParser::Table_name_with_hintContext::Table_name_with_hintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Table_nameContext* tsqlParser::Table_name_with_hintContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}

tsqlParser::With_table_hintsContext* tsqlParser::Table_name_with_hintContext::with_table_hints() {
  return getRuleContext<tsqlParser::With_table_hintsContext>(0);
}


size_t tsqlParser::Table_name_with_hintContext::getRuleIndex() const {
  return tsqlParser::RuleTable_name_with_hint;
}


antlrcpp::Any tsqlParser::Table_name_with_hintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTable_name_with_hint(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Table_name_with_hintContext* tsqlParser::table_name_with_hint() {
  Table_name_with_hintContext *_localctx = _tracker.createInstance<Table_name_with_hintContext>(_ctx, getState());
  enterRule(_localctx, 284, tsqlParser::RuleTable_name_with_hint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2710);
    table_name();
    setState(2712);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 395, _ctx)) {
    case 1: {
      setState(2711);
      with_table_hints();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rowset_functionContext ------------------------------------------------------------------

tsqlParser::Rowset_functionContext::Rowset_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Rowset_functionContext::OPENROWSET() {
  return getToken(tsqlParser::OPENROWSET, 0);
}

tree::TerminalNode* tsqlParser::Rowset_functionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Rowset_functionContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Rowset_functionContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::Rowset_functionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Rowset_functionContext::STRING() {
  return getTokens(tsqlParser::STRING);
}

tree::TerminalNode* tsqlParser::Rowset_functionContext::STRING(size_t i) {
  return getToken(tsqlParser::STRING, i);
}

tree::TerminalNode* tsqlParser::Rowset_functionContext::BULK() {
  return getToken(tsqlParser::BULK, 0);
}

std::vector<tsqlParser::Bulk_optionContext *> tsqlParser::Rowset_functionContext::bulk_option() {
  return getRuleContexts<tsqlParser::Bulk_optionContext>();
}

tsqlParser::Bulk_optionContext* tsqlParser::Rowset_functionContext::bulk_option(size_t i) {
  return getRuleContext<tsqlParser::Bulk_optionContext>(i);
}

tsqlParser::R_idContext* tsqlParser::Rowset_functionContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}


size_t tsqlParser::Rowset_functionContext::getRuleIndex() const {
  return tsqlParser::RuleRowset_function;
}


antlrcpp::Any tsqlParser::Rowset_functionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitRowset_function(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Rowset_functionContext* tsqlParser::rowset_function() {
  Rowset_functionContext *_localctx = _tracker.createInstance<Rowset_functionContext>(_ctx, getState());
  enterRule(_localctx, 286, tsqlParser::RuleRowset_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2740);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 398, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2714);
      match(tsqlParser::OPENROWSET);
      setState(2715);
      match(tsqlParser::LR_BRACKET);
      setState(2716);
      dynamic_cast<Rowset_functionContext *>(_localctx)->provider_name = match(tsqlParser::STRING);
      setState(2717);
      match(tsqlParser::COMMA);
      setState(2718);
      dynamic_cast<Rowset_functionContext *>(_localctx)->connectionString = match(tsqlParser::STRING);
      setState(2719);
      match(tsqlParser::COMMA);
      setState(2720);
      dynamic_cast<Rowset_functionContext *>(_localctx)->sql = match(tsqlParser::STRING);
      setState(2721);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2722);
      match(tsqlParser::OPENROWSET);
      setState(2723);
      match(tsqlParser::LR_BRACKET);
      setState(2724);
      match(tsqlParser::BULK);
      setState(2725);
      dynamic_cast<Rowset_functionContext *>(_localctx)->data_file = match(tsqlParser::STRING);
      setState(2726);
      match(tsqlParser::COMMA);
      setState(2736);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 397, _ctx)) {
      case 1: {
        setState(2727);
        bulk_option();
        setState(2732);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == tsqlParser::COMMA) {
          setState(2728);
          match(tsqlParser::COMMA);
          setState(2729);
          bulk_option();
          setState(2734);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(2735);
        r_id();
        break;
      }

      default:
        break;
      }
      setState(2738);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bulk_optionContext ------------------------------------------------------------------

tsqlParser::Bulk_optionContext::Bulk_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::R_idContext* tsqlParser::Bulk_optionContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Bulk_optionContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Bulk_optionContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tree::TerminalNode* tsqlParser::Bulk_optionContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}


size_t tsqlParser::Bulk_optionContext::getRuleIndex() const {
  return tsqlParser::RuleBulk_option;
}


antlrcpp::Any tsqlParser::Bulk_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitBulk_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Bulk_optionContext* tsqlParser::bulk_option() {
  Bulk_optionContext *_localctx = _tracker.createInstance<Bulk_optionContext>(_ctx, getState());
  enterRule(_localctx, 288, tsqlParser::RuleBulk_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2742);
    r_id();
    setState(2743);
    match(tsqlParser::EQUAL);
    setState(2744);
    dynamic_cast<Bulk_optionContext *>(_localctx)->bulk_option_value = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::DECIMAL

    || _la == tsqlParser::STRING)) {
      dynamic_cast<Bulk_optionContext *>(_localctx)->bulk_option_value = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Derived_tableContext ------------------------------------------------------------------

tsqlParser::Derived_tableContext::Derived_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::SubqueryContext* tsqlParser::Derived_tableContext::subquery() {
  return getRuleContext<tsqlParser::SubqueryContext>(0);
}

tree::TerminalNode* tsqlParser::Derived_tableContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Derived_tableContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::Table_value_constructorContext* tsqlParser::Derived_tableContext::table_value_constructor() {
  return getRuleContext<tsqlParser::Table_value_constructorContext>(0);
}

tsqlParser::Table_aliasContext* tsqlParser::Derived_tableContext::table_alias() {
  return getRuleContext<tsqlParser::Table_aliasContext>(0);
}

tsqlParser::Column_alias_listContext* tsqlParser::Derived_tableContext::column_alias_list() {
  return getRuleContext<tsqlParser::Column_alias_listContext>(0);
}


size_t tsqlParser::Derived_tableContext::getRuleIndex() const {
  return tsqlParser::RuleDerived_table;
}


antlrcpp::Any tsqlParser::Derived_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDerived_table(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Derived_tableContext* tsqlParser::derived_table() {
  Derived_tableContext *_localctx = _tracker.createInstance<Derived_tableContext>(_ctx, getState());
  enterRule(_localctx, 290, tsqlParser::RuleDerived_table);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2757);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2746);
      subquery();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2747);
      match(tsqlParser::LR_BRACKET);
      setState(2748);
      subquery();
      setState(2749);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2751);
      match(tsqlParser::LR_BRACKET);
      setState(2752);
      table_value_constructor();
      setState(2753);
      match(tsqlParser::RR_BRACKET);
      setState(2754);
      table_alias();
      setState(2755);
      column_alias_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_callContext ------------------------------------------------------------------

tsqlParser::Function_callContext::Function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t tsqlParser::Function_callContext::getRuleIndex() const {
  return tsqlParser::RuleFunction_call;
}

void tsqlParser::Function_callContext::copyFrom(Function_callContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Standard_callContext ------------------------------------------------------------------

tsqlParser::Scalar_function_nameContext* tsqlParser::Standard_callContext::scalar_function_name() {
  return getRuleContext<tsqlParser::Scalar_function_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::Expression_listContext* tsqlParser::Standard_callContext::expression_list() {
  return getRuleContext<tsqlParser::Expression_listContext>(0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::BINARY_CHECKSUM() {
  return getToken(tsqlParser::BINARY_CHECKSUM, 0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::STAR() {
  return getToken(tsqlParser::STAR, 0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::CONVERT() {
  return getToken(tsqlParser::CONVERT, 0);
}

tsqlParser::Data_typeContext* tsqlParser::Standard_callContext::data_type() {
  return getRuleContext<tsqlParser::Data_typeContext>(0);
}

std::vector<tree::TerminalNode *> tsqlParser::Standard_callContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Standard_callContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

std::vector<tsqlParser::ExpressionContext *> tsqlParser::Standard_callContext::expression() {
  return getRuleContexts<tsqlParser::ExpressionContext>();
}

tsqlParser::ExpressionContext* tsqlParser::Standard_callContext::expression(size_t i) {
  return getRuleContext<tsqlParser::ExpressionContext>(i);
}

tree::TerminalNode* tsqlParser::Standard_callContext::COALESCE() {
  return getToken(tsqlParser::COALESCE, 0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::DATEADD() {
  return getToken(tsqlParser::DATEADD, 0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::ID() {
  return getToken(tsqlParser::ID, 0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::DATEDIFF() {
  return getToken(tsqlParser::DATEDIFF, 0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::DATENAME() {
  return getToken(tsqlParser::DATENAME, 0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::DATEPART() {
  return getToken(tsqlParser::DATEPART, 0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::DATETIMEOFFSETFROMPARTS() {
  return getToken(tsqlParser::DATETIMEOFFSETFROMPARTS, 0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::IDENTITY() {
  return getToken(tsqlParser::IDENTITY, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Standard_callContext::DECIMAL() {
  return getTokens(tsqlParser::DECIMAL);
}

tree::TerminalNode* tsqlParser::Standard_callContext::DECIMAL(size_t i) {
  return getToken(tsqlParser::DECIMAL, i);
}

tree::TerminalNode* tsqlParser::Standard_callContext::IIF() {
  return getToken(tsqlParser::IIF, 0);
}

tsqlParser::Search_conditionContext* tsqlParser::Standard_callContext::search_condition() {
  return getRuleContext<tsqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::NULLIF() {
  return getToken(tsqlParser::NULLIF, 0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::STRING_SPLIT() {
  return getToken(tsqlParser::STRING_SPLIT, 0);
}

tree::TerminalNode* tsqlParser::Standard_callContext::TRY_CONVERT() {
  return getToken(tsqlParser::TRY_CONVERT, 0);
}

tsqlParser::Standard_callContext::Standard_callContext(Function_callContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Standard_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitStandard_call(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Aggregate_callContext ------------------------------------------------------------------

tsqlParser::Aggregate_windowed_functionContext* tsqlParser::Aggregate_callContext::aggregate_windowed_function() {
  return getRuleContext<tsqlParser::Aggregate_windowed_functionContext>(0);
}

tsqlParser::Aggregate_callContext::Aggregate_callContext(Function_callContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Aggregate_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitAggregate_call(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Nvf_callContext ------------------------------------------------------------------

tsqlParser::Next_value_for_functionContext* tsqlParser::Nvf_callContext::next_value_for_function() {
  return getRuleContext<tsqlParser::Next_value_for_functionContext>(0);
}

tsqlParser::Nvf_callContext::Nvf_callContext(Function_callContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Nvf_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitNvf_call(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Rank_callContext ------------------------------------------------------------------

tsqlParser::Ranking_windowed_functionContext* tsqlParser::Rank_callContext::ranking_windowed_function() {
  return getRuleContext<tsqlParser::Ranking_windowed_functionContext>(0);
}

tsqlParser::Rank_callContext::Rank_callContext(Function_callContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Rank_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitRank_call(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expression_callContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Expression_callContext::PARSE() {
  return getToken(tsqlParser::PARSE, 0);
}

tree::TerminalNode* tsqlParser::Expression_callContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Expression_callContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

tree::TerminalNode* tsqlParser::Expression_callContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tsqlParser::ExpressionContext *> tsqlParser::Expression_callContext::expression() {
  return getRuleContexts<tsqlParser::ExpressionContext>();
}

tsqlParser::ExpressionContext* tsqlParser::Expression_callContext::expression(size_t i) {
  return getRuleContext<tsqlParser::ExpressionContext>(i);
}

tsqlParser::Data_typeContext* tsqlParser::Expression_callContext::data_type() {
  return getRuleContext<tsqlParser::Data_typeContext>(0);
}

tree::TerminalNode* tsqlParser::Expression_callContext::USING() {
  return getToken(tsqlParser::USING, 0);
}

tree::TerminalNode* tsqlParser::Expression_callContext::TRY_PARSE() {
  return getToken(tsqlParser::TRY_PARSE, 0);
}

tsqlParser::Expression_callContext::Expression_callContext(Function_callContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Expression_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitExpression_call(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_callContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Simple_callContext::CHECKSUM() {
  return getToken(tsqlParser::CHECKSUM, 0);
}

tree::TerminalNode* tsqlParser::Simple_callContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Simple_callContext::STAR() {
  return getToken(tsqlParser::STAR, 0);
}

tree::TerminalNode* tsqlParser::Simple_callContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Simple_callContext::CURRENT_TIMESTAMP() {
  return getToken(tsqlParser::CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* tsqlParser::Simple_callContext::CURRENT_USER() {
  return getToken(tsqlParser::CURRENT_USER, 0);
}

tree::TerminalNode* tsqlParser::Simple_callContext::MIN_ACTIVE_ROWVERSION() {
  return getToken(tsqlParser::MIN_ACTIVE_ROWVERSION, 0);
}

tree::TerminalNode* tsqlParser::Simple_callContext::SESSION_USER() {
  return getToken(tsqlParser::SESSION_USER, 0);
}

tree::TerminalNode* tsqlParser::Simple_callContext::SYSTEM_USER() {
  return getToken(tsqlParser::SYSTEM_USER, 0);
}

tsqlParser::Simple_callContext::Simple_callContext(Function_callContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Simple_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSimple_call(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Cast_callContext ------------------------------------------------------------------

tree::TerminalNode* tsqlParser::Cast_callContext::CAST() {
  return getToken(tsqlParser::CAST, 0);
}

tree::TerminalNode* tsqlParser::Cast_callContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Cast_callContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Cast_callContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

tree::TerminalNode* tsqlParser::Cast_callContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::Data_typeContext* tsqlParser::Cast_callContext::data_type() {
  return getRuleContext<tsqlParser::Data_typeContext>(0);
}

tree::TerminalNode* tsqlParser::Cast_callContext::TRY_CAST() {
  return getToken(tsqlParser::TRY_CAST, 0);
}

tsqlParser::Cast_callContext::Cast_callContext(Function_callContext *ctx) { copyFrom(ctx); }


antlrcpp::Any tsqlParser::Cast_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCast_call(this);
  else
    return visitor->visitChildren(this);
}
tsqlParser::Function_callContext* tsqlParser::function_call() {
  Function_callContext *_localctx = _tracker.createInstance<Function_callContext>(_ctx, getState());
  enterRule(_localctx, 292, tsqlParser::RuleFunction_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2932);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx)) {
    case 1: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Rank_callContext>(_localctx));
      enterOuterAlt(_localctx, 1);
      setState(2759);
      ranking_windowed_function();
      break;
    }

    case 2: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Aggregate_callContext>(_localctx));
      enterOuterAlt(_localctx, 2);
      setState(2760);
      aggregate_windowed_function();
      break;
    }

    case 3: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 3);
      setState(2761);
      scalar_function_name();
      setState(2762);
      match(tsqlParser::LR_BRACKET);
      setState(2764);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << tsqlParser::CASE)
        | (1ULL << tsqlParser::COALESCE)
        | (1ULL << tsqlParser::CONVERT)
        | (1ULL << tsqlParser::CURRENT_TIMESTAMP)
        | (1ULL << tsqlParser::CURRENT_USER)
        | (1ULL << tsqlParser::DEFAULT))) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & ((1ULL << (tsqlParser::EXP - 66))
        | (1ULL << (tsqlParser::FORCESEEK - 66))
        | (1ULL << (tsqlParser::IDENTITY - 66))
        | (1ULL << (tsqlParser::IIF - 66))
        | (1ULL << (tsqlParser::LEFT - 66))
        | (1ULL << (tsqlParser::LOG - 66))
        | (1ULL << (tsqlParser::LOG10 - 66))
        | (1ULL << (tsqlParser::NEXT - 66))
        | (1ULL << (tsqlParser::NULL_ - 66))
        | (1ULL << (tsqlParser::NULLIF - 66))
        | (1ULL << (tsqlParser::NUMERIC - 66))
        | (1ULL << (tsqlParser::OVER - 66)))) != 0) || ((((_la - 152) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 152)) & ((1ULL << (tsqlParser::RIGHT - 152))
        | (1ULL << (tsqlParser::SESSION_USER - 152))
        | (1ULL << (tsqlParser::SIGN - 152))
        | (1ULL << (tsqlParser::SYSTEM_USER - 152))
        | (1ULL << (tsqlParser::TRY_CAST - 152))
        | (1ULL << (tsqlParser::TRY_CONVERT - 152))
        | (1ULL << (tsqlParser::TRY_PARSE - 152))
        | (1ULL << (tsqlParser::VALUE - 152))
        | (1ULL << (tsqlParser::ABSOLUTE - 152))
        | (1ULL << (tsqlParser::APPLY - 152)))) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & ((1ULL << (tsqlParser::AUTO - 217))
        | (1ULL << (tsqlParser::AVG - 217))
        | (1ULL << (tsqlParser::BASE64 - 217))
        | (1ULL << (tsqlParser::BINARY_CHECKSUM - 217))
        | (1ULL << (tsqlParser::CALLER - 217))
        | (1ULL << (tsqlParser::CAST - 217))
        | (1ULL << (tsqlParser::CATCH - 217))
        | (1ULL << (tsqlParser::CEILING - 217))
        | (1ULL << (tsqlParser::CHECKSUM - 217))
        | (1ULL << (tsqlParser::CHECKSUM_AGG - 217))
        | (1ULL << (tsqlParser::COMMITTED - 217))
        | (1ULL << (tsqlParser::CONCAT - 217))
        | (1ULL << (tsqlParser::CONTROL - 217))
        | (1ULL << (tsqlParser::COOKIE - 217))
        | (1ULL << (tsqlParser::COS - 217))
        | (1ULL << (tsqlParser::COUNT - 217))
        | (1ULL << (tsqlParser::COUNT_BIG - 217))
        | (1ULL << (tsqlParser::DATE - 217))
        | (1ULL << (tsqlParser::DATEADD - 217))
        | (1ULL << (tsqlParser::DATEDIFF - 217))
        | (1ULL << (tsqlParser::DATENAME - 217))
        | (1ULL << (tsqlParser::DATEPART - 217))
        | (1ULL << (tsqlParser::DATETIMEOFFSETFROMPARTS - 217))
        | (1ULL << (tsqlParser::DELAY - 217))
        | (1ULL << (tsqlParser::DELETED - 217))
        | (1ULL << (tsqlParser::DENSE_RANK - 217))
        | (1ULL << (tsqlParser::DISABLE - 217))
        | (1ULL << (tsqlParser::DYNAMIC - 217))
        | (1ULL << (tsqlParser::ENCRYPTION - 217))
        | (1ULL << (tsqlParser::EXIST - 217))
        | (1ULL << (tsqlParser::EXPAND - 217))
        | (1ULL << (tsqlParser::FAST - 217))
        | (1ULL << (tsqlParser::FAST_FORWARD - 217)))) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & ((1ULL << (tsqlParser::FIRST - 281))
        | (1ULL << (tsqlParser::FIRST_VALUE - 281))
        | (1ULL << (tsqlParser::FLOOR - 281))
        | (1ULL << (tsqlParser::FOLLOWING - 281))
        | (1ULL << (tsqlParser::FORCE - 281))
        | (1ULL << (tsqlParser::FORCED - 281))
        | (1ULL << (tsqlParser::FORWARD_ONLY - 281))
        | (1ULL << (tsqlParser::FULLSCAN - 281))
        | (1ULL << (tsqlParser::GLOBAL - 281))
        | (1ULL << (tsqlParser::GROUPING - 281))
        | (1ULL << (tsqlParser::GROUPING_ID - 281))
        | (1ULL << (tsqlParser::HASH - 281))
        | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 281))
        | (1ULL << (tsqlParser::IMPERSONATE - 281))
        | (1ULL << (tsqlParser::INSENSITIVE - 281))
        | (1ULL << (tsqlParser::INSERTED - 281))
        | (1ULL << (tsqlParser::ISOLATION - 281))
        | (1ULL << (tsqlParser::IO - 281))
        | (1ULL << (tsqlParser::KEEP - 281))
        | (1ULL << (tsqlParser::KEEPFIXED - 281))
        | (1ULL << (tsqlParser::KEYSET - 281))
        | (1ULL << (tsqlParser::LAG - 281))
        | (1ULL << (tsqlParser::LAST - 281))
        | (1ULL << (tsqlParser::LAST_VALUE - 281))
        | (1ULL << (tsqlParser::LEAD - 281))
        | (1ULL << (tsqlParser::LEVEL - 281))
        | (1ULL << (tsqlParser::LOCAL - 281))
        | (1ULL << (tsqlParser::LOCK_ESCALATION - 281))
        | (1ULL << (tsqlParser::LOGIN - 281))
        | (1ULL << (tsqlParser::LOOP - 281))
        | (1ULL << (tsqlParser::MARK - 281))
        | (1ULL << (tsqlParser::MAX - 281))
        | (1ULL << (tsqlParser::MAXDOP - 281))
        | (1ULL << (tsqlParser::MAXRECURSION - 281))
        | (1ULL << (tsqlParser::MIN - 281))
        | (1ULL << (tsqlParser::MIN_ACTIVE_ROWVERSION - 281))
        | (1ULL << (tsqlParser::MODIFY - 281))
        | (1ULL << (tsqlParser::NAME - 281))
        | (1ULL << (tsqlParser::NOCOUNT - 281))
        | (1ULL << (tsqlParser::NODES - 281))
        | (1ULL << (tsqlParser::NOEXPAND - 281))
        | (1ULL << (tsqlParser::NORECOMPUTE - 281))
        | (1ULL << (tsqlParser::NTILE - 281))
        | (1ULL << (tsqlParser::NUMBER - 281)))) != 0) || ((((_la - 347) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 347)) & ((1ULL << (tsqlParser::OFFSET - 347))
        | (1ULL << (tsqlParser::ONLINE - 347))
        | (1ULL << (tsqlParser::ONLY - 347))
        | (1ULL << (tsqlParser::OPTIMISTIC - 347))
        | (1ULL << (tsqlParser::OPTIMIZE - 347))
        | (1ULL << (tsqlParser::OUT - 347))
        | (1ULL << (tsqlParser::OUTPUT - 347))
        | (1ULL << (tsqlParser::OWNER - 347))
        | (1ULL << (tsqlParser::PARAMETERIZATION - 347))
        | (1ULL << (tsqlParser::PARSE - 347))
        | (1ULL << (tsqlParser::PARTITION - 347))
        | (1ULL << (tsqlParser::PATH - 347))
        | (1ULL << (tsqlParser::PERCENTILE_CONT - 347))
        | (1ULL << (tsqlParser::POWER - 347))
        | (1ULL << (tsqlParser::PRECEDING - 347))
        | (1ULL << (tsqlParser::PRIOR - 347))
        | (1ULL << (tsqlParser::PRIVILEGES - 347))
        | (1ULL << (tsqlParser::QUERY - 347))
        | (1ULL << (tsqlParser::RANGE - 347))
        | (1ULL << (tsqlParser::RANK - 347))
        | (1ULL << (tsqlParser::READONLY - 347))
        | (1ULL << (tsqlParser::READ_ONLY - 347))
        | (1ULL << (tsqlParser::RECOMPILE - 347))
        | (1ULL << (tsqlParser::RELATIVE - 347))
        | (1ULL << (tsqlParser::REMOTE - 347))
        | (1ULL << (tsqlParser::REPEATABLE - 347))
        | (1ULL << (tsqlParser::ROBUST - 347))
        | (1ULL << (tsqlParser::ROOT - 347))
        | (1ULL << (tsqlParser::ROUND - 347))
        | (1ULL << (tsqlParser::ROW - 347))
        | (1ULL << (tsqlParser::ROWGUID - 347))
        | (1ULL << (tsqlParser::ROWS - 347))
        | (1ULL << (tsqlParser::ROW_NUMBER - 347))
        | (1ULL << (tsqlParser::SAMPLE - 347))
        | (1ULL << (tsqlParser::SCHEMABINDING - 347))
        | (1ULL << (tsqlParser::SCROLL - 347))
        | (1ULL << (tsqlParser::SCROLL_LOCKS - 347))
        | (1ULL << (tsqlParser::SELF - 347))
        | (1ULL << (tsqlParser::SERIALIZABLE - 347))
        | (1ULL << (tsqlParser::SIMPLE - 347))
        | (1ULL << (tsqlParser::SIN - 347))
        | (1ULL << (tsqlParser::SIZE - 347))
        | (1ULL << (tsqlParser::SNAPSHOT - 347))
        | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 347))
        | (1ULL << (tsqlParser::STATIC - 347))
        | (1ULL << (tsqlParser::STATS_STREAM - 347))
        | (1ULL << (tsqlParser::STDEV - 347))
        | (1ULL << (tsqlParser::STDEVP - 347))
        | (1ULL << (tsqlParser::STRING_AGG - 347))
        | (1ULL << (tsqlParser::STRING_SPLIT - 347))
        | (1ULL << (tsqlParser::SUM - 347)))) != 0) || ((((_la - 411) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 411)) & ((1ULL << (tsqlParser::SQRT - 411))
        | (1ULL << (tsqlParser::SQUARE - 411))
        | (1ULL << (tsqlParser::TAN - 411))
        | (1ULL << (tsqlParser::TEXTIMAGE_ON - 411))
        | (1ULL << (tsqlParser::THROW - 411))
        | (1ULL << (tsqlParser::TIES - 411))
        | (1ULL << (tsqlParser::TIME - 411))
        | (1ULL << (tsqlParser::TRY - 411))
        | (1ULL << (tsqlParser::TYPE - 411))
        | (1ULL << (tsqlParser::TYPE_WARNING - 411))
        | (1ULL << (tsqlParser::UNBOUNDED - 411))
        | (1ULL << (tsqlParser::UNCOMMITTED - 411))
        | (1ULL << (tsqlParser::UNKNOWN - 411))
        | (1ULL << (tsqlParser::USING - 411))
        | (1ULL << (tsqlParser::VAR - 411))
        | (1ULL << (tsqlParser::VARP - 411))
        | (1ULL << (tsqlParser::VIEWS - 411))
        | (1ULL << (tsqlParser::VIEW_METADATA - 411))
        | (1ULL << (tsqlParser::WORK - 411))
        | (1ULL << (tsqlParser::XML - 411))
        | (1ULL << (tsqlParser::XMLNAMESPACES - 411))
        | (1ULL << (tsqlParser::ZONE - 411))
        | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 411))
        | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 411))
        | (1ULL << (tsqlParser::LOCAL_ID - 411))
        | (1ULL << (tsqlParser::DECIMAL - 411))
        | (1ULL << (tsqlParser::ID - 411))
        | (1ULL << (tsqlParser::STRING - 411))
        | (1ULL << (tsqlParser::BINARY - 411))
        | (1ULL << (tsqlParser::FLOAT - 411))
        | (1ULL << (tsqlParser::REAL - 411))
        | (1ULL << (tsqlParser::DOLLAR - 411))
        | (1ULL << (tsqlParser::LR_BRACKET - 411)))) != 0) || ((((_la - 480) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 480)) & ((1ULL << (tsqlParser::PLUS - 480))
        | (1ULL << (tsqlParser::MINUS - 480))
        | (1ULL << (tsqlParser::BIT_NOT - 480)))) != 0)) {
        setState(2763);
        expression_list();
      }
      setState(2766);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 4: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Nvf_callContext>(_localctx));
      enterOuterAlt(_localctx, 4);
      setState(2768);
      next_value_for_function();
      break;
    }

    case 5: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 5);
      setState(2769);
      match(tsqlParser::BINARY_CHECKSUM);
      setState(2770);
      match(tsqlParser::LR_BRACKET);
      setState(2771);
      match(tsqlParser::STAR);
      setState(2772);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 6: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Cast_callContext>(_localctx));
      enterOuterAlt(_localctx, 6);
      setState(2773);
      match(tsqlParser::CAST);
      setState(2774);
      match(tsqlParser::LR_BRACKET);
      setState(2775);
      expression(0);
      setState(2776);
      match(tsqlParser::AS);
      setState(2777);
      dynamic_cast<Cast_callContext *>(_localctx)->alias = data_type();
      setState(2778);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 7: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 7);
      setState(2780);
      match(tsqlParser::CONVERT);
      setState(2781);
      match(tsqlParser::LR_BRACKET);
      setState(2782);
      data_type();
      setState(2783);
      match(tsqlParser::COMMA);
      setState(2784);
      expression(0);
      setState(2787);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::COMMA) {
        setState(2785);
        match(tsqlParser::COMMA);
        setState(2786);
        dynamic_cast<Standard_callContext *>(_localctx)->style = expression(0);
      }
      setState(2789);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 8: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Simple_callContext>(_localctx));
      enterOuterAlt(_localctx, 8);
      setState(2791);
      match(tsqlParser::CHECKSUM);
      setState(2792);
      match(tsqlParser::LR_BRACKET);
      setState(2793);
      match(tsqlParser::STAR);
      setState(2794);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 9: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 9);
      setState(2795);
      match(tsqlParser::COALESCE);
      setState(2796);
      match(tsqlParser::LR_BRACKET);
      setState(2797);
      expression_list();
      setState(2798);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 10: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Simple_callContext>(_localctx));
      enterOuterAlt(_localctx, 10);
      setState(2800);
      match(tsqlParser::CURRENT_TIMESTAMP);
      break;
    }

    case 11: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Simple_callContext>(_localctx));
      enterOuterAlt(_localctx, 11);
      setState(2801);
      match(tsqlParser::CURRENT_USER);
      break;
    }

    case 12: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 12);
      setState(2802);
      match(tsqlParser::DATEADD);
      setState(2803);
      match(tsqlParser::LR_BRACKET);
      setState(2804);
      match(tsqlParser::ID);
      setState(2805);
      match(tsqlParser::COMMA);
      setState(2806);
      expression(0);
      setState(2807);
      match(tsqlParser::COMMA);
      setState(2808);
      expression(0);
      setState(2809);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 13: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 13);
      setState(2811);
      match(tsqlParser::DATEDIFF);
      setState(2812);
      match(tsqlParser::LR_BRACKET);
      setState(2813);
      match(tsqlParser::ID);
      setState(2814);
      match(tsqlParser::COMMA);
      setState(2815);
      expression(0);
      setState(2816);
      match(tsqlParser::COMMA);
      setState(2817);
      expression(0);
      setState(2818);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 14: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 14);
      setState(2820);
      match(tsqlParser::DATENAME);
      setState(2821);
      match(tsqlParser::LR_BRACKET);
      setState(2822);
      match(tsqlParser::ID);
      setState(2823);
      match(tsqlParser::COMMA);
      setState(2824);
      expression(0);
      setState(2825);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 15: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 15);
      setState(2827);
      match(tsqlParser::DATEPART);
      setState(2828);
      match(tsqlParser::LR_BRACKET);
      setState(2829);
      match(tsqlParser::ID);
      setState(2830);
      match(tsqlParser::COMMA);
      setState(2831);
      expression(0);
      setState(2832);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 16: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 16);
      setState(2834);
      match(tsqlParser::DATETIMEOFFSETFROMPARTS);
      setState(2835);
      match(tsqlParser::LR_BRACKET);
      setState(2836);
      expression(0);
      setState(2837);
      match(tsqlParser::COMMA);
      setState(2838);
      expression(0);
      setState(2839);
      match(tsqlParser::COMMA);
      setState(2840);
      expression(0);
      setState(2841);
      match(tsqlParser::COMMA);
      setState(2842);
      expression(0);
      setState(2843);
      match(tsqlParser::COMMA);
      setState(2844);
      expression(0);
      setState(2845);
      match(tsqlParser::COMMA);
      setState(2846);
      expression(0);
      setState(2847);
      match(tsqlParser::COMMA);
      setState(2848);
      expression(0);
      setState(2849);
      match(tsqlParser::COMMA);
      setState(2850);
      expression(0);
      setState(2851);
      match(tsqlParser::COMMA);
      setState(2852);
      expression(0);
      setState(2853);
      match(tsqlParser::COMMA);
      setState(2854);
      expression(0);
      setState(2855);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 17: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 17);
      setState(2857);
      match(tsqlParser::IDENTITY);
      setState(2858);
      match(tsqlParser::LR_BRACKET);
      setState(2859);
      data_type();
      setState(2862);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 402, _ctx)) {
      case 1: {
        setState(2860);
        match(tsqlParser::COMMA);
        setState(2861);
        dynamic_cast<Standard_callContext *>(_localctx)->seed = match(tsqlParser::DECIMAL);
        break;
      }

      default:
        break;
      }
      setState(2866);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::COMMA) {
        setState(2864);
        match(tsqlParser::COMMA);
        setState(2865);
        dynamic_cast<Standard_callContext *>(_localctx)->increment = match(tsqlParser::DECIMAL);
      }
      setState(2868);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 18: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 18);
      setState(2870);
      match(tsqlParser::IIF);
      setState(2871);
      match(tsqlParser::LR_BRACKET);
      setState(2872);
      search_condition(0);
      setState(2873);
      match(tsqlParser::COMMA);
      setState(2874);
      expression(0);
      setState(2875);
      match(tsqlParser::COMMA);
      setState(2876);
      expression(0);
      setState(2877);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 19: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Simple_callContext>(_localctx));
      enterOuterAlt(_localctx, 19);
      setState(2879);
      match(tsqlParser::MIN_ACTIVE_ROWVERSION);
      break;
    }

    case 20: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 20);
      setState(2880);
      match(tsqlParser::NULLIF);
      setState(2881);
      match(tsqlParser::LR_BRACKET);
      setState(2882);
      expression(0);
      setState(2883);
      match(tsqlParser::COMMA);
      setState(2884);
      expression(0);
      setState(2885);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 21: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Expression_callContext>(_localctx));
      enterOuterAlt(_localctx, 21);
      setState(2887);
      match(tsqlParser::PARSE);
      setState(2888);
      match(tsqlParser::LR_BRACKET);
      setState(2889);
      dynamic_cast<Expression_callContext *>(_localctx)->left = expression(0);
      setState(2890);
      match(tsqlParser::AS);
      setState(2891);
      dynamic_cast<Expression_callContext *>(_localctx)->alias = data_type();
      setState(2894);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::USING) {
        setState(2892);
        match(tsqlParser::USING);
        setState(2893);
        dynamic_cast<Expression_callContext *>(_localctx)->right = expression(0);
      }
      setState(2896);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 22: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Simple_callContext>(_localctx));
      enterOuterAlt(_localctx, 22);
      setState(2898);
      match(tsqlParser::SESSION_USER);
      break;
    }

    case 23: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 23);
      setState(2899);
      match(tsqlParser::STRING_SPLIT);
      setState(2900);
      match(tsqlParser::LR_BRACKET);
      setState(2901);
      expression(0);
      setState(2902);
      match(tsqlParser::COMMA);
      setState(2903);
      expression(0);
      setState(2904);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 24: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Simple_callContext>(_localctx));
      enterOuterAlt(_localctx, 24);
      setState(2906);
      match(tsqlParser::SYSTEM_USER);
      break;
    }

    case 25: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Standard_callContext>(_localctx));
      enterOuterAlt(_localctx, 25);
      setState(2907);
      match(tsqlParser::TRY_CONVERT);
      setState(2908);
      match(tsqlParser::LR_BRACKET);
      setState(2909);
      data_type();
      setState(2910);
      match(tsqlParser::COMMA);
      setState(2911);
      expression(0);
      setState(2912);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 26: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Cast_callContext>(_localctx));
      enterOuterAlt(_localctx, 26);
      setState(2914);
      match(tsqlParser::TRY_CAST);
      setState(2915);
      match(tsqlParser::LR_BRACKET);
      setState(2916);
      expression(0);
      setState(2917);
      match(tsqlParser::AS);
      setState(2918);
      dynamic_cast<Cast_callContext *>(_localctx)->alias = data_type();
      setState(2919);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 27: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<tsqlParser::Expression_callContext>(_localctx));
      enterOuterAlt(_localctx, 27);
      setState(2921);
      match(tsqlParser::TRY_PARSE);
      setState(2922);
      match(tsqlParser::LR_BRACKET);
      setState(2923);
      dynamic_cast<Expression_callContext *>(_localctx)->left = expression(0);
      setState(2924);
      match(tsqlParser::AS);
      setState(2925);
      dynamic_cast<Expression_callContext *>(_localctx)->alias = data_type();
      setState(2928);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::USING) {
        setState(2926);
        match(tsqlParser::USING);
        setState(2927);
        dynamic_cast<Expression_callContext *>(_localctx)->right = expression(0);
      }
      setState(2930);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_sectionContext ------------------------------------------------------------------

tsqlParser::Switch_sectionContext::Switch_sectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Switch_sectionContext::WHEN() {
  return getToken(tsqlParser::WHEN, 0);
}

tree::TerminalNode* tsqlParser::Switch_sectionContext::THEN() {
  return getToken(tsqlParser::THEN, 0);
}

std::vector<tsqlParser::ExpressionContext *> tsqlParser::Switch_sectionContext::expression() {
  return getRuleContexts<tsqlParser::ExpressionContext>();
}

tsqlParser::ExpressionContext* tsqlParser::Switch_sectionContext::expression(size_t i) {
  return getRuleContext<tsqlParser::ExpressionContext>(i);
}


size_t tsqlParser::Switch_sectionContext::getRuleIndex() const {
  return tsqlParser::RuleSwitch_section;
}


antlrcpp::Any tsqlParser::Switch_sectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSwitch_section(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Switch_sectionContext* tsqlParser::switch_section() {
  Switch_sectionContext *_localctx = _tracker.createInstance<Switch_sectionContext>(_ctx, getState());
  enterRule(_localctx, 294, tsqlParser::RuleSwitch_section);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2934);
    match(tsqlParser::WHEN);
    setState(2935);
    dynamic_cast<Switch_sectionContext *>(_localctx)->whenExpr = expression(0);
    setState(2936);
    match(tsqlParser::THEN);
    setState(2937);
    dynamic_cast<Switch_sectionContext *>(_localctx)->thenExpr = expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_search_condition_sectionContext ------------------------------------------------------------------

tsqlParser::Switch_search_condition_sectionContext::Switch_search_condition_sectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Switch_search_condition_sectionContext::WHEN() {
  return getToken(tsqlParser::WHEN, 0);
}

tree::TerminalNode* tsqlParser::Switch_search_condition_sectionContext::THEN() {
  return getToken(tsqlParser::THEN, 0);
}

tsqlParser::Search_conditionContext* tsqlParser::Switch_search_condition_sectionContext::search_condition() {
  return getRuleContext<tsqlParser::Search_conditionContext>(0);
}

tsqlParser::ExpressionContext* tsqlParser::Switch_search_condition_sectionContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}


size_t tsqlParser::Switch_search_condition_sectionContext::getRuleIndex() const {
  return tsqlParser::RuleSwitch_search_condition_section;
}


antlrcpp::Any tsqlParser::Switch_search_condition_sectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSwitch_search_condition_section(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Switch_search_condition_sectionContext* tsqlParser::switch_search_condition_section() {
  Switch_search_condition_sectionContext *_localctx = _tracker.createInstance<Switch_search_condition_sectionContext>(_ctx, getState());
  enterRule(_localctx, 296, tsqlParser::RuleSwitch_search_condition_section);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2939);
    match(tsqlParser::WHEN);
    setState(2940);
    dynamic_cast<Switch_search_condition_sectionContext *>(_localctx)->whenExpr = search_condition(0);
    setState(2941);
    match(tsqlParser::THEN);
    setState(2942);
    dynamic_cast<Switch_search_condition_sectionContext *>(_localctx)->thenExpr = expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_table_hintsContext ------------------------------------------------------------------

tsqlParser::With_table_hintsContext::With_table_hintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::With_table_hintsContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

std::vector<tsqlParser::Table_hintContext *> tsqlParser::With_table_hintsContext::table_hint() {
  return getRuleContexts<tsqlParser::Table_hintContext>();
}

tsqlParser::Table_hintContext* tsqlParser::With_table_hintsContext::table_hint(size_t i) {
  return getRuleContext<tsqlParser::Table_hintContext>(i);
}

tree::TerminalNode* tsqlParser::With_table_hintsContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::With_table_hintsContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::With_table_hintsContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::With_table_hintsContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::With_table_hintsContext::getRuleIndex() const {
  return tsqlParser::RuleWith_table_hints;
}


antlrcpp::Any tsqlParser::With_table_hintsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitWith_table_hints(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::With_table_hintsContext* tsqlParser::with_table_hints() {
  With_table_hintsContext *_localctx = _tracker.createInstance<With_table_hintsContext>(_ctx, getState());
  enterRule(_localctx, 298, tsqlParser::RuleWith_table_hints);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2945);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WITH) {
      setState(2944);
      match(tsqlParser::WITH);
    }
    setState(2947);
    match(tsqlParser::LR_BRACKET);
    setState(2948);
    table_hint();
    setState(2953);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(2949);
      match(tsqlParser::COMMA);
      setState(2950);
      table_hint();
      setState(2955);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2956);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_with_table_hintsContext ------------------------------------------------------------------

tsqlParser::Insert_with_table_hintsContext::Insert_with_table_hintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Insert_with_table_hintsContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

tree::TerminalNode* tsqlParser::Insert_with_table_hintsContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

std::vector<tsqlParser::Table_hintContext *> tsqlParser::Insert_with_table_hintsContext::table_hint() {
  return getRuleContexts<tsqlParser::Table_hintContext>();
}

tsqlParser::Table_hintContext* tsqlParser::Insert_with_table_hintsContext::table_hint(size_t i) {
  return getRuleContext<tsqlParser::Table_hintContext>(i);
}

tree::TerminalNode* tsqlParser::Insert_with_table_hintsContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Insert_with_table_hintsContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Insert_with_table_hintsContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Insert_with_table_hintsContext::getRuleIndex() const {
  return tsqlParser::RuleInsert_with_table_hints;
}


antlrcpp::Any tsqlParser::Insert_with_table_hintsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitInsert_with_table_hints(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Insert_with_table_hintsContext* tsqlParser::insert_with_table_hints() {
  Insert_with_table_hintsContext *_localctx = _tracker.createInstance<Insert_with_table_hintsContext>(_ctx, getState());
  enterRule(_localctx, 300, tsqlParser::RuleInsert_with_table_hints);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2958);
    match(tsqlParser::WITH);
    setState(2959);
    match(tsqlParser::LR_BRACKET);
    setState(2960);
    table_hint();
    setState(2965);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(2961);
      match(tsqlParser::COMMA);
      setState(2962);
      table_hint();
      setState(2967);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2968);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_hintContext ------------------------------------------------------------------

tsqlParser::Table_hintContext::Table_hintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Table_hintContext::NOEXPAND() {
  return getToken(tsqlParser::NOEXPAND, 0);
}

tree::TerminalNode* tsqlParser::Table_hintContext::INDEX() {
  return getToken(tsqlParser::INDEX, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Table_hintContext::LR_BRACKET() {
  return getTokens(tsqlParser::LR_BRACKET);
}

tree::TerminalNode* tsqlParser::Table_hintContext::LR_BRACKET(size_t i) {
  return getToken(tsqlParser::LR_BRACKET, i);
}

std::vector<tsqlParser::Index_valueContext *> tsqlParser::Table_hintContext::index_value() {
  return getRuleContexts<tsqlParser::Index_valueContext>();
}

tsqlParser::Index_valueContext* tsqlParser::Table_hintContext::index_value(size_t i) {
  return getRuleContext<tsqlParser::Index_valueContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Table_hintContext::RR_BRACKET() {
  return getTokens(tsqlParser::RR_BRACKET);
}

tree::TerminalNode* tsqlParser::Table_hintContext::RR_BRACKET(size_t i) {
  return getToken(tsqlParser::RR_BRACKET, i);
}

tree::TerminalNode* tsqlParser::Table_hintContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Table_hintContext::FORCESEEK() {
  return getToken(tsqlParser::FORCESEEK, 0);
}

tree::TerminalNode* tsqlParser::Table_hintContext::SERIALIZABLE() {
  return getToken(tsqlParser::SERIALIZABLE, 0);
}

tree::TerminalNode* tsqlParser::Table_hintContext::SNAPSHOT() {
  return getToken(tsqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* tsqlParser::Table_hintContext::SPATIAL_WINDOW_MAX_CELLS() {
  return getToken(tsqlParser::SPATIAL_WINDOW_MAX_CELLS, 0);
}

tree::TerminalNode* tsqlParser::Table_hintContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Table_hintContext::ID() {
  return getTokens(tsqlParser::ID);
}

tree::TerminalNode* tsqlParser::Table_hintContext::ID(size_t i) {
  return getToken(tsqlParser::ID, i);
}

std::vector<tree::TerminalNode *> tsqlParser::Table_hintContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Table_hintContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Table_hintContext::getRuleIndex() const {
  return tsqlParser::RuleTable_hint;
}


antlrcpp::Any tsqlParser::Table_hintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTable_hint(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Table_hintContext* tsqlParser::table_hint() {
  Table_hintContext *_localctx = _tracker.createInstance<Table_hintContext>(_ctx, getState());
  enterRule(_localctx, 302, tsqlParser::RuleTable_hint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2971);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::NOEXPAND) {
      setState(2970);
      match(tsqlParser::NOEXPAND);
    }
    setState(3011);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx)) {
    case 1: {
      setState(2973);
      match(tsqlParser::INDEX);
      setState(2974);
      match(tsqlParser::LR_BRACKET);
      setState(2975);
      index_value();
      setState(2980);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(2976);
        match(tsqlParser::COMMA);
        setState(2977);
        index_value();
        setState(2982);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2983);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(2985);
      match(tsqlParser::INDEX);
      setState(2986);
      match(tsqlParser::EQUAL);
      setState(2987);
      index_value();
      break;
    }

    case 3: {
      setState(2988);
      match(tsqlParser::FORCESEEK);
      setState(3003);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::LR_BRACKET) {
        setState(2989);
        match(tsqlParser::LR_BRACKET);
        setState(2990);
        index_value();
        setState(2991);
        match(tsqlParser::LR_BRACKET);
        setState(2992);
        match(tsqlParser::ID);
        setState(2997);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == tsqlParser::COMMA) {
          setState(2993);
          match(tsqlParser::COMMA);
          setState(2994);
          match(tsqlParser::ID);
          setState(2999);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3000);
        match(tsqlParser::RR_BRACKET);
        setState(3001);
        match(tsqlParser::RR_BRACKET);
      }
      break;
    }

    case 4: {
      setState(3005);
      match(tsqlParser::SERIALIZABLE);
      break;
    }

    case 5: {
      setState(3006);
      match(tsqlParser::SNAPSHOT);
      break;
    }

    case 6: {
      setState(3007);
      match(tsqlParser::SPATIAL_WINDOW_MAX_CELLS);
      setState(3008);
      match(tsqlParser::EQUAL);
      setState(3009);
      match(tsqlParser::DECIMAL);
      break;
    }

    case 7: {
      setState(3010);
      match(tsqlParser::ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_valueContext ------------------------------------------------------------------

tsqlParser::Index_valueContext::Index_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::R_idContext* tsqlParser::Index_valueContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Index_valueContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}


size_t tsqlParser::Index_valueContext::getRuleIndex() const {
  return tsqlParser::RuleIndex_value;
}


antlrcpp::Any tsqlParser::Index_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitIndex_value(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Index_valueContext* tsqlParser::index_value() {
  Index_valueContext *_localctx = _tracker.createInstance<Index_valueContext>(_ctx, getState());
  enterRule(_localctx, 304, tsqlParser::RuleIndex_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3015);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3013);
        r_id();
        break;
      }

      case tsqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(3014);
        match(tsqlParser::DECIMAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_alias_listContext ------------------------------------------------------------------

tsqlParser::Column_alias_listContext::Column_alias_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Column_alias_listContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

std::vector<tsqlParser::Column_aliasContext *> tsqlParser::Column_alias_listContext::column_alias() {
  return getRuleContexts<tsqlParser::Column_aliasContext>();
}

tsqlParser::Column_aliasContext* tsqlParser::Column_alias_listContext::column_alias(size_t i) {
  return getRuleContext<tsqlParser::Column_aliasContext>(i);
}

tree::TerminalNode* tsqlParser::Column_alias_listContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Column_alias_listContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Column_alias_listContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Column_alias_listContext::getRuleIndex() const {
  return tsqlParser::RuleColumn_alias_list;
}


antlrcpp::Any tsqlParser::Column_alias_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitColumn_alias_list(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Column_alias_listContext* tsqlParser::column_alias_list() {
  Column_alias_listContext *_localctx = _tracker.createInstance<Column_alias_listContext>(_ctx, getState());
  enterRule(_localctx, 306, tsqlParser::RuleColumn_alias_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3017);
    match(tsqlParser::LR_BRACKET);
    setState(3018);
    column_alias();
    setState(3023);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(3019);
      match(tsqlParser::COMMA);
      setState(3020);
      column_alias();
      setState(3025);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3026);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_aliasContext ------------------------------------------------------------------

tsqlParser::Column_aliasContext::Column_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::R_idContext* tsqlParser::Column_aliasContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Column_aliasContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}


size_t tsqlParser::Column_aliasContext::getRuleIndex() const {
  return tsqlParser::RuleColumn_alias;
}


antlrcpp::Any tsqlParser::Column_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitColumn_alias(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Column_aliasContext* tsqlParser::column_alias() {
  Column_aliasContext *_localctx = _tracker.createInstance<Column_aliasContext>(_ctx, getState());
  enterRule(_localctx, 308, tsqlParser::RuleColumn_alias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3030);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3028);
        r_id();
        break;
      }

      case tsqlParser::STRING: {
        enterOuterAlt(_localctx, 2);
        setState(3029);
        match(tsqlParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_starContext ------------------------------------------------------------------

tsqlParser::A_starContext::A_starContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::A_starContext::STAR() {
  return getToken(tsqlParser::STAR, 0);
}


size_t tsqlParser::A_starContext::getRuleIndex() const {
  return tsqlParser::RuleA_star;
}


antlrcpp::Any tsqlParser::A_starContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitA_star(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::A_starContext* tsqlParser::a_star() {
  A_starContext *_localctx = _tracker.createInstance<A_starContext>(_ctx, getState());
  enterRule(_localctx, 310, tsqlParser::RuleA_star);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3032);
    match(tsqlParser::STAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_value_constructorContext ------------------------------------------------------------------

tsqlParser::Table_value_constructorContext::Table_value_constructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Table_value_constructorContext::VALUES() {
  return getToken(tsqlParser::VALUES, 0);
}

std::vector<tsqlParser::Value_listContext *> tsqlParser::Table_value_constructorContext::value_list() {
  return getRuleContexts<tsqlParser::Value_listContext>();
}

tsqlParser::Value_listContext* tsqlParser::Table_value_constructorContext::value_list(size_t i) {
  return getRuleContext<tsqlParser::Value_listContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Table_value_constructorContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Table_value_constructorContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Table_value_constructorContext::getRuleIndex() const {
  return tsqlParser::RuleTable_value_constructor;
}


antlrcpp::Any tsqlParser::Table_value_constructorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTable_value_constructor(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Table_value_constructorContext* tsqlParser::table_value_constructor() {
  Table_value_constructorContext *_localctx = _tracker.createInstance<Table_value_constructorContext>(_ctx, getState());
  enterRule(_localctx, 312, tsqlParser::RuleTable_value_constructor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3034);
    match(tsqlParser::VALUES);
    setState(3035);
    value_list();
    setState(3040);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 418, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3036);
        match(tsqlParser::COMMA);
        setState(3037);
        value_list(); 
      }
      setState(3042);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 418, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_listContext ------------------------------------------------------------------

tsqlParser::Expression_listContext::Expression_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::ExpressionContext *> tsqlParser::Expression_listContext::expression() {
  return getRuleContexts<tsqlParser::ExpressionContext>();
}

tsqlParser::ExpressionContext* tsqlParser::Expression_listContext::expression(size_t i) {
  return getRuleContext<tsqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Expression_listContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Expression_listContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Expression_listContext::getRuleIndex() const {
  return tsqlParser::RuleExpression_list;
}


antlrcpp::Any tsqlParser::Expression_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitExpression_list(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Expression_listContext* tsqlParser::expression_list() {
  Expression_listContext *_localctx = _tracker.createInstance<Expression_listContext>(_ctx, getState());
  enterRule(_localctx, 314, tsqlParser::RuleExpression_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3043);
    expression(0);
    setState(3048);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(3044);
      match(tsqlParser::COMMA);
      setState(3045);
      expression(0);
      setState(3050);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Value_listContext ------------------------------------------------------------------

tsqlParser::Value_listContext::Value_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Value_listContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Expression_listContext* tsqlParser::Value_listContext::expression_list() {
  return getRuleContext<tsqlParser::Expression_listContext>(0);
}

tree::TerminalNode* tsqlParser::Value_listContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}


size_t tsqlParser::Value_listContext::getRuleIndex() const {
  return tsqlParser::RuleValue_list;
}


antlrcpp::Any tsqlParser::Value_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitValue_list(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Value_listContext* tsqlParser::value_list() {
  Value_listContext *_localctx = _tracker.createInstance<Value_listContext>(_ctx, getState());
  enterRule(_localctx, 316, tsqlParser::RuleValue_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3051);
    match(tsqlParser::LR_BRACKET);
    setState(3052);
    expression_list();
    setState(3053);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Next_value_forContext ------------------------------------------------------------------

tsqlParser::Next_value_forContext::Next_value_forContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Next_value_forContext::NEXT() {
  return getToken(tsqlParser::NEXT, 0);
}

tree::TerminalNode* tsqlParser::Next_value_forContext::VALUE() {
  return getToken(tsqlParser::VALUE, 0);
}

tree::TerminalNode* tsqlParser::Next_value_forContext::FOR() {
  return getToken(tsqlParser::FOR, 0);
}


size_t tsqlParser::Next_value_forContext::getRuleIndex() const {
  return tsqlParser::RuleNext_value_for;
}


antlrcpp::Any tsqlParser::Next_value_forContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitNext_value_for(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Next_value_forContext* tsqlParser::next_value_for() {
  Next_value_forContext *_localctx = _tracker.createInstance<Next_value_forContext>(_ctx, getState());
  enterRule(_localctx, 318, tsqlParser::RuleNext_value_for);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3055);
    match(tsqlParser::NEXT);
    setState(3056);
    match(tsqlParser::VALUE);
    setState(3057);
    match(tsqlParser::FOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Next_value_for_functionContext ------------------------------------------------------------------

tsqlParser::Next_value_for_functionContext::Next_value_for_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Next_value_forContext* tsqlParser::Next_value_for_functionContext::next_value_for() {
  return getRuleContext<tsqlParser::Next_value_forContext>(0);
}

tsqlParser::Over_clauseContext* tsqlParser::Next_value_for_functionContext::over_clause() {
  return getRuleContext<tsqlParser::Over_clauseContext>(0);
}

tsqlParser::Func_proc_nameContext* tsqlParser::Next_value_for_functionContext::func_proc_name() {
  return getRuleContext<tsqlParser::Func_proc_nameContext>(0);
}


size_t tsqlParser::Next_value_for_functionContext::getRuleIndex() const {
  return tsqlParser::RuleNext_value_for_function;
}


antlrcpp::Any tsqlParser::Next_value_for_functionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitNext_value_for_function(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Next_value_for_functionContext* tsqlParser::next_value_for_function() {
  Next_value_for_functionContext *_localctx = _tracker.createInstance<Next_value_for_functionContext>(_ctx, getState());
  enterRule(_localctx, 320, tsqlParser::RuleNext_value_for_function);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3059);
    next_value_for();
    setState(3060);
    dynamic_cast<Next_value_for_functionContext *>(_localctx)->args = func_proc_name();
    setState(3061);
    over_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ranking_windowed_functionContext ------------------------------------------------------------------

tsqlParser::Ranking_windowed_functionContext::Ranking_windowed_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Ranking_windowed_functionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Ranking_windowed_functionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::Over_clauseContext* tsqlParser::Ranking_windowed_functionContext::over_clause() {
  return getRuleContext<tsqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* tsqlParser::Ranking_windowed_functionContext::RANK() {
  return getToken(tsqlParser::RANK, 0);
}

tree::TerminalNode* tsqlParser::Ranking_windowed_functionContext::DENSE_RANK() {
  return getToken(tsqlParser::DENSE_RANK, 0);
}

tree::TerminalNode* tsqlParser::Ranking_windowed_functionContext::ROW_NUMBER() {
  return getToken(tsqlParser::ROW_NUMBER, 0);
}

std::vector<tsqlParser::ExpressionContext *> tsqlParser::Ranking_windowed_functionContext::expression() {
  return getRuleContexts<tsqlParser::ExpressionContext>();
}

tsqlParser::ExpressionContext* tsqlParser::Ranking_windowed_functionContext::expression(size_t i) {
  return getRuleContext<tsqlParser::ExpressionContext>(i);
}

tree::TerminalNode* tsqlParser::Ranking_windowed_functionContext::NTILE() {
  return getToken(tsqlParser::NTILE, 0);
}

tree::TerminalNode* tsqlParser::Ranking_windowed_functionContext::FIRST_VALUE() {
  return getToken(tsqlParser::FIRST_VALUE, 0);
}

tree::TerminalNode* tsqlParser::Ranking_windowed_functionContext::LAST_VALUE() {
  return getToken(tsqlParser::LAST_VALUE, 0);
}

tree::TerminalNode* tsqlParser::Ranking_windowed_functionContext::LEAD() {
  return getToken(tsqlParser::LEAD, 0);
}

tree::TerminalNode* tsqlParser::Ranking_windowed_functionContext::LAG() {
  return getToken(tsqlParser::LAG, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Ranking_windowed_functionContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Ranking_windowed_functionContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Ranking_windowed_functionContext::getRuleIndex() const {
  return tsqlParser::RuleRanking_windowed_function;
}


antlrcpp::Any tsqlParser::Ranking_windowed_functionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitRanking_windowed_function(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Ranking_windowed_functionContext* tsqlParser::ranking_windowed_function() {
  Ranking_windowed_functionContext *_localctx = _tracker.createInstance<Ranking_windowed_functionContext>(_ctx, getState());
  enterRule(_localctx, 322, tsqlParser::RuleRanking_windowed_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3086);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::DENSE_RANK:
      case tsqlParser::RANK:
      case tsqlParser::ROW_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(3063);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::DENSE_RANK || _la == tsqlParser::RANK

        || _la == tsqlParser::ROW_NUMBER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3064);
        match(tsqlParser::LR_BRACKET);
        setState(3065);
        match(tsqlParser::RR_BRACKET);
        setState(3066);
        over_clause();
        break;
      }

      case tsqlParser::FIRST_VALUE:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::NTILE: {
        enterOuterAlt(_localctx, 2);
        setState(3067);
        _la = _input->LA(1);
        if (!(((((_la - 282) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 282)) & ((1ULL << (tsqlParser::FIRST_VALUE - 282))
          | (1ULL << (tsqlParser::LAST_VALUE - 282))
          | (1ULL << (tsqlParser::NTILE - 282)))) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3068);
        match(tsqlParser::LR_BRACKET);
        setState(3069);
        expression(0);
        setState(3070);
        match(tsqlParser::RR_BRACKET);
        setState(3071);
        over_clause();
        break;
      }

      case tsqlParser::LAG:
      case tsqlParser::LEAD: {
        enterOuterAlt(_localctx, 3);
        setState(3073);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::LAG

        || _la == tsqlParser::LEAD)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3074);
        match(tsqlParser::LR_BRACKET);
        setState(3075);
        expression(0);
        setState(3080);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == tsqlParser::COMMA) {
          setState(3076);
          match(tsqlParser::COMMA);
          setState(3077);
          expression(0);
          setState(3082);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3083);
        match(tsqlParser::RR_BRACKET);
        setState(3084);
        over_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggregate_windowed_functionContext ------------------------------------------------------------------

tsqlParser::Aggregate_windowed_functionContext::Aggregate_windowed_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Aggregate_windowed_functionContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::AVG() {
  return getToken(tsqlParser::AVG, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::MAX() {
  return getToken(tsqlParser::MAX, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::MIN() {
  return getToken(tsqlParser::MIN, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::SUM() {
  return getToken(tsqlParser::SUM, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::STDEV() {
  return getToken(tsqlParser::STDEV, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::STDEVP() {
  return getToken(tsqlParser::STDEVP, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::VAR() {
  return getToken(tsqlParser::VAR, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::VARP() {
  return getToken(tsqlParser::VARP, 0);
}

tsqlParser::All_distinctContext* tsqlParser::Aggregate_windowed_functionContext::all_distinct() {
  return getRuleContext<tsqlParser::All_distinctContext>(0);
}

tsqlParser::Over_clauseContext* tsqlParser::Aggregate_windowed_functionContext::over_clause() {
  return getRuleContext<tsqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::COUNT() {
  return getToken(tsqlParser::COUNT, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::COUNT_BIG() {
  return getToken(tsqlParser::COUNT_BIG, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::STAR() {
  return getToken(tsqlParser::STAR, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::CHECKSUM_AGG() {
  return getToken(tsqlParser::CHECKSUM_AGG, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::GROUPING() {
  return getToken(tsqlParser::GROUPING, 0);
}

tree::TerminalNode* tsqlParser::Aggregate_windowed_functionContext::GROUPING_ID() {
  return getToken(tsqlParser::GROUPING_ID, 0);
}

tsqlParser::Expression_listContext* tsqlParser::Aggregate_windowed_functionContext::expression_list() {
  return getRuleContext<tsqlParser::Expression_listContext>(0);
}


size_t tsqlParser::Aggregate_windowed_functionContext::getRuleIndex() const {
  return tsqlParser::RuleAggregate_windowed_function;
}


antlrcpp::Any tsqlParser::Aggregate_windowed_functionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitAggregate_windowed_function(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Aggregate_windowed_functionContext* tsqlParser::aggregate_windowed_function() {
  Aggregate_windowed_functionContext *_localctx = _tracker.createInstance<Aggregate_windowed_functionContext>(_ctx, getState());
  enterRule(_localctx, 324, tsqlParser::RuleAggregate_windowed_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3129);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::AVG:
      case tsqlParser::MAX:
      case tsqlParser::MIN:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::VAR:
      case tsqlParser::VARP: {
        enterOuterAlt(_localctx, 1);
        setState(3088);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::AVG || _la == tsqlParser::MAX

        || _la == tsqlParser::MIN || ((((_la - 406) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 406)) & ((1ULL << (tsqlParser::STDEV - 406))
          | (1ULL << (tsqlParser::STDEVP - 406))
          | (1ULL << (tsqlParser::SUM - 406))
          | (1ULL << (tsqlParser::VAR - 406))
          | (1ULL << (tsqlParser::VARP - 406)))) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3089);
        match(tsqlParser::LR_BRACKET);
        setState(3091);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::ALL

        || _la == tsqlParser::DISTINCT) {
          setState(3090);
          all_distinct();
        }
        setState(3093);
        expression(0);
        setState(3094);
        match(tsqlParser::RR_BRACKET);
        setState(3096);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx)) {
        case 1: {
          setState(3095);
          over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG: {
        enterOuterAlt(_localctx, 2);
        setState(3098);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::COUNT

        || _la == tsqlParser::COUNT_BIG)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3099);
        match(tsqlParser::LR_BRACKET);
        setState(3105);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::STAR: {
            setState(3100);
            dynamic_cast<Aggregate_windowed_functionContext *>(_localctx)->args = match(tsqlParser::STAR);
            break;
          }

          case tsqlParser::ALL:
          case tsqlParser::CASE:
          case tsqlParser::COALESCE:
          case tsqlParser::CONVERT:
          case tsqlParser::CURRENT_TIMESTAMP:
          case tsqlParser::CURRENT_USER:
          case tsqlParser::DEFAULT:
          case tsqlParser::DISTINCT:
          case tsqlParser::EXP:
          case tsqlParser::FORCESEEK:
          case tsqlParser::IDENTITY:
          case tsqlParser::IIF:
          case tsqlParser::LEFT:
          case tsqlParser::LOG:
          case tsqlParser::LOG10:
          case tsqlParser::NEXT:
          case tsqlParser::NULL_:
          case tsqlParser::NULLIF:
          case tsqlParser::NUMERIC:
          case tsqlParser::OVER:
          case tsqlParser::RIGHT:
          case tsqlParser::SESSION_USER:
          case tsqlParser::SIGN:
          case tsqlParser::SYSTEM_USER:
          case tsqlParser::TRY_CAST:
          case tsqlParser::TRY_CONVERT:
          case tsqlParser::TRY_PARSE:
          case tsqlParser::VALUE:
          case tsqlParser::ABSOLUTE:
          case tsqlParser::APPLY:
          case tsqlParser::AUTO:
          case tsqlParser::AVG:
          case tsqlParser::BASE64:
          case tsqlParser::BINARY_CHECKSUM:
          case tsqlParser::CALLER:
          case tsqlParser::CAST:
          case tsqlParser::CATCH:
          case tsqlParser::CEILING:
          case tsqlParser::CHECKSUM:
          case tsqlParser::CHECKSUM_AGG:
          case tsqlParser::COMMITTED:
          case tsqlParser::CONCAT:
          case tsqlParser::CONTROL:
          case tsqlParser::COOKIE:
          case tsqlParser::COS:
          case tsqlParser::COUNT:
          case tsqlParser::COUNT_BIG:
          case tsqlParser::DATE:
          case tsqlParser::DATEADD:
          case tsqlParser::DATEDIFF:
          case tsqlParser::DATENAME:
          case tsqlParser::DATEPART:
          case tsqlParser::DATETIMEOFFSETFROMPARTS:
          case tsqlParser::DELAY:
          case tsqlParser::DELETED:
          case tsqlParser::DENSE_RANK:
          case tsqlParser::DISABLE:
          case tsqlParser::DYNAMIC:
          case tsqlParser::ENCRYPTION:
          case tsqlParser::EXIST:
          case tsqlParser::EXPAND:
          case tsqlParser::FAST:
          case tsqlParser::FAST_FORWARD:
          case tsqlParser::FIRST:
          case tsqlParser::FIRST_VALUE:
          case tsqlParser::FLOOR:
          case tsqlParser::FOLLOWING:
          case tsqlParser::FORCE:
          case tsqlParser::FORCED:
          case tsqlParser::FORWARD_ONLY:
          case tsqlParser::FULLSCAN:
          case tsqlParser::GLOBAL:
          case tsqlParser::GROUPING:
          case tsqlParser::GROUPING_ID:
          case tsqlParser::HASH:
          case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case tsqlParser::IMPERSONATE:
          case tsqlParser::INSENSITIVE:
          case tsqlParser::INSERTED:
          case tsqlParser::ISOLATION:
          case tsqlParser::IO:
          case tsqlParser::KEEP:
          case tsqlParser::KEEPFIXED:
          case tsqlParser::KEYSET:
          case tsqlParser::LAG:
          case tsqlParser::LAST:
          case tsqlParser::LAST_VALUE:
          case tsqlParser::LEAD:
          case tsqlParser::LEVEL:
          case tsqlParser::LOCAL:
          case tsqlParser::LOCK_ESCALATION:
          case tsqlParser::LOGIN:
          case tsqlParser::LOOP:
          case tsqlParser::MARK:
          case tsqlParser::MAX:
          case tsqlParser::MAXDOP:
          case tsqlParser::MAXRECURSION:
          case tsqlParser::MIN:
          case tsqlParser::MIN_ACTIVE_ROWVERSION:
          case tsqlParser::MODIFY:
          case tsqlParser::NAME:
          case tsqlParser::NOCOUNT:
          case tsqlParser::NODES:
          case tsqlParser::NOEXPAND:
          case tsqlParser::NORECOMPUTE:
          case tsqlParser::NTILE:
          case tsqlParser::NUMBER:
          case tsqlParser::OFFSET:
          case tsqlParser::ONLINE:
          case tsqlParser::ONLY:
          case tsqlParser::OPTIMISTIC:
          case tsqlParser::OPTIMIZE:
          case tsqlParser::OUT:
          case tsqlParser::OUTPUT:
          case tsqlParser::OWNER:
          case tsqlParser::PARAMETERIZATION:
          case tsqlParser::PARSE:
          case tsqlParser::PARTITION:
          case tsqlParser::PATH:
          case tsqlParser::PERCENTILE_CONT:
          case tsqlParser::POWER:
          case tsqlParser::PRECEDING:
          case tsqlParser::PRIOR:
          case tsqlParser::PRIVILEGES:
          case tsqlParser::QUERY:
          case tsqlParser::RANGE:
          case tsqlParser::RANK:
          case tsqlParser::READONLY:
          case tsqlParser::READ_ONLY:
          case tsqlParser::RECOMPILE:
          case tsqlParser::RELATIVE:
          case tsqlParser::REMOTE:
          case tsqlParser::REPEATABLE:
          case tsqlParser::ROBUST:
          case tsqlParser::ROOT:
          case tsqlParser::ROUND:
          case tsqlParser::ROW:
          case tsqlParser::ROWGUID:
          case tsqlParser::ROWS:
          case tsqlParser::ROW_NUMBER:
          case tsqlParser::SAMPLE:
          case tsqlParser::SCHEMABINDING:
          case tsqlParser::SCROLL:
          case tsqlParser::SCROLL_LOCKS:
          case tsqlParser::SELF:
          case tsqlParser::SERIALIZABLE:
          case tsqlParser::SIMPLE:
          case tsqlParser::SIN:
          case tsqlParser::SIZE:
          case tsqlParser::SNAPSHOT:
          case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case tsqlParser::STATIC:
          case tsqlParser::STATS_STREAM:
          case tsqlParser::STDEV:
          case tsqlParser::STDEVP:
          case tsqlParser::STRING_AGG:
          case tsqlParser::STRING_SPLIT:
          case tsqlParser::SUM:
          case tsqlParser::SQRT:
          case tsqlParser::SQUARE:
          case tsqlParser::TAN:
          case tsqlParser::TEXTIMAGE_ON:
          case tsqlParser::THROW:
          case tsqlParser::TIES:
          case tsqlParser::TIME:
          case tsqlParser::TRY:
          case tsqlParser::TYPE:
          case tsqlParser::TYPE_WARNING:
          case tsqlParser::UNBOUNDED:
          case tsqlParser::UNCOMMITTED:
          case tsqlParser::UNKNOWN:
          case tsqlParser::USING:
          case tsqlParser::VAR:
          case tsqlParser::VARP:
          case tsqlParser::VIEWS:
          case tsqlParser::VIEW_METADATA:
          case tsqlParser::WORK:
          case tsqlParser::XML:
          case tsqlParser::XMLNAMESPACES:
          case tsqlParser::ZONE:
          case tsqlParser::DOUBLE_QUOTE_ID:
          case tsqlParser::SQUARE_BRACKET_ID:
          case tsqlParser::LOCAL_ID:
          case tsqlParser::DECIMAL:
          case tsqlParser::ID:
          case tsqlParser::STRING:
          case tsqlParser::BINARY:
          case tsqlParser::FLOAT:
          case tsqlParser::REAL:
          case tsqlParser::DOLLAR:
          case tsqlParser::LR_BRACKET:
          case tsqlParser::PLUS:
          case tsqlParser::MINUS:
          case tsqlParser::BIT_NOT: {
            setState(3102);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == tsqlParser::ALL

            || _la == tsqlParser::DISTINCT) {
              setState(3101);
              all_distinct();
            }
            setState(3104);
            expression(0);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(3107);
        match(tsqlParser::RR_BRACKET);
        setState(3109);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 426, _ctx)) {
        case 1: {
          setState(3108);
          over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case tsqlParser::CHECKSUM_AGG: {
        enterOuterAlt(_localctx, 3);
        setState(3111);
        match(tsqlParser::CHECKSUM_AGG);
        setState(3112);
        match(tsqlParser::LR_BRACKET);
        setState(3114);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::ALL

        || _la == tsqlParser::DISTINCT) {
          setState(3113);
          all_distinct();
        }
        setState(3116);
        expression(0);
        setState(3117);
        match(tsqlParser::RR_BRACKET);
        break;
      }

      case tsqlParser::GROUPING: {
        enterOuterAlt(_localctx, 4);
        setState(3119);
        match(tsqlParser::GROUPING);
        setState(3120);
        match(tsqlParser::LR_BRACKET);
        setState(3121);
        expression(0);
        setState(3122);
        match(tsqlParser::RR_BRACKET);
        break;
      }

      case tsqlParser::GROUPING_ID: {
        enterOuterAlt(_localctx, 5);
        setState(3124);
        match(tsqlParser::GROUPING_ID);
        setState(3125);
        match(tsqlParser::LR_BRACKET);
        setState(3126);
        expression_list();
        setState(3127);
        match(tsqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- All_distinctContext ------------------------------------------------------------------

tsqlParser::All_distinctContext::All_distinctContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::All_distinctContext::ALL() {
  return getToken(tsqlParser::ALL, 0);
}

tree::TerminalNode* tsqlParser::All_distinctContext::DISTINCT() {
  return getToken(tsqlParser::DISTINCT, 0);
}


size_t tsqlParser::All_distinctContext::getRuleIndex() const {
  return tsqlParser::RuleAll_distinct;
}


antlrcpp::Any tsqlParser::All_distinctContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitAll_distinct(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::All_distinctContext* tsqlParser::all_distinct() {
  All_distinctContext *_localctx = _tracker.createInstance<All_distinctContext>(_ctx, getState());
  enterRule(_localctx, 326, tsqlParser::RuleAll_distinct);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3131);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::ALL

    || _la == tsqlParser::DISTINCT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Over_clauseContext ------------------------------------------------------------------

tsqlParser::Over_clauseContext::Over_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Over_clauseContext::OVER() {
  return getToken(tsqlParser::OVER, 0);
}

tree::TerminalNode* tsqlParser::Over_clauseContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Over_clauseContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Over_clauseContext::PARTITION() {
  return getToken(tsqlParser::PARTITION, 0);
}

tree::TerminalNode* tsqlParser::Over_clauseContext::BY() {
  return getToken(tsqlParser::BY, 0);
}

tsqlParser::Expression_listContext* tsqlParser::Over_clauseContext::expression_list() {
  return getRuleContext<tsqlParser::Expression_listContext>(0);
}

tsqlParser::Order_by_clauseContext* tsqlParser::Over_clauseContext::order_by_clause() {
  return getRuleContext<tsqlParser::Order_by_clauseContext>(0);
}

tsqlParser::Row_or_range_clauseContext* tsqlParser::Over_clauseContext::row_or_range_clause() {
  return getRuleContext<tsqlParser::Row_or_range_clauseContext>(0);
}


size_t tsqlParser::Over_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleOver_clause;
}


antlrcpp::Any tsqlParser::Over_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOver_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Over_clauseContext* tsqlParser::over_clause() {
  Over_clauseContext *_localctx = _tracker.createInstance<Over_clauseContext>(_ctx, getState());
  enterRule(_localctx, 328, tsqlParser::RuleOver_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3133);
    match(tsqlParser::OVER);
    setState(3134);
    match(tsqlParser::LR_BRACKET);
    setState(3138);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::PARTITION) {
      setState(3135);
      match(tsqlParser::PARTITION);
      setState(3136);
      match(tsqlParser::BY);
      setState(3137);
      expression_list();
    }
    setState(3141);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::ORDER) {
      setState(3140);
      order_by_clause();
    }
    setState(3144);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::RANGE

    || _la == tsqlParser::ROWS) {
      setState(3143);
      row_or_range_clause();
    }
    setState(3146);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Row_or_range_clauseContext ------------------------------------------------------------------

tsqlParser::Row_or_range_clauseContext::Row_or_range_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Window_frame_extentContext* tsqlParser::Row_or_range_clauseContext::window_frame_extent() {
  return getRuleContext<tsqlParser::Window_frame_extentContext>(0);
}

tree::TerminalNode* tsqlParser::Row_or_range_clauseContext::ROWS() {
  return getToken(tsqlParser::ROWS, 0);
}

tree::TerminalNode* tsqlParser::Row_or_range_clauseContext::RANGE() {
  return getToken(tsqlParser::RANGE, 0);
}


size_t tsqlParser::Row_or_range_clauseContext::getRuleIndex() const {
  return tsqlParser::RuleRow_or_range_clause;
}


antlrcpp::Any tsqlParser::Row_or_range_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitRow_or_range_clause(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Row_or_range_clauseContext* tsqlParser::row_or_range_clause() {
  Row_or_range_clauseContext *_localctx = _tracker.createInstance<Row_or_range_clauseContext>(_ctx, getState());
  enterRule(_localctx, 330, tsqlParser::RuleRow_or_range_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3148);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::RANGE

    || _la == tsqlParser::ROWS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3149);
    window_frame_extent();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_extentContext ------------------------------------------------------------------

tsqlParser::Window_frame_extentContext::Window_frame_extentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Window_frame_precedingContext* tsqlParser::Window_frame_extentContext::window_frame_preceding() {
  return getRuleContext<tsqlParser::Window_frame_precedingContext>(0);
}

tree::TerminalNode* tsqlParser::Window_frame_extentContext::BETWEEN() {
  return getToken(tsqlParser::BETWEEN, 0);
}

std::vector<tsqlParser::Window_frame_boundContext *> tsqlParser::Window_frame_extentContext::window_frame_bound() {
  return getRuleContexts<tsqlParser::Window_frame_boundContext>();
}

tsqlParser::Window_frame_boundContext* tsqlParser::Window_frame_extentContext::window_frame_bound(size_t i) {
  return getRuleContext<tsqlParser::Window_frame_boundContext>(i);
}

tree::TerminalNode* tsqlParser::Window_frame_extentContext::AND() {
  return getToken(tsqlParser::AND, 0);
}


size_t tsqlParser::Window_frame_extentContext::getRuleIndex() const {
  return tsqlParser::RuleWindow_frame_extent;
}


antlrcpp::Any tsqlParser::Window_frame_extentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitWindow_frame_extent(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Window_frame_extentContext* tsqlParser::window_frame_extent() {
  Window_frame_extentContext *_localctx = _tracker.createInstance<Window_frame_extentContext>(_ctx, getState());
  enterRule(_localctx, 332, tsqlParser::RuleWindow_frame_extent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3157);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::CURRENT:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 1);
        setState(3151);
        window_frame_preceding();
        break;
      }

      case tsqlParser::BETWEEN: {
        enterOuterAlt(_localctx, 2);
        setState(3152);
        match(tsqlParser::BETWEEN);
        setState(3153);
        window_frame_bound();
        setState(3154);
        match(tsqlParser::AND);
        setState(3155);
        window_frame_bound();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_boundContext ------------------------------------------------------------------

tsqlParser::Window_frame_boundContext::Window_frame_boundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Window_frame_precedingContext* tsqlParser::Window_frame_boundContext::window_frame_preceding() {
  return getRuleContext<tsqlParser::Window_frame_precedingContext>(0);
}

tsqlParser::Window_frame_followingContext* tsqlParser::Window_frame_boundContext::window_frame_following() {
  return getRuleContext<tsqlParser::Window_frame_followingContext>(0);
}


size_t tsqlParser::Window_frame_boundContext::getRuleIndex() const {
  return tsqlParser::RuleWindow_frame_bound;
}


antlrcpp::Any tsqlParser::Window_frame_boundContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitWindow_frame_bound(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Window_frame_boundContext* tsqlParser::window_frame_bound() {
  Window_frame_boundContext *_localctx = _tracker.createInstance<Window_frame_boundContext>(_ctx, getState());
  enterRule(_localctx, 334, tsqlParser::RuleWindow_frame_bound);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3161);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3159);
      window_frame_preceding();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3160);
      window_frame_following();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_precedingContext ------------------------------------------------------------------

tsqlParser::Window_frame_precedingContext::Window_frame_precedingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Window_frame_precedingContext::UNBOUNDED() {
  return getToken(tsqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* tsqlParser::Window_frame_precedingContext::PRECEDING() {
  return getToken(tsqlParser::PRECEDING, 0);
}

tree::TerminalNode* tsqlParser::Window_frame_precedingContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tree::TerminalNode* tsqlParser::Window_frame_precedingContext::CURRENT() {
  return getToken(tsqlParser::CURRENT, 0);
}

tree::TerminalNode* tsqlParser::Window_frame_precedingContext::ROW() {
  return getToken(tsqlParser::ROW, 0);
}


size_t tsqlParser::Window_frame_precedingContext::getRuleIndex() const {
  return tsqlParser::RuleWindow_frame_preceding;
}


antlrcpp::Any tsqlParser::Window_frame_precedingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitWindow_frame_preceding(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Window_frame_precedingContext* tsqlParser::window_frame_preceding() {
  Window_frame_precedingContext *_localctx = _tracker.createInstance<Window_frame_precedingContext>(_ctx, getState());
  enterRule(_localctx, 336, tsqlParser::RuleWindow_frame_preceding);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3169);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::UNBOUNDED: {
        enterOuterAlt(_localctx, 1);
        setState(3163);
        match(tsqlParser::UNBOUNDED);
        setState(3164);
        match(tsqlParser::PRECEDING);
        break;
      }

      case tsqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(3165);
        match(tsqlParser::DECIMAL);
        setState(3166);
        match(tsqlParser::PRECEDING);
        break;
      }

      case tsqlParser::CURRENT: {
        enterOuterAlt(_localctx, 3);
        setState(3167);
        match(tsqlParser::CURRENT);
        setState(3168);
        match(tsqlParser::ROW);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_followingContext ------------------------------------------------------------------

tsqlParser::Window_frame_followingContext::Window_frame_followingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Window_frame_followingContext::UNBOUNDED() {
  return getToken(tsqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* tsqlParser::Window_frame_followingContext::FOLLOWING() {
  return getToken(tsqlParser::FOLLOWING, 0);
}

tree::TerminalNode* tsqlParser::Window_frame_followingContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}


size_t tsqlParser::Window_frame_followingContext::getRuleIndex() const {
  return tsqlParser::RuleWindow_frame_following;
}


antlrcpp::Any tsqlParser::Window_frame_followingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitWindow_frame_following(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Window_frame_followingContext* tsqlParser::window_frame_following() {
  Window_frame_followingContext *_localctx = _tracker.createInstance<Window_frame_followingContext>(_ctx, getState());
  enterRule(_localctx, 338, tsqlParser::RuleWindow_frame_following);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3175);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::UNBOUNDED: {
        enterOuterAlt(_localctx, 1);
        setState(3171);
        match(tsqlParser::UNBOUNDED);
        setState(3172);
        match(tsqlParser::FOLLOWING);
        break;
      }

      case tsqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(3173);
        match(tsqlParser::DECIMAL);
        setState(3174);
        match(tsqlParser::FOLLOWING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_database_optionContext ------------------------------------------------------------------

tsqlParser::Create_database_optionContext::Create_database_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::FILESTREAM() {
  return getToken(tsqlParser::FILESTREAM, 0);
}

std::vector<tsqlParser::Database_filestream_optionContext *> tsqlParser::Create_database_optionContext::database_filestream_option() {
  return getRuleContexts<tsqlParser::Database_filestream_optionContext>();
}

tsqlParser::Database_filestream_optionContext* tsqlParser::Create_database_optionContext::database_filestream_option(size_t i) {
  return getRuleContext<tsqlParser::Database_filestream_optionContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_database_optionContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::DEFAULT_LANGUAGE() {
  return getToken(tsqlParser::DEFAULT_LANGUAGE, 0);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tsqlParser::R_idContext* tsqlParser::Create_database_optionContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::DEFAULT_FULLTEXT_LANGUAGE() {
  return getToken(tsqlParser::DEFAULT_FULLTEXT_LANGUAGE, 0);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::NESTED_TRIGGERS() {
  return getToken(tsqlParser::NESTED_TRIGGERS, 0);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::OFF() {
  return getToken(tsqlParser::OFF, 0);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::TRANSFORM_NOISE_WORDS() {
  return getToken(tsqlParser::TRANSFORM_NOISE_WORDS, 0);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::TWO_DIGIT_YEAR_CUTOFF() {
  return getToken(tsqlParser::TWO_DIGIT_YEAR_CUTOFF, 0);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::DB_CHAINING() {
  return getToken(tsqlParser::DB_CHAINING, 0);
}

tree::TerminalNode* tsqlParser::Create_database_optionContext::TRUSTWORTHY() {
  return getToken(tsqlParser::TRUSTWORTHY, 0);
}


size_t tsqlParser::Create_database_optionContext::getRuleIndex() const {
  return tsqlParser::RuleCreate_database_option;
}


antlrcpp::Any tsqlParser::Create_database_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_database_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Create_database_optionContext* tsqlParser::create_database_option() {
  Create_database_optionContext *_localctx = _tracker.createInstance<Create_database_optionContext>(_ctx, getState());
  enterRule(_localctx, 340, tsqlParser::RuleCreate_database_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(3211);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FILESTREAM: {
        enterOuterAlt(_localctx, 1);
        setState(3177);
        match(tsqlParser::FILESTREAM);

        setState(3178);
        database_filestream_option();
        setState(3183);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(3179);
            match(tsqlParser::COMMA);
            setState(3180);
            database_filestream_option(); 
          }
          setState(3185);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx);
        }
        break;
      }

      case tsqlParser::DEFAULT_LANGUAGE: {
        enterOuterAlt(_localctx, 2);
        setState(3186);
        match(tsqlParser::DEFAULT_LANGUAGE);
        setState(3187);
        match(tsqlParser::EQUAL);
        setState(3190);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::FORCESEEK:
          case tsqlParser::NEXT:
          case tsqlParser::NUMERIC:
          case tsqlParser::VALUE:
          case tsqlParser::ABSOLUTE:
          case tsqlParser::APPLY:
          case tsqlParser::AUTO:
          case tsqlParser::AVG:
          case tsqlParser::BASE64:
          case tsqlParser::CALLER:
          case tsqlParser::CAST:
          case tsqlParser::CATCH:
          case tsqlParser::CHECKSUM_AGG:
          case tsqlParser::COMMITTED:
          case tsqlParser::CONCAT:
          case tsqlParser::CONTROL:
          case tsqlParser::COOKIE:
          case tsqlParser::COUNT:
          case tsqlParser::COUNT_BIG:
          case tsqlParser::DATE:
          case tsqlParser::DELAY:
          case tsqlParser::DELETED:
          case tsqlParser::DENSE_RANK:
          case tsqlParser::DISABLE:
          case tsqlParser::DYNAMIC:
          case tsqlParser::ENCRYPTION:
          case tsqlParser::EXIST:
          case tsqlParser::EXPAND:
          case tsqlParser::FAST:
          case tsqlParser::FAST_FORWARD:
          case tsqlParser::FIRST:
          case tsqlParser::FIRST_VALUE:
          case tsqlParser::FOLLOWING:
          case tsqlParser::FORCE:
          case tsqlParser::FORCED:
          case tsqlParser::FORWARD_ONLY:
          case tsqlParser::FULLSCAN:
          case tsqlParser::GLOBAL:
          case tsqlParser::GROUPING:
          case tsqlParser::GROUPING_ID:
          case tsqlParser::HASH:
          case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case tsqlParser::IMPERSONATE:
          case tsqlParser::INSENSITIVE:
          case tsqlParser::INSERTED:
          case tsqlParser::ISOLATION:
          case tsqlParser::IO:
          case tsqlParser::KEEP:
          case tsqlParser::KEEPFIXED:
          case tsqlParser::KEYSET:
          case tsqlParser::LAG:
          case tsqlParser::LAST:
          case tsqlParser::LAST_VALUE:
          case tsqlParser::LEAD:
          case tsqlParser::LEVEL:
          case tsqlParser::LOCAL:
          case tsqlParser::LOCK_ESCALATION:
          case tsqlParser::LOGIN:
          case tsqlParser::LOOP:
          case tsqlParser::MARK:
          case tsqlParser::MAX:
          case tsqlParser::MAXDOP:
          case tsqlParser::MAXRECURSION:
          case tsqlParser::MIN:
          case tsqlParser::MODIFY:
          case tsqlParser::NAME:
          case tsqlParser::NOCOUNT:
          case tsqlParser::NODES:
          case tsqlParser::NOEXPAND:
          case tsqlParser::NORECOMPUTE:
          case tsqlParser::NTILE:
          case tsqlParser::NUMBER:
          case tsqlParser::OFFSET:
          case tsqlParser::ONLINE:
          case tsqlParser::ONLY:
          case tsqlParser::OPTIMISTIC:
          case tsqlParser::OPTIMIZE:
          case tsqlParser::OUT:
          case tsqlParser::OUTPUT:
          case tsqlParser::OWNER:
          case tsqlParser::PARAMETERIZATION:
          case tsqlParser::PARTITION:
          case tsqlParser::PATH:
          case tsqlParser::PRECEDING:
          case tsqlParser::PRIOR:
          case tsqlParser::PRIVILEGES:
          case tsqlParser::QUERY:
          case tsqlParser::RANGE:
          case tsqlParser::RANK:
          case tsqlParser::READONLY:
          case tsqlParser::READ_ONLY:
          case tsqlParser::RECOMPILE:
          case tsqlParser::RELATIVE:
          case tsqlParser::REMOTE:
          case tsqlParser::REPEATABLE:
          case tsqlParser::ROBUST:
          case tsqlParser::ROOT:
          case tsqlParser::ROW:
          case tsqlParser::ROWGUID:
          case tsqlParser::ROWS:
          case tsqlParser::ROW_NUMBER:
          case tsqlParser::SAMPLE:
          case tsqlParser::SCHEMABINDING:
          case tsqlParser::SCROLL:
          case tsqlParser::SCROLL_LOCKS:
          case tsqlParser::SELF:
          case tsqlParser::SERIALIZABLE:
          case tsqlParser::SIMPLE:
          case tsqlParser::SIZE:
          case tsqlParser::SNAPSHOT:
          case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case tsqlParser::STATIC:
          case tsqlParser::STATS_STREAM:
          case tsqlParser::STDEV:
          case tsqlParser::STDEVP:
          case tsqlParser::SUM:
          case tsqlParser::TEXTIMAGE_ON:
          case tsqlParser::THROW:
          case tsqlParser::TIES:
          case tsqlParser::TIME:
          case tsqlParser::TRY:
          case tsqlParser::TYPE:
          case tsqlParser::TYPE_WARNING:
          case tsqlParser::UNBOUNDED:
          case tsqlParser::UNCOMMITTED:
          case tsqlParser::UNKNOWN:
          case tsqlParser::USING:
          case tsqlParser::VAR:
          case tsqlParser::VARP:
          case tsqlParser::VIEWS:
          case tsqlParser::VIEW_METADATA:
          case tsqlParser::WORK:
          case tsqlParser::XML:
          case tsqlParser::XMLNAMESPACES:
          case tsqlParser::ZONE:
          case tsqlParser::DOUBLE_QUOTE_ID:
          case tsqlParser::SQUARE_BRACKET_ID:
          case tsqlParser::ID: {
            setState(3188);
            r_id();
            break;
          }

          case tsqlParser::STRING: {
            setState(3189);
            match(tsqlParser::STRING);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case tsqlParser::DEFAULT_FULLTEXT_LANGUAGE: {
        enterOuterAlt(_localctx, 3);
        setState(3192);
        match(tsqlParser::DEFAULT_FULLTEXT_LANGUAGE);
        setState(3193);
        match(tsqlParser::EQUAL);
        setState(3196);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case tsqlParser::FORCESEEK:
          case tsqlParser::NEXT:
          case tsqlParser::NUMERIC:
          case tsqlParser::VALUE:
          case tsqlParser::ABSOLUTE:
          case tsqlParser::APPLY:
          case tsqlParser::AUTO:
          case tsqlParser::AVG:
          case tsqlParser::BASE64:
          case tsqlParser::CALLER:
          case tsqlParser::CAST:
          case tsqlParser::CATCH:
          case tsqlParser::CHECKSUM_AGG:
          case tsqlParser::COMMITTED:
          case tsqlParser::CONCAT:
          case tsqlParser::CONTROL:
          case tsqlParser::COOKIE:
          case tsqlParser::COUNT:
          case tsqlParser::COUNT_BIG:
          case tsqlParser::DATE:
          case tsqlParser::DELAY:
          case tsqlParser::DELETED:
          case tsqlParser::DENSE_RANK:
          case tsqlParser::DISABLE:
          case tsqlParser::DYNAMIC:
          case tsqlParser::ENCRYPTION:
          case tsqlParser::EXIST:
          case tsqlParser::EXPAND:
          case tsqlParser::FAST:
          case tsqlParser::FAST_FORWARD:
          case tsqlParser::FIRST:
          case tsqlParser::FIRST_VALUE:
          case tsqlParser::FOLLOWING:
          case tsqlParser::FORCE:
          case tsqlParser::FORCED:
          case tsqlParser::FORWARD_ONLY:
          case tsqlParser::FULLSCAN:
          case tsqlParser::GLOBAL:
          case tsqlParser::GROUPING:
          case tsqlParser::GROUPING_ID:
          case tsqlParser::HASH:
          case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case tsqlParser::IMPERSONATE:
          case tsqlParser::INSENSITIVE:
          case tsqlParser::INSERTED:
          case tsqlParser::ISOLATION:
          case tsqlParser::IO:
          case tsqlParser::KEEP:
          case tsqlParser::KEEPFIXED:
          case tsqlParser::KEYSET:
          case tsqlParser::LAG:
          case tsqlParser::LAST:
          case tsqlParser::LAST_VALUE:
          case tsqlParser::LEAD:
          case tsqlParser::LEVEL:
          case tsqlParser::LOCAL:
          case tsqlParser::LOCK_ESCALATION:
          case tsqlParser::LOGIN:
          case tsqlParser::LOOP:
          case tsqlParser::MARK:
          case tsqlParser::MAX:
          case tsqlParser::MAXDOP:
          case tsqlParser::MAXRECURSION:
          case tsqlParser::MIN:
          case tsqlParser::MODIFY:
          case tsqlParser::NAME:
          case tsqlParser::NOCOUNT:
          case tsqlParser::NODES:
          case tsqlParser::NOEXPAND:
          case tsqlParser::NORECOMPUTE:
          case tsqlParser::NTILE:
          case tsqlParser::NUMBER:
          case tsqlParser::OFFSET:
          case tsqlParser::ONLINE:
          case tsqlParser::ONLY:
          case tsqlParser::OPTIMISTIC:
          case tsqlParser::OPTIMIZE:
          case tsqlParser::OUT:
          case tsqlParser::OUTPUT:
          case tsqlParser::OWNER:
          case tsqlParser::PARAMETERIZATION:
          case tsqlParser::PARTITION:
          case tsqlParser::PATH:
          case tsqlParser::PRECEDING:
          case tsqlParser::PRIOR:
          case tsqlParser::PRIVILEGES:
          case tsqlParser::QUERY:
          case tsqlParser::RANGE:
          case tsqlParser::RANK:
          case tsqlParser::READONLY:
          case tsqlParser::READ_ONLY:
          case tsqlParser::RECOMPILE:
          case tsqlParser::RELATIVE:
          case tsqlParser::REMOTE:
          case tsqlParser::REPEATABLE:
          case tsqlParser::ROBUST:
          case tsqlParser::ROOT:
          case tsqlParser::ROW:
          case tsqlParser::ROWGUID:
          case tsqlParser::ROWS:
          case tsqlParser::ROW_NUMBER:
          case tsqlParser::SAMPLE:
          case tsqlParser::SCHEMABINDING:
          case tsqlParser::SCROLL:
          case tsqlParser::SCROLL_LOCKS:
          case tsqlParser::SELF:
          case tsqlParser::SERIALIZABLE:
          case tsqlParser::SIMPLE:
          case tsqlParser::SIZE:
          case tsqlParser::SNAPSHOT:
          case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case tsqlParser::STATIC:
          case tsqlParser::STATS_STREAM:
          case tsqlParser::STDEV:
          case tsqlParser::STDEVP:
          case tsqlParser::SUM:
          case tsqlParser::TEXTIMAGE_ON:
          case tsqlParser::THROW:
          case tsqlParser::TIES:
          case tsqlParser::TIME:
          case tsqlParser::TRY:
          case tsqlParser::TYPE:
          case tsqlParser::TYPE_WARNING:
          case tsqlParser::UNBOUNDED:
          case tsqlParser::UNCOMMITTED:
          case tsqlParser::UNKNOWN:
          case tsqlParser::USING:
          case tsqlParser::VAR:
          case tsqlParser::VARP:
          case tsqlParser::VIEWS:
          case tsqlParser::VIEW_METADATA:
          case tsqlParser::WORK:
          case tsqlParser::XML:
          case tsqlParser::XMLNAMESPACES:
          case tsqlParser::ZONE:
          case tsqlParser::DOUBLE_QUOTE_ID:
          case tsqlParser::SQUARE_BRACKET_ID:
          case tsqlParser::ID: {
            setState(3194);
            r_id();
            break;
          }

          case tsqlParser::STRING: {
            setState(3195);
            match(tsqlParser::STRING);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case tsqlParser::NESTED_TRIGGERS: {
        enterOuterAlt(_localctx, 4);
        setState(3198);
        match(tsqlParser::NESTED_TRIGGERS);
        setState(3199);
        match(tsqlParser::EQUAL);
        setState(3200);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::OFF

        || _la == tsqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case tsqlParser::TRANSFORM_NOISE_WORDS: {
        enterOuterAlt(_localctx, 5);
        setState(3201);
        match(tsqlParser::TRANSFORM_NOISE_WORDS);
        setState(3202);
        match(tsqlParser::EQUAL);
        setState(3203);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::OFF

        || _la == tsqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case tsqlParser::TWO_DIGIT_YEAR_CUTOFF: {
        enterOuterAlt(_localctx, 6);
        setState(3204);
        match(tsqlParser::TWO_DIGIT_YEAR_CUTOFF);
        setState(3205);
        match(tsqlParser::EQUAL);
        setState(3206);
        match(tsqlParser::DECIMAL);
        break;
      }

      case tsqlParser::DB_CHAINING: {
        enterOuterAlt(_localctx, 7);
        setState(3207);
        match(tsqlParser::DB_CHAINING);
        setState(3208);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::OFF

        || _la == tsqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case tsqlParser::TRUSTWORTHY: {
        enterOuterAlt(_localctx, 8);
        setState(3209);
        match(tsqlParser::TRUSTWORTHY);
        setState(3210);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::OFF

        || _la == tsqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Database_filestream_optionContext ------------------------------------------------------------------

tsqlParser::Database_filestream_optionContext::Database_filestream_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Database_filestream_optionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Database_filestream_optionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Database_filestream_optionContext::NON_TRANSACTED_ACCESS() {
  return getToken(tsqlParser::NON_TRANSACTED_ACCESS, 0);
}

tree::TerminalNode* tsqlParser::Database_filestream_optionContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Database_filestream_optionContext::DIRECTORY_NAME() {
  return getToken(tsqlParser::DIRECTORY_NAME, 0);
}

tree::TerminalNode* tsqlParser::Database_filestream_optionContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}

tree::TerminalNode* tsqlParser::Database_filestream_optionContext::OFF() {
  return getToken(tsqlParser::OFF, 0);
}

tree::TerminalNode* tsqlParser::Database_filestream_optionContext::READ_ONLY() {
  return getToken(tsqlParser::READ_ONLY, 0);
}

tree::TerminalNode* tsqlParser::Database_filestream_optionContext::FULL() {
  return getToken(tsqlParser::FULL, 0);
}


size_t tsqlParser::Database_filestream_optionContext::getRuleIndex() const {
  return tsqlParser::RuleDatabase_filestream_option;
}


antlrcpp::Any tsqlParser::Database_filestream_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDatabase_filestream_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Database_filestream_optionContext* tsqlParser::database_filestream_option() {
  Database_filestream_optionContext *_localctx = _tracker.createInstance<Database_filestream_optionContext>(_ctx, getState());
  enterRule(_localctx, 342, tsqlParser::RuleDatabase_filestream_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3213);
    match(tsqlParser::LR_BRACKET);
    setState(3220);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::NON_TRANSACTED_ACCESS: {
        setState(3214);
        match(tsqlParser::NON_TRANSACTED_ACCESS);
        setState(3215);
        match(tsqlParser::EQUAL);
        setState(3216);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::FULL

        || _la == tsqlParser::OFF || _la == tsqlParser::READ_ONLY)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case tsqlParser::DIRECTORY_NAME: {
        setState(3217);
        match(tsqlParser::DIRECTORY_NAME);
        setState(3218);
        match(tsqlParser::EQUAL);
        setState(3219);
        match(tsqlParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3222);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Database_file_specContext ------------------------------------------------------------------

tsqlParser::Database_file_specContext::Database_file_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::File_groupContext* tsqlParser::Database_file_specContext::file_group() {
  return getRuleContext<tsqlParser::File_groupContext>(0);
}

tsqlParser::File_specContext* tsqlParser::Database_file_specContext::file_spec() {
  return getRuleContext<tsqlParser::File_specContext>(0);
}


size_t tsqlParser::Database_file_specContext::getRuleIndex() const {
  return tsqlParser::RuleDatabase_file_spec;
}


antlrcpp::Any tsqlParser::Database_file_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDatabase_file_spec(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Database_file_specContext* tsqlParser::database_file_spec() {
  Database_file_specContext *_localctx = _tracker.createInstance<Database_file_specContext>(_ctx, getState());
  enterRule(_localctx, 344, tsqlParser::RuleDatabase_file_spec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3226);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FILEGROUP: {
        enterOuterAlt(_localctx, 1);
        setState(3224);
        file_group();
        break;
      }

      case tsqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(3225);
        file_spec();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_groupContext ------------------------------------------------------------------

tsqlParser::File_groupContext::File_groupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::File_groupContext::FILEGROUP() {
  return getToken(tsqlParser::FILEGROUP, 0);
}

tsqlParser::R_idContext* tsqlParser::File_groupContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

std::vector<tsqlParser::File_specContext *> tsqlParser::File_groupContext::file_spec() {
  return getRuleContexts<tsqlParser::File_specContext>();
}

tsqlParser::File_specContext* tsqlParser::File_groupContext::file_spec(size_t i) {
  return getRuleContext<tsqlParser::File_specContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::File_groupContext::CONTAINS() {
  return getTokens(tsqlParser::CONTAINS);
}

tree::TerminalNode* tsqlParser::File_groupContext::CONTAINS(size_t i) {
  return getToken(tsqlParser::CONTAINS, i);
}

tree::TerminalNode* tsqlParser::File_groupContext::FILESTREAM() {
  return getToken(tsqlParser::FILESTREAM, 0);
}

tree::TerminalNode* tsqlParser::File_groupContext::DEFAULT() {
  return getToken(tsqlParser::DEFAULT, 0);
}

tree::TerminalNode* tsqlParser::File_groupContext::MEMORY_OPTIMIZED_DATA() {
  return getToken(tsqlParser::MEMORY_OPTIMIZED_DATA, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::File_groupContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::File_groupContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::File_groupContext::getRuleIndex() const {
  return tsqlParser::RuleFile_group;
}


antlrcpp::Any tsqlParser::File_groupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFile_group(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::File_groupContext* tsqlParser::file_group() {
  File_groupContext *_localctx = _tracker.createInstance<File_groupContext>(_ctx, getState());
  enterRule(_localctx, 346, tsqlParser::RuleFile_group);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3228);
    match(tsqlParser::FILEGROUP);
    setState(3229);
    r_id();
    setState(3232);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 442, _ctx)) {
    case 1: {
      setState(3230);
      match(tsqlParser::CONTAINS);
      setState(3231);
      match(tsqlParser::FILESTREAM);
      break;
    }

    default:
      break;
    }
    setState(3235);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::DEFAULT) {
      setState(3234);
      match(tsqlParser::DEFAULT);
    }
    setState(3239);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::CONTAINS) {
      setState(3237);
      match(tsqlParser::CONTAINS);
      setState(3238);
      match(tsqlParser::MEMORY_OPTIMIZED_DATA);
    }
    setState(3241);
    file_spec();
    setState(3246);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 445, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3242);
        match(tsqlParser::COMMA);
        setState(3243);
        file_spec(); 
      }
      setState(3248);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 445, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_specContext ------------------------------------------------------------------

tsqlParser::File_specContext::File_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::File_specContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::File_specContext::NAME() {
  return getToken(tsqlParser::NAME, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::File_specContext::EQUAL() {
  return getTokens(tsqlParser::EQUAL);
}

tree::TerminalNode* tsqlParser::File_specContext::EQUAL(size_t i) {
  return getToken(tsqlParser::EQUAL, i);
}

tree::TerminalNode* tsqlParser::File_specContext::FILENAME() {
  return getToken(tsqlParser::FILENAME, 0);
}

tree::TerminalNode* tsqlParser::File_specContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::File_specContext::STRING() {
  return getTokens(tsqlParser::STRING);
}

tree::TerminalNode* tsqlParser::File_specContext::STRING(size_t i) {
  return getToken(tsqlParser::STRING, i);
}

tsqlParser::R_idContext* tsqlParser::File_specContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

std::vector<tree::TerminalNode *> tsqlParser::File_specContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::File_specContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::File_specContext::SIZE() {
  return getToken(tsqlParser::SIZE, 0);
}

std::vector<tsqlParser::File_sizeContext *> tsqlParser::File_specContext::file_size() {
  return getRuleContexts<tsqlParser::File_sizeContext>();
}

tsqlParser::File_sizeContext* tsqlParser::File_specContext::file_size(size_t i) {
  return getRuleContext<tsqlParser::File_sizeContext>(i);
}

tree::TerminalNode* tsqlParser::File_specContext::MAXSIZE() {
  return getToken(tsqlParser::MAXSIZE, 0);
}

tree::TerminalNode* tsqlParser::File_specContext::FILEGROWTH() {
  return getToken(tsqlParser::FILEGROWTH, 0);
}

tree::TerminalNode* tsqlParser::File_specContext::UNLIMITED() {
  return getToken(tsqlParser::UNLIMITED, 0);
}


size_t tsqlParser::File_specContext::getRuleIndex() const {
  return tsqlParser::RuleFile_spec;
}


antlrcpp::Any tsqlParser::File_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFile_spec(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::File_specContext* tsqlParser::file_spec() {
  File_specContext *_localctx = _tracker.createInstance<File_specContext>(_ctx, getState());
  enterRule(_localctx, 348, tsqlParser::RuleFile_spec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3249);
    match(tsqlParser::LR_BRACKET);
    setState(3250);
    match(tsqlParser::NAME);
    setState(3251);
    match(tsqlParser::EQUAL);
    setState(3254);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        setState(3252);
        r_id();
        break;
      }

      case tsqlParser::STRING: {
        setState(3253);
        match(tsqlParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3257);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::COMMA) {
      setState(3256);
      match(tsqlParser::COMMA);
    }
    setState(3259);
    match(tsqlParser::FILENAME);
    setState(3260);
    match(tsqlParser::EQUAL);
    setState(3261);
    dynamic_cast<File_specContext *>(_localctx)->r_file = match(tsqlParser::STRING);
    setState(3263);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::COMMA) {
      setState(3262);
      match(tsqlParser::COMMA);
    }
    setState(3271);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::SIZE) {
      setState(3265);
      match(tsqlParser::SIZE);
      setState(3266);
      match(tsqlParser::EQUAL);
      setState(3267);
      file_size();
      setState(3269);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::COMMA) {
        setState(3268);
        match(tsqlParser::COMMA);
      }
    }
    setState(3282);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::MAXSIZE) {
      setState(3273);
      match(tsqlParser::MAXSIZE);
      setState(3274);
      match(tsqlParser::EQUAL);
      setState(3277);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case tsqlParser::DECIMAL: {
          setState(3275);
          file_size();
          break;
        }

        case tsqlParser::UNLIMITED: {
          setState(3276);
          match(tsqlParser::UNLIMITED);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(3280);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::COMMA) {
        setState(3279);
        match(tsqlParser::COMMA);
      }
    }
    setState(3290);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::FILEGROWTH) {
      setState(3284);
      match(tsqlParser::FILEGROWTH);
      setState(3285);
      match(tsqlParser::EQUAL);
      setState(3286);
      file_size();
      setState(3288);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::COMMA) {
        setState(3287);
        match(tsqlParser::COMMA);
      }
    }
    setState(3292);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_table_nameContext ------------------------------------------------------------------

tsqlParser::Full_table_nameContext::Full_table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Full_table_nameContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Full_table_nameContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Full_table_nameContext::DOT() {
  return getTokens(tsqlParser::DOT);
}

tree::TerminalNode* tsqlParser::Full_table_nameContext::DOT(size_t i) {
  return getToken(tsqlParser::DOT, i);
}


size_t tsqlParser::Full_table_nameContext::getRuleIndex() const {
  return tsqlParser::RuleFull_table_name;
}


antlrcpp::Any tsqlParser::Full_table_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFull_table_name(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Full_table_nameContext* tsqlParser::full_table_name() {
  Full_table_nameContext *_localctx = _tracker.createInstance<Full_table_nameContext>(_ctx, getState());
  enterRule(_localctx, 350, tsqlParser::RuleFull_table_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3311);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 457, _ctx)) {
    case 1: {
      setState(3294);
      dynamic_cast<Full_table_nameContext *>(_localctx)->server = r_id();
      setState(3295);
      match(tsqlParser::DOT);
      setState(3296);
      dynamic_cast<Full_table_nameContext *>(_localctx)->database = r_id();
      setState(3297);
      match(tsqlParser::DOT);
      setState(3298);
      dynamic_cast<Full_table_nameContext *>(_localctx)->schema = r_id();
      setState(3299);
      match(tsqlParser::DOT);
      break;
    }

    case 2: {
      setState(3301);
      dynamic_cast<Full_table_nameContext *>(_localctx)->database = r_id();
      setState(3302);
      match(tsqlParser::DOT);
      setState(3304);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & ((1ULL << (tsqlParser::FORCESEEK - 73))
        | (1ULL << (tsqlParser::NEXT - 73))
        | (1ULL << (tsqlParser::NUMERIC - 73)))) != 0) || ((((_la - 196) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 196)) & ((1ULL << (tsqlParser::VALUE - 196))
        | (1ULL << (tsqlParser::ABSOLUTE - 196))
        | (1ULL << (tsqlParser::APPLY - 196))
        | (1ULL << (tsqlParser::AUTO - 196))
        | (1ULL << (tsqlParser::AVG - 196))
        | (1ULL << (tsqlParser::BASE64 - 196))
        | (1ULL << (tsqlParser::CALLER - 196))
        | (1ULL << (tsqlParser::CAST - 196))
        | (1ULL << (tsqlParser::CATCH - 196))
        | (1ULL << (tsqlParser::CHECKSUM_AGG - 196))
        | (1ULL << (tsqlParser::COMMITTED - 196))
        | (1ULL << (tsqlParser::CONCAT - 196))
        | (1ULL << (tsqlParser::CONTROL - 196))
        | (1ULL << (tsqlParser::COOKIE - 196))
        | (1ULL << (tsqlParser::COUNT - 196))
        | (1ULL << (tsqlParser::COUNT_BIG - 196))
        | (1ULL << (tsqlParser::DATE - 196)))) != 0) || ((((_la - 261) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 261)) & ((1ULL << (tsqlParser::DELAY - 261))
        | (1ULL << (tsqlParser::DELETED - 261))
        | (1ULL << (tsqlParser::DENSE_RANK - 261))
        | (1ULL << (tsqlParser::DISABLE - 261))
        | (1ULL << (tsqlParser::DYNAMIC - 261))
        | (1ULL << (tsqlParser::ENCRYPTION - 261))
        | (1ULL << (tsqlParser::EXIST - 261))
        | (1ULL << (tsqlParser::EXPAND - 261))
        | (1ULL << (tsqlParser::FAST - 261))
        | (1ULL << (tsqlParser::FAST_FORWARD - 261))
        | (1ULL << (tsqlParser::FIRST - 261))
        | (1ULL << (tsqlParser::FIRST_VALUE - 261))
        | (1ULL << (tsqlParser::FOLLOWING - 261))
        | (1ULL << (tsqlParser::FORCE - 261))
        | (1ULL << (tsqlParser::FORCED - 261))
        | (1ULL << (tsqlParser::FORWARD_ONLY - 261))
        | (1ULL << (tsqlParser::FULLSCAN - 261))
        | (1ULL << (tsqlParser::GLOBAL - 261))
        | (1ULL << (tsqlParser::GROUPING - 261))
        | (1ULL << (tsqlParser::GROUPING_ID - 261))
        | (1ULL << (tsqlParser::HASH - 261))
        | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 261))
        | (1ULL << (tsqlParser::IMPERSONATE - 261))
        | (1ULL << (tsqlParser::INSENSITIVE - 261))
        | (1ULL << (tsqlParser::INSERTED - 261))
        | (1ULL << (tsqlParser::ISOLATION - 261))
        | (1ULL << (tsqlParser::IO - 261))
        | (1ULL << (tsqlParser::KEEP - 261))
        | (1ULL << (tsqlParser::KEEPFIXED - 261))
        | (1ULL << (tsqlParser::KEYSET - 261))
        | (1ULL << (tsqlParser::LAG - 261))
        | (1ULL << (tsqlParser::LAST - 261))
        | (1ULL << (tsqlParser::LAST_VALUE - 261))
        | (1ULL << (tsqlParser::LEAD - 261))
        | (1ULL << (tsqlParser::LEVEL - 261))
        | (1ULL << (tsqlParser::LOCAL - 261))
        | (1ULL << (tsqlParser::LOCK_ESCALATION - 261))
        | (1ULL << (tsqlParser::LOGIN - 261))
        | (1ULL << (tsqlParser::LOOP - 261))
        | (1ULL << (tsqlParser::MARK - 261))
        | (1ULL << (tsqlParser::MAX - 261))
        | (1ULL << (tsqlParser::MAXDOP - 261))
        | (1ULL << (tsqlParser::MAXRECURSION - 261)))) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 328)) & ((1ULL << (tsqlParser::MIN - 328))
        | (1ULL << (tsqlParser::MODIFY - 328))
        | (1ULL << (tsqlParser::NAME - 328))
        | (1ULL << (tsqlParser::NOCOUNT - 328))
        | (1ULL << (tsqlParser::NODES - 328))
        | (1ULL << (tsqlParser::NOEXPAND - 328))
        | (1ULL << (tsqlParser::NORECOMPUTE - 328))
        | (1ULL << (tsqlParser::NTILE - 328))
        | (1ULL << (tsqlParser::NUMBER - 328))
        | (1ULL << (tsqlParser::OFFSET - 328))
        | (1ULL << (tsqlParser::ONLINE - 328))
        | (1ULL << (tsqlParser::ONLY - 328))
        | (1ULL << (tsqlParser::OPTIMISTIC - 328))
        | (1ULL << (tsqlParser::OPTIMIZE - 328))
        | (1ULL << (tsqlParser::OUT - 328))
        | (1ULL << (tsqlParser::OUTPUT - 328))
        | (1ULL << (tsqlParser::OWNER - 328))
        | (1ULL << (tsqlParser::PARAMETERIZATION - 328))
        | (1ULL << (tsqlParser::PARTITION - 328))
        | (1ULL << (tsqlParser::PATH - 328))
        | (1ULL << (tsqlParser::PRECEDING - 328))
        | (1ULL << (tsqlParser::PRIOR - 328))
        | (1ULL << (tsqlParser::PRIVILEGES - 328))
        | (1ULL << (tsqlParser::QUERY - 328))
        | (1ULL << (tsqlParser::RANGE - 328))
        | (1ULL << (tsqlParser::RANK - 328))
        | (1ULL << (tsqlParser::READONLY - 328))
        | (1ULL << (tsqlParser::READ_ONLY - 328))
        | (1ULL << (tsqlParser::RECOMPILE - 328))
        | (1ULL << (tsqlParser::RELATIVE - 328))
        | (1ULL << (tsqlParser::REMOTE - 328))
        | (1ULL << (tsqlParser::REPEATABLE - 328))
        | (1ULL << (tsqlParser::ROBUST - 328))
        | (1ULL << (tsqlParser::ROOT - 328))
        | (1ULL << (tsqlParser::ROW - 328))
        | (1ULL << (tsqlParser::ROWGUID - 328))
        | (1ULL << (tsqlParser::ROWS - 328))
        | (1ULL << (tsqlParser::ROW_NUMBER - 328))
        | (1ULL << (tsqlParser::SAMPLE - 328))
        | (1ULL << (tsqlParser::SCHEMABINDING - 328))
        | (1ULL << (tsqlParser::SCROLL - 328))
        | (1ULL << (tsqlParser::SCROLL_LOCKS - 328)))) != 0) || ((((_la - 393) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 393)) & ((1ULL << (tsqlParser::SELF - 393))
        | (1ULL << (tsqlParser::SERIALIZABLE - 393))
        | (1ULL << (tsqlParser::SIMPLE - 393))
        | (1ULL << (tsqlParser::SIZE - 393))
        | (1ULL << (tsqlParser::SNAPSHOT - 393))
        | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 393))
        | (1ULL << (tsqlParser::STATIC - 393))
        | (1ULL << (tsqlParser::STATS_STREAM - 393))
        | (1ULL << (tsqlParser::STDEV - 393))
        | (1ULL << (tsqlParser::STDEVP - 393))
        | (1ULL << (tsqlParser::SUM - 393))
        | (1ULL << (tsqlParser::TEXTIMAGE_ON - 393))
        | (1ULL << (tsqlParser::THROW - 393))
        | (1ULL << (tsqlParser::TIES - 393))
        | (1ULL << (tsqlParser::TIME - 393))
        | (1ULL << (tsqlParser::TRY - 393))
        | (1ULL << (tsqlParser::TYPE - 393))
        | (1ULL << (tsqlParser::TYPE_WARNING - 393))
        | (1ULL << (tsqlParser::UNBOUNDED - 393))
        | (1ULL << (tsqlParser::UNCOMMITTED - 393))
        | (1ULL << (tsqlParser::UNKNOWN - 393))
        | (1ULL << (tsqlParser::USING - 393))
        | (1ULL << (tsqlParser::VAR - 393))
        | (1ULL << (tsqlParser::VARP - 393))
        | (1ULL << (tsqlParser::VIEWS - 393))
        | (1ULL << (tsqlParser::VIEW_METADATA - 393))
        | (1ULL << (tsqlParser::WORK - 393))
        | (1ULL << (tsqlParser::XML - 393))
        | (1ULL << (tsqlParser::XMLNAMESPACES - 393))
        | (1ULL << (tsqlParser::ZONE - 393))
        | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 393))
        | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 393))
        | (1ULL << (tsqlParser::ID - 393)))) != 0)) {
        setState(3303);
        dynamic_cast<Full_table_nameContext *>(_localctx)->schema = r_id();
      }
      setState(3306);
      match(tsqlParser::DOT);
      break;
    }

    case 3: {
      setState(3308);
      dynamic_cast<Full_table_nameContext *>(_localctx)->schema = r_id();
      setState(3309);
      match(tsqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3313);
    dynamic_cast<Full_table_nameContext *>(_localctx)->table = r_id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_nameContext ------------------------------------------------------------------

tsqlParser::Table_nameContext::Table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Table_nameContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Table_nameContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Table_nameContext::DOT() {
  return getTokens(tsqlParser::DOT);
}

tree::TerminalNode* tsqlParser::Table_nameContext::DOT(size_t i) {
  return getToken(tsqlParser::DOT, i);
}


size_t tsqlParser::Table_nameContext::getRuleIndex() const {
  return tsqlParser::RuleTable_name;
}


antlrcpp::Any tsqlParser::Table_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitTable_name(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Table_nameContext* tsqlParser::table_name() {
  Table_nameContext *_localctx = _tracker.createInstance<Table_nameContext>(_ctx, getState());
  enterRule(_localctx, 352, tsqlParser::RuleTable_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3325);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 459, _ctx)) {
    case 1: {
      setState(3315);
      dynamic_cast<Table_nameContext *>(_localctx)->database = r_id();
      setState(3316);
      match(tsqlParser::DOT);
      setState(3318);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & ((1ULL << (tsqlParser::FORCESEEK - 73))
        | (1ULL << (tsqlParser::NEXT - 73))
        | (1ULL << (tsqlParser::NUMERIC - 73)))) != 0) || ((((_la - 196) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 196)) & ((1ULL << (tsqlParser::VALUE - 196))
        | (1ULL << (tsqlParser::ABSOLUTE - 196))
        | (1ULL << (tsqlParser::APPLY - 196))
        | (1ULL << (tsqlParser::AUTO - 196))
        | (1ULL << (tsqlParser::AVG - 196))
        | (1ULL << (tsqlParser::BASE64 - 196))
        | (1ULL << (tsqlParser::CALLER - 196))
        | (1ULL << (tsqlParser::CAST - 196))
        | (1ULL << (tsqlParser::CATCH - 196))
        | (1ULL << (tsqlParser::CHECKSUM_AGG - 196))
        | (1ULL << (tsqlParser::COMMITTED - 196))
        | (1ULL << (tsqlParser::CONCAT - 196))
        | (1ULL << (tsqlParser::CONTROL - 196))
        | (1ULL << (tsqlParser::COOKIE - 196))
        | (1ULL << (tsqlParser::COUNT - 196))
        | (1ULL << (tsqlParser::COUNT_BIG - 196))
        | (1ULL << (tsqlParser::DATE - 196)))) != 0) || ((((_la - 261) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 261)) & ((1ULL << (tsqlParser::DELAY - 261))
        | (1ULL << (tsqlParser::DELETED - 261))
        | (1ULL << (tsqlParser::DENSE_RANK - 261))
        | (1ULL << (tsqlParser::DISABLE - 261))
        | (1ULL << (tsqlParser::DYNAMIC - 261))
        | (1ULL << (tsqlParser::ENCRYPTION - 261))
        | (1ULL << (tsqlParser::EXIST - 261))
        | (1ULL << (tsqlParser::EXPAND - 261))
        | (1ULL << (tsqlParser::FAST - 261))
        | (1ULL << (tsqlParser::FAST_FORWARD - 261))
        | (1ULL << (tsqlParser::FIRST - 261))
        | (1ULL << (tsqlParser::FIRST_VALUE - 261))
        | (1ULL << (tsqlParser::FOLLOWING - 261))
        | (1ULL << (tsqlParser::FORCE - 261))
        | (1ULL << (tsqlParser::FORCED - 261))
        | (1ULL << (tsqlParser::FORWARD_ONLY - 261))
        | (1ULL << (tsqlParser::FULLSCAN - 261))
        | (1ULL << (tsqlParser::GLOBAL - 261))
        | (1ULL << (tsqlParser::GROUPING - 261))
        | (1ULL << (tsqlParser::GROUPING_ID - 261))
        | (1ULL << (tsqlParser::HASH - 261))
        | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 261))
        | (1ULL << (tsqlParser::IMPERSONATE - 261))
        | (1ULL << (tsqlParser::INSENSITIVE - 261))
        | (1ULL << (tsqlParser::INSERTED - 261))
        | (1ULL << (tsqlParser::ISOLATION - 261))
        | (1ULL << (tsqlParser::IO - 261))
        | (1ULL << (tsqlParser::KEEP - 261))
        | (1ULL << (tsqlParser::KEEPFIXED - 261))
        | (1ULL << (tsqlParser::KEYSET - 261))
        | (1ULL << (tsqlParser::LAG - 261))
        | (1ULL << (tsqlParser::LAST - 261))
        | (1ULL << (tsqlParser::LAST_VALUE - 261))
        | (1ULL << (tsqlParser::LEAD - 261))
        | (1ULL << (tsqlParser::LEVEL - 261))
        | (1ULL << (tsqlParser::LOCAL - 261))
        | (1ULL << (tsqlParser::LOCK_ESCALATION - 261))
        | (1ULL << (tsqlParser::LOGIN - 261))
        | (1ULL << (tsqlParser::LOOP - 261))
        | (1ULL << (tsqlParser::MARK - 261))
        | (1ULL << (tsqlParser::MAX - 261))
        | (1ULL << (tsqlParser::MAXDOP - 261))
        | (1ULL << (tsqlParser::MAXRECURSION - 261)))) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 328)) & ((1ULL << (tsqlParser::MIN - 328))
        | (1ULL << (tsqlParser::MODIFY - 328))
        | (1ULL << (tsqlParser::NAME - 328))
        | (1ULL << (tsqlParser::NOCOUNT - 328))
        | (1ULL << (tsqlParser::NODES - 328))
        | (1ULL << (tsqlParser::NOEXPAND - 328))
        | (1ULL << (tsqlParser::NORECOMPUTE - 328))
        | (1ULL << (tsqlParser::NTILE - 328))
        | (1ULL << (tsqlParser::NUMBER - 328))
        | (1ULL << (tsqlParser::OFFSET - 328))
        | (1ULL << (tsqlParser::ONLINE - 328))
        | (1ULL << (tsqlParser::ONLY - 328))
        | (1ULL << (tsqlParser::OPTIMISTIC - 328))
        | (1ULL << (tsqlParser::OPTIMIZE - 328))
        | (1ULL << (tsqlParser::OUT - 328))
        | (1ULL << (tsqlParser::OUTPUT - 328))
        | (1ULL << (tsqlParser::OWNER - 328))
        | (1ULL << (tsqlParser::PARAMETERIZATION - 328))
        | (1ULL << (tsqlParser::PARTITION - 328))
        | (1ULL << (tsqlParser::PATH - 328))
        | (1ULL << (tsqlParser::PRECEDING - 328))
        | (1ULL << (tsqlParser::PRIOR - 328))
        | (1ULL << (tsqlParser::PRIVILEGES - 328))
        | (1ULL << (tsqlParser::QUERY - 328))
        | (1ULL << (tsqlParser::RANGE - 328))
        | (1ULL << (tsqlParser::RANK - 328))
        | (1ULL << (tsqlParser::READONLY - 328))
        | (1ULL << (tsqlParser::READ_ONLY - 328))
        | (1ULL << (tsqlParser::RECOMPILE - 328))
        | (1ULL << (tsqlParser::RELATIVE - 328))
        | (1ULL << (tsqlParser::REMOTE - 328))
        | (1ULL << (tsqlParser::REPEATABLE - 328))
        | (1ULL << (tsqlParser::ROBUST - 328))
        | (1ULL << (tsqlParser::ROOT - 328))
        | (1ULL << (tsqlParser::ROW - 328))
        | (1ULL << (tsqlParser::ROWGUID - 328))
        | (1ULL << (tsqlParser::ROWS - 328))
        | (1ULL << (tsqlParser::ROW_NUMBER - 328))
        | (1ULL << (tsqlParser::SAMPLE - 328))
        | (1ULL << (tsqlParser::SCHEMABINDING - 328))
        | (1ULL << (tsqlParser::SCROLL - 328))
        | (1ULL << (tsqlParser::SCROLL_LOCKS - 328)))) != 0) || ((((_la - 393) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 393)) & ((1ULL << (tsqlParser::SELF - 393))
        | (1ULL << (tsqlParser::SERIALIZABLE - 393))
        | (1ULL << (tsqlParser::SIMPLE - 393))
        | (1ULL << (tsqlParser::SIZE - 393))
        | (1ULL << (tsqlParser::SNAPSHOT - 393))
        | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 393))
        | (1ULL << (tsqlParser::STATIC - 393))
        | (1ULL << (tsqlParser::STATS_STREAM - 393))
        | (1ULL << (tsqlParser::STDEV - 393))
        | (1ULL << (tsqlParser::STDEVP - 393))
        | (1ULL << (tsqlParser::SUM - 393))
        | (1ULL << (tsqlParser::TEXTIMAGE_ON - 393))
        | (1ULL << (tsqlParser::THROW - 393))
        | (1ULL << (tsqlParser::TIES - 393))
        | (1ULL << (tsqlParser::TIME - 393))
        | (1ULL << (tsqlParser::TRY - 393))
        | (1ULL << (tsqlParser::TYPE - 393))
        | (1ULL << (tsqlParser::TYPE_WARNING - 393))
        | (1ULL << (tsqlParser::UNBOUNDED - 393))
        | (1ULL << (tsqlParser::UNCOMMITTED - 393))
        | (1ULL << (tsqlParser::UNKNOWN - 393))
        | (1ULL << (tsqlParser::USING - 393))
        | (1ULL << (tsqlParser::VAR - 393))
        | (1ULL << (tsqlParser::VARP - 393))
        | (1ULL << (tsqlParser::VIEWS - 393))
        | (1ULL << (tsqlParser::VIEW_METADATA - 393))
        | (1ULL << (tsqlParser::WORK - 393))
        | (1ULL << (tsqlParser::XML - 393))
        | (1ULL << (tsqlParser::XMLNAMESPACES - 393))
        | (1ULL << (tsqlParser::ZONE - 393))
        | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 393))
        | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 393))
        | (1ULL << (tsqlParser::ID - 393)))) != 0)) {
        setState(3317);
        dynamic_cast<Table_nameContext *>(_localctx)->schema = r_id();
      }
      setState(3320);
      match(tsqlParser::DOT);
      break;
    }

    case 2: {
      setState(3322);
      dynamic_cast<Table_nameContext *>(_localctx)->schema = r_id();
      setState(3323);
      match(tsqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3327);
    dynamic_cast<Table_nameContext *>(_localctx)->table = r_id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_nameContext ------------------------------------------------------------------

tsqlParser::Simple_nameContext::Simple_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Simple_nameContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Simple_nameContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

tree::TerminalNode* tsqlParser::Simple_nameContext::DOT() {
  return getToken(tsqlParser::DOT, 0);
}


size_t tsqlParser::Simple_nameContext::getRuleIndex() const {
  return tsqlParser::RuleSimple_name;
}


antlrcpp::Any tsqlParser::Simple_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSimple_name(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Simple_nameContext* tsqlParser::simple_name() {
  Simple_nameContext *_localctx = _tracker.createInstance<Simple_nameContext>(_ctx, getState());
  enterRule(_localctx, 354, tsqlParser::RuleSimple_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3332);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 460, _ctx)) {
    case 1: {
      setState(3329);
      dynamic_cast<Simple_nameContext *>(_localctx)->schema = r_id();
      setState(3330);
      match(tsqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3334);
    dynamic_cast<Simple_nameContext *>(_localctx)->name = r_id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_proc_nameContext ------------------------------------------------------------------

tsqlParser::Func_proc_nameContext::Func_proc_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Func_proc_nameContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Func_proc_nameContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Func_proc_nameContext::DOT() {
  return getTokens(tsqlParser::DOT);
}

tree::TerminalNode* tsqlParser::Func_proc_nameContext::DOT(size_t i) {
  return getToken(tsqlParser::DOT, i);
}


size_t tsqlParser::Func_proc_nameContext::getRuleIndex() const {
  return tsqlParser::RuleFunc_proc_name;
}


antlrcpp::Any tsqlParser::Func_proc_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFunc_proc_name(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Func_proc_nameContext* tsqlParser::func_proc_name() {
  Func_proc_nameContext *_localctx = _tracker.createInstance<Func_proc_nameContext>(_ctx, getState());
  enterRule(_localctx, 356, tsqlParser::RuleFunc_proc_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3346);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 462, _ctx)) {
    case 1: {
      setState(3336);
      dynamic_cast<Func_proc_nameContext *>(_localctx)->database = r_id();
      setState(3337);
      match(tsqlParser::DOT);
      setState(3339);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & ((1ULL << (tsqlParser::FORCESEEK - 73))
        | (1ULL << (tsqlParser::NEXT - 73))
        | (1ULL << (tsqlParser::NUMERIC - 73)))) != 0) || ((((_la - 196) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 196)) & ((1ULL << (tsqlParser::VALUE - 196))
        | (1ULL << (tsqlParser::ABSOLUTE - 196))
        | (1ULL << (tsqlParser::APPLY - 196))
        | (1ULL << (tsqlParser::AUTO - 196))
        | (1ULL << (tsqlParser::AVG - 196))
        | (1ULL << (tsqlParser::BASE64 - 196))
        | (1ULL << (tsqlParser::CALLER - 196))
        | (1ULL << (tsqlParser::CAST - 196))
        | (1ULL << (tsqlParser::CATCH - 196))
        | (1ULL << (tsqlParser::CHECKSUM_AGG - 196))
        | (1ULL << (tsqlParser::COMMITTED - 196))
        | (1ULL << (tsqlParser::CONCAT - 196))
        | (1ULL << (tsqlParser::CONTROL - 196))
        | (1ULL << (tsqlParser::COOKIE - 196))
        | (1ULL << (tsqlParser::COUNT - 196))
        | (1ULL << (tsqlParser::COUNT_BIG - 196))
        | (1ULL << (tsqlParser::DATE - 196)))) != 0) || ((((_la - 261) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 261)) & ((1ULL << (tsqlParser::DELAY - 261))
        | (1ULL << (tsqlParser::DELETED - 261))
        | (1ULL << (tsqlParser::DENSE_RANK - 261))
        | (1ULL << (tsqlParser::DISABLE - 261))
        | (1ULL << (tsqlParser::DYNAMIC - 261))
        | (1ULL << (tsqlParser::ENCRYPTION - 261))
        | (1ULL << (tsqlParser::EXIST - 261))
        | (1ULL << (tsqlParser::EXPAND - 261))
        | (1ULL << (tsqlParser::FAST - 261))
        | (1ULL << (tsqlParser::FAST_FORWARD - 261))
        | (1ULL << (tsqlParser::FIRST - 261))
        | (1ULL << (tsqlParser::FIRST_VALUE - 261))
        | (1ULL << (tsqlParser::FOLLOWING - 261))
        | (1ULL << (tsqlParser::FORCE - 261))
        | (1ULL << (tsqlParser::FORCED - 261))
        | (1ULL << (tsqlParser::FORWARD_ONLY - 261))
        | (1ULL << (tsqlParser::FULLSCAN - 261))
        | (1ULL << (tsqlParser::GLOBAL - 261))
        | (1ULL << (tsqlParser::GROUPING - 261))
        | (1ULL << (tsqlParser::GROUPING_ID - 261))
        | (1ULL << (tsqlParser::HASH - 261))
        | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 261))
        | (1ULL << (tsqlParser::IMPERSONATE - 261))
        | (1ULL << (tsqlParser::INSENSITIVE - 261))
        | (1ULL << (tsqlParser::INSERTED - 261))
        | (1ULL << (tsqlParser::ISOLATION - 261))
        | (1ULL << (tsqlParser::IO - 261))
        | (1ULL << (tsqlParser::KEEP - 261))
        | (1ULL << (tsqlParser::KEEPFIXED - 261))
        | (1ULL << (tsqlParser::KEYSET - 261))
        | (1ULL << (tsqlParser::LAG - 261))
        | (1ULL << (tsqlParser::LAST - 261))
        | (1ULL << (tsqlParser::LAST_VALUE - 261))
        | (1ULL << (tsqlParser::LEAD - 261))
        | (1ULL << (tsqlParser::LEVEL - 261))
        | (1ULL << (tsqlParser::LOCAL - 261))
        | (1ULL << (tsqlParser::LOCK_ESCALATION - 261))
        | (1ULL << (tsqlParser::LOGIN - 261))
        | (1ULL << (tsqlParser::LOOP - 261))
        | (1ULL << (tsqlParser::MARK - 261))
        | (1ULL << (tsqlParser::MAX - 261))
        | (1ULL << (tsqlParser::MAXDOP - 261))
        | (1ULL << (tsqlParser::MAXRECURSION - 261)))) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 328)) & ((1ULL << (tsqlParser::MIN - 328))
        | (1ULL << (tsqlParser::MODIFY - 328))
        | (1ULL << (tsqlParser::NAME - 328))
        | (1ULL << (tsqlParser::NOCOUNT - 328))
        | (1ULL << (tsqlParser::NODES - 328))
        | (1ULL << (tsqlParser::NOEXPAND - 328))
        | (1ULL << (tsqlParser::NORECOMPUTE - 328))
        | (1ULL << (tsqlParser::NTILE - 328))
        | (1ULL << (tsqlParser::NUMBER - 328))
        | (1ULL << (tsqlParser::OFFSET - 328))
        | (1ULL << (tsqlParser::ONLINE - 328))
        | (1ULL << (tsqlParser::ONLY - 328))
        | (1ULL << (tsqlParser::OPTIMISTIC - 328))
        | (1ULL << (tsqlParser::OPTIMIZE - 328))
        | (1ULL << (tsqlParser::OUT - 328))
        | (1ULL << (tsqlParser::OUTPUT - 328))
        | (1ULL << (tsqlParser::OWNER - 328))
        | (1ULL << (tsqlParser::PARAMETERIZATION - 328))
        | (1ULL << (tsqlParser::PARTITION - 328))
        | (1ULL << (tsqlParser::PATH - 328))
        | (1ULL << (tsqlParser::PRECEDING - 328))
        | (1ULL << (tsqlParser::PRIOR - 328))
        | (1ULL << (tsqlParser::PRIVILEGES - 328))
        | (1ULL << (tsqlParser::QUERY - 328))
        | (1ULL << (tsqlParser::RANGE - 328))
        | (1ULL << (tsqlParser::RANK - 328))
        | (1ULL << (tsqlParser::READONLY - 328))
        | (1ULL << (tsqlParser::READ_ONLY - 328))
        | (1ULL << (tsqlParser::RECOMPILE - 328))
        | (1ULL << (tsqlParser::RELATIVE - 328))
        | (1ULL << (tsqlParser::REMOTE - 328))
        | (1ULL << (tsqlParser::REPEATABLE - 328))
        | (1ULL << (tsqlParser::ROBUST - 328))
        | (1ULL << (tsqlParser::ROOT - 328))
        | (1ULL << (tsqlParser::ROW - 328))
        | (1ULL << (tsqlParser::ROWGUID - 328))
        | (1ULL << (tsqlParser::ROWS - 328))
        | (1ULL << (tsqlParser::ROW_NUMBER - 328))
        | (1ULL << (tsqlParser::SAMPLE - 328))
        | (1ULL << (tsqlParser::SCHEMABINDING - 328))
        | (1ULL << (tsqlParser::SCROLL - 328))
        | (1ULL << (tsqlParser::SCROLL_LOCKS - 328)))) != 0) || ((((_la - 393) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 393)) & ((1ULL << (tsqlParser::SELF - 393))
        | (1ULL << (tsqlParser::SERIALIZABLE - 393))
        | (1ULL << (tsqlParser::SIMPLE - 393))
        | (1ULL << (tsqlParser::SIZE - 393))
        | (1ULL << (tsqlParser::SNAPSHOT - 393))
        | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 393))
        | (1ULL << (tsqlParser::STATIC - 393))
        | (1ULL << (tsqlParser::STATS_STREAM - 393))
        | (1ULL << (tsqlParser::STDEV - 393))
        | (1ULL << (tsqlParser::STDEVP - 393))
        | (1ULL << (tsqlParser::SUM - 393))
        | (1ULL << (tsqlParser::TEXTIMAGE_ON - 393))
        | (1ULL << (tsqlParser::THROW - 393))
        | (1ULL << (tsqlParser::TIES - 393))
        | (1ULL << (tsqlParser::TIME - 393))
        | (1ULL << (tsqlParser::TRY - 393))
        | (1ULL << (tsqlParser::TYPE - 393))
        | (1ULL << (tsqlParser::TYPE_WARNING - 393))
        | (1ULL << (tsqlParser::UNBOUNDED - 393))
        | (1ULL << (tsqlParser::UNCOMMITTED - 393))
        | (1ULL << (tsqlParser::UNKNOWN - 393))
        | (1ULL << (tsqlParser::USING - 393))
        | (1ULL << (tsqlParser::VAR - 393))
        | (1ULL << (tsqlParser::VARP - 393))
        | (1ULL << (tsqlParser::VIEWS - 393))
        | (1ULL << (tsqlParser::VIEW_METADATA - 393))
        | (1ULL << (tsqlParser::WORK - 393))
        | (1ULL << (tsqlParser::XML - 393))
        | (1ULL << (tsqlParser::XMLNAMESPACES - 393))
        | (1ULL << (tsqlParser::ZONE - 393))
        | (1ULL << (tsqlParser::DOUBLE_QUOTE_ID - 393))
        | (1ULL << (tsqlParser::SQUARE_BRACKET_ID - 393))
        | (1ULL << (tsqlParser::ID - 393)))) != 0)) {
        setState(3338);
        dynamic_cast<Func_proc_nameContext *>(_localctx)->schema = r_id();
      }
      setState(3341);
      match(tsqlParser::DOT);
      break;
    }

    case 2: {
      setState(3343);
      dynamic_cast<Func_proc_nameContext *>(_localctx)->schema = r_id();
      setState(3344);
      match(tsqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3348);
    dynamic_cast<Func_proc_nameContext *>(_localctx)->procedure = r_id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ddl_objectContext ------------------------------------------------------------------

tsqlParser::Ddl_objectContext::Ddl_objectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Full_table_nameContext* tsqlParser::Ddl_objectContext::full_table_name() {
  return getRuleContext<tsqlParser::Full_table_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Ddl_objectContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}


size_t tsqlParser::Ddl_objectContext::getRuleIndex() const {
  return tsqlParser::RuleDdl_object;
}


antlrcpp::Any tsqlParser::Ddl_objectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDdl_object(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Ddl_objectContext* tsqlParser::ddl_object() {
  Ddl_objectContext *_localctx = _tracker.createInstance<Ddl_objectContext>(_ctx, getState());
  enterRule(_localctx, 358, tsqlParser::RuleDdl_object);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3352);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3350);
        full_table_name();
        break;
      }

      case tsqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(3351);
        match(tsqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_column_nameContext ------------------------------------------------------------------

tsqlParser::Full_column_nameContext::Full_column_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::R_idContext* tsqlParser::Full_column_nameContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Full_column_nameContext::DOT() {
  return getToken(tsqlParser::DOT, 0);
}

tsqlParser::Table_nameContext* tsqlParser::Full_column_nameContext::table_name() {
  return getRuleContext<tsqlParser::Table_nameContext>(0);
}


size_t tsqlParser::Full_column_nameContext::getRuleIndex() const {
  return tsqlParser::RuleFull_column_name;
}


antlrcpp::Any tsqlParser::Full_column_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFull_column_name(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Full_column_nameContext* tsqlParser::full_column_name() {
  Full_column_nameContext *_localctx = _tracker.createInstance<Full_column_nameContext>(_ctx, getState());
  enterRule(_localctx, 360, tsqlParser::RuleFull_column_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3357);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 464, _ctx)) {
    case 1: {
      setState(3354);
      dynamic_cast<Full_column_nameContext *>(_localctx)->table = table_name();
      setState(3355);
      match(tsqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3359);
    dynamic_cast<Full_column_nameContext *>(_localctx)->name = r_id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_name_listContext ------------------------------------------------------------------

tsqlParser::Column_name_listContext::Column_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tsqlParser::R_idContext *> tsqlParser::Column_name_listContext::r_id() {
  return getRuleContexts<tsqlParser::R_idContext>();
}

tsqlParser::R_idContext* tsqlParser::Column_name_listContext::r_id(size_t i) {
  return getRuleContext<tsqlParser::R_idContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Column_name_listContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Column_name_listContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Column_name_listContext::getRuleIndex() const {
  return tsqlParser::RuleColumn_name_list;
}


antlrcpp::Any tsqlParser::Column_name_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitColumn_name_list(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Column_name_listContext* tsqlParser::column_name_list() {
  Column_name_listContext *_localctx = _tracker.createInstance<Column_name_listContext>(_ctx, getState());
  enterRule(_localctx, 362, tsqlParser::RuleColumn_name_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3361);
    r_id();
    setState(3366);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == tsqlParser::COMMA) {
      setState(3362);
      match(tsqlParser::COMMA);
      setState(3363);
      r_id();
      setState(3368);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_nameContext ------------------------------------------------------------------

tsqlParser::Cursor_nameContext::Cursor_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::R_idContext* tsqlParser::Cursor_nameContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Cursor_nameContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}


size_t tsqlParser::Cursor_nameContext::getRuleIndex() const {
  return tsqlParser::RuleCursor_name;
}


antlrcpp::Any tsqlParser::Cursor_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCursor_name(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Cursor_nameContext* tsqlParser::cursor_name() {
  Cursor_nameContext *_localctx = _tracker.createInstance<Cursor_nameContext>(_ctx, getState());
  enterRule(_localctx, 364, tsqlParser::RuleCursor_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3371);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3369);
        r_id();
        break;
      }

      case tsqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(3370);
        match(tsqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- On_offContext ------------------------------------------------------------------

tsqlParser::On_offContext::On_offContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::On_offContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

tree::TerminalNode* tsqlParser::On_offContext::OFF() {
  return getToken(tsqlParser::OFF, 0);
}


size_t tsqlParser::On_offContext::getRuleIndex() const {
  return tsqlParser::RuleOn_off;
}


antlrcpp::Any tsqlParser::On_offContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitOn_off(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::On_offContext* tsqlParser::on_off() {
  On_offContext *_localctx = _tracker.createInstance<On_offContext>(_ctx, getState());
  enterRule(_localctx, 366, tsqlParser::RuleOn_off);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3373);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::OFF

    || _la == tsqlParser::ON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClusteredContext ------------------------------------------------------------------

tsqlParser::ClusteredContext::ClusteredContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::ClusteredContext::CLUSTERED() {
  return getToken(tsqlParser::CLUSTERED, 0);
}

tree::TerminalNode* tsqlParser::ClusteredContext::NONCLUSTERED() {
  return getToken(tsqlParser::NONCLUSTERED, 0);
}


size_t tsqlParser::ClusteredContext::getRuleIndex() const {
  return tsqlParser::RuleClustered;
}


antlrcpp::Any tsqlParser::ClusteredContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitClustered(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::ClusteredContext* tsqlParser::clustered() {
  ClusteredContext *_localctx = _tracker.createInstance<ClusteredContext>(_ctx, getState());
  enterRule(_localctx, 368, tsqlParser::RuleClustered);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3375);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::CLUSTERED || _la == tsqlParser::NONCLUSTERED)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Null_notnullContext ------------------------------------------------------------------

tsqlParser::Null_notnullContext::Null_notnullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Null_notnullContext::NULL_() {
  return getToken(tsqlParser::NULL_, 0);
}

tree::TerminalNode* tsqlParser::Null_notnullContext::NOT() {
  return getToken(tsqlParser::NOT, 0);
}


size_t tsqlParser::Null_notnullContext::getRuleIndex() const {
  return tsqlParser::RuleNull_notnull;
}


antlrcpp::Any tsqlParser::Null_notnullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitNull_notnull(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Null_notnullContext* tsqlParser::null_notnull() {
  Null_notnullContext *_localctx = _tracker.createInstance<Null_notnullContext>(_ctx, getState());
  enterRule(_localctx, 370, tsqlParser::RuleNull_notnull);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3378);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::NOT) {
      setState(3377);
      match(tsqlParser::NOT);
    }
    setState(3380);
    match(tsqlParser::NULL_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scalar_function_nameContext ------------------------------------------------------------------

tsqlParser::Scalar_function_nameContext::Scalar_function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Func_proc_nameContext* tsqlParser::Scalar_function_nameContext::func_proc_name() {
  return getRuleContext<tsqlParser::Func_proc_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::RIGHT() {
  return getToken(tsqlParser::RIGHT, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::LEFT() {
  return getToken(tsqlParser::LEFT, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::BINARY_CHECKSUM() {
  return getToken(tsqlParser::BINARY_CHECKSUM, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::CHECKSUM() {
  return getToken(tsqlParser::CHECKSUM, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::EXP() {
  return getToken(tsqlParser::EXP, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::LOG() {
  return getToken(tsqlParser::LOG, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::LOG10() {
  return getToken(tsqlParser::LOG10, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::SQUARE() {
  return getToken(tsqlParser::SQUARE, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::SQRT() {
  return getToken(tsqlParser::SQRT, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::ROUND() {
  return getToken(tsqlParser::ROUND, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::CEILING() {
  return getToken(tsqlParser::CEILING, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::FLOOR() {
  return getToken(tsqlParser::FLOOR, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::POWER() {
  return getToken(tsqlParser::POWER, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::COS() {
  return getToken(tsqlParser::COS, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::SIN() {
  return getToken(tsqlParser::SIN, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::TAN() {
  return getToken(tsqlParser::TAN, 0);
}

tree::TerminalNode* tsqlParser::Scalar_function_nameContext::SIGN() {
  return getToken(tsqlParser::SIGN, 0);
}


size_t tsqlParser::Scalar_function_nameContext::getRuleIndex() const {
  return tsqlParser::RuleScalar_function_name;
}


antlrcpp::Any tsqlParser::Scalar_function_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitScalar_function_name(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Scalar_function_nameContext* tsqlParser::scalar_function_name() {
  Scalar_function_nameContext *_localctx = _tracker.createInstance<Scalar_function_nameContext>(_ctx, getState());
  enterRule(_localctx, 372, tsqlParser::RuleScalar_function_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3400);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::DOUBLE_QUOTE_ID:
      case tsqlParser::SQUARE_BRACKET_ID:
      case tsqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3382);
        func_proc_name();
        break;
      }

      case tsqlParser::RIGHT: {
        enterOuterAlt(_localctx, 2);
        setState(3383);
        match(tsqlParser::RIGHT);
        break;
      }

      case tsqlParser::LEFT: {
        enterOuterAlt(_localctx, 3);
        setState(3384);
        match(tsqlParser::LEFT);
        break;
      }

      case tsqlParser::BINARY_CHECKSUM: {
        enterOuterAlt(_localctx, 4);
        setState(3385);
        match(tsqlParser::BINARY_CHECKSUM);
        break;
      }

      case tsqlParser::CHECKSUM: {
        enterOuterAlt(_localctx, 5);
        setState(3386);
        match(tsqlParser::CHECKSUM);
        break;
      }

      case tsqlParser::EXP: {
        enterOuterAlt(_localctx, 6);
        setState(3387);
        match(tsqlParser::EXP);
        break;
      }

      case tsqlParser::LOG: {
        enterOuterAlt(_localctx, 7);
        setState(3388);
        match(tsqlParser::LOG);
        break;
      }

      case tsqlParser::LOG10: {
        enterOuterAlt(_localctx, 8);
        setState(3389);
        match(tsqlParser::LOG10);
        break;
      }

      case tsqlParser::SQUARE: {
        enterOuterAlt(_localctx, 9);
        setState(3390);
        match(tsqlParser::SQUARE);
        break;
      }

      case tsqlParser::SQRT: {
        enterOuterAlt(_localctx, 10);
        setState(3391);
        match(tsqlParser::SQRT);
        break;
      }

      case tsqlParser::ROUND: {
        enterOuterAlt(_localctx, 11);
        setState(3392);
        match(tsqlParser::ROUND);
        break;
      }

      case tsqlParser::CEILING: {
        enterOuterAlt(_localctx, 12);
        setState(3393);
        match(tsqlParser::CEILING);
        break;
      }

      case tsqlParser::FLOOR: {
        enterOuterAlt(_localctx, 13);
        setState(3394);
        match(tsqlParser::FLOOR);
        break;
      }

      case tsqlParser::POWER: {
        enterOuterAlt(_localctx, 14);
        setState(3395);
        match(tsqlParser::POWER);
        break;
      }

      case tsqlParser::COS: {
        enterOuterAlt(_localctx, 15);
        setState(3396);
        match(tsqlParser::COS);
        break;
      }

      case tsqlParser::SIN: {
        enterOuterAlt(_localctx, 16);
        setState(3397);
        match(tsqlParser::SIN);
        break;
      }

      case tsqlParser::TAN: {
        enterOuterAlt(_localctx, 17);
        setState(3398);
        match(tsqlParser::TAN);
        break;
      }

      case tsqlParser::SIGN: {
        enterOuterAlt(_localctx, 18);
        setState(3399);
        match(tsqlParser::SIGN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_valueContext ------------------------------------------------------------------

tsqlParser::Default_valueContext::Default_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Default_valueContext::NULL_() {
  return getToken(tsqlParser::NULL_, 0);
}

tsqlParser::ConstantContext* tsqlParser::Default_valueContext::constant() {
  return getRuleContext<tsqlParser::ConstantContext>(0);
}


size_t tsqlParser::Default_valueContext::getRuleIndex() const {
  return tsqlParser::RuleDefault_value;
}


antlrcpp::Any tsqlParser::Default_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitDefault_value(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Default_valueContext* tsqlParser::default_value() {
  Default_valueContext *_localctx = _tracker.createInstance<Default_valueContext>(_ctx, getState());
  enterRule(_localctx, 374, tsqlParser::RuleDefault_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3404);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::NULL_: {
        enterOuterAlt(_localctx, 1);
        setState(3402);
        match(tsqlParser::NULL_);
        break;
      }

      case tsqlParser::DECIMAL:
      case tsqlParser::STRING:
      case tsqlParser::BINARY:
      case tsqlParser::FLOAT:
      case tsqlParser::REAL:
      case tsqlParser::DOLLAR:
      case tsqlParser::PLUS:
      case tsqlParser::MINUS: {
        enterOuterAlt(_localctx, 2);
        setState(3403);
        constant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

tsqlParser::ConstantContext::ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::ConstantContext::STRING() {
  return getToken(tsqlParser::STRING, 0);
}

tree::TerminalNode* tsqlParser::ConstantContext::BINARY() {
  return getToken(tsqlParser::BINARY, 0);
}

tree::TerminalNode* tsqlParser::ConstantContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tsqlParser::SignContext* tsqlParser::ConstantContext::sign() {
  return getRuleContext<tsqlParser::SignContext>(0);
}

tree::TerminalNode* tsqlParser::ConstantContext::REAL() {
  return getToken(tsqlParser::REAL, 0);
}

tree::TerminalNode* tsqlParser::ConstantContext::FLOAT() {
  return getToken(tsqlParser::FLOAT, 0);
}

tree::TerminalNode* tsqlParser::ConstantContext::DOLLAR() {
  return getToken(tsqlParser::DOLLAR, 0);
}


size_t tsqlParser::ConstantContext::getRuleIndex() const {
  return tsqlParser::RuleConstant;
}


antlrcpp::Any tsqlParser::ConstantContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitConstant(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::ConstantContext* tsqlParser::constant() {
  ConstantContext *_localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
  enterRule(_localctx, 376, tsqlParser::RuleConstant);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3421);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 473, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3406);
      match(tsqlParser::STRING);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3407);
      match(tsqlParser::BINARY);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3409);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::PLUS

      || _la == tsqlParser::MINUS) {
        setState(3408);
        sign();
      }
      setState(3411);
      match(tsqlParser::DECIMAL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3413);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::PLUS

      || _la == tsqlParser::MINUS) {
        setState(3412);
        sign();
      }
      setState(3415);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::FLOAT

      || _la == tsqlParser::REAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3417);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::PLUS

      || _la == tsqlParser::MINUS) {
        setState(3416);
        sign();
      }
      setState(3419);
      dynamic_cast<ConstantContext *>(_localctx)->dollar = match(tsqlParser::DOLLAR);
      setState(3420);
      _la = _input->LA(1);
      if (!(_la == tsqlParser::DECIMAL

      || _la == tsqlParser::FLOAT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignContext ------------------------------------------------------------------

tsqlParser::SignContext::SignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::SignContext::PLUS() {
  return getToken(tsqlParser::PLUS, 0);
}

tree::TerminalNode* tsqlParser::SignContext::MINUS() {
  return getToken(tsqlParser::MINUS, 0);
}


size_t tsqlParser::SignContext::getRuleIndex() const {
  return tsqlParser::RuleSign;
}


antlrcpp::Any tsqlParser::SignContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSign(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::SignContext* tsqlParser::sign() {
  SignContext *_localctx = _tracker.createInstance<SignContext>(_ctx, getState());
  enterRule(_localctx, 378, tsqlParser::RuleSign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3423);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::PLUS

    || _la == tsqlParser::MINUS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- R_idContext ------------------------------------------------------------------

tsqlParser::R_idContext::R_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Simple_idContext* tsqlParser::R_idContext::simple_id() {
  return getRuleContext<tsqlParser::Simple_idContext>(0);
}

tree::TerminalNode* tsqlParser::R_idContext::DOUBLE_QUOTE_ID() {
  return getToken(tsqlParser::DOUBLE_QUOTE_ID, 0);
}

tree::TerminalNode* tsqlParser::R_idContext::SQUARE_BRACKET_ID() {
  return getToken(tsqlParser::SQUARE_BRACKET_ID, 0);
}


size_t tsqlParser::R_idContext::getRuleIndex() const {
  return tsqlParser::RuleR_id;
}


antlrcpp::Any tsqlParser::R_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitR_id(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::R_idContext* tsqlParser::r_id() {
  R_idContext *_localctx = _tracker.createInstance<R_idContext>(_ctx, getState());
  enterRule(_localctx, 380, tsqlParser::RuleR_id);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3428);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::FORCESEEK:
      case tsqlParser::NEXT:
      case tsqlParser::NUMERIC:
      case tsqlParser::VALUE:
      case tsqlParser::ABSOLUTE:
      case tsqlParser::APPLY:
      case tsqlParser::AUTO:
      case tsqlParser::AVG:
      case tsqlParser::BASE64:
      case tsqlParser::CALLER:
      case tsqlParser::CAST:
      case tsqlParser::CATCH:
      case tsqlParser::CHECKSUM_AGG:
      case tsqlParser::COMMITTED:
      case tsqlParser::CONCAT:
      case tsqlParser::CONTROL:
      case tsqlParser::COOKIE:
      case tsqlParser::COUNT:
      case tsqlParser::COUNT_BIG:
      case tsqlParser::DATE:
      case tsqlParser::DELAY:
      case tsqlParser::DELETED:
      case tsqlParser::DENSE_RANK:
      case tsqlParser::DISABLE:
      case tsqlParser::DYNAMIC:
      case tsqlParser::ENCRYPTION:
      case tsqlParser::EXIST:
      case tsqlParser::EXPAND:
      case tsqlParser::FAST:
      case tsqlParser::FAST_FORWARD:
      case tsqlParser::FIRST:
      case tsqlParser::FIRST_VALUE:
      case tsqlParser::FOLLOWING:
      case tsqlParser::FORCE:
      case tsqlParser::FORCED:
      case tsqlParser::FORWARD_ONLY:
      case tsqlParser::FULLSCAN:
      case tsqlParser::GLOBAL:
      case tsqlParser::GROUPING:
      case tsqlParser::GROUPING_ID:
      case tsqlParser::HASH:
      case tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case tsqlParser::IMPERSONATE:
      case tsqlParser::INSENSITIVE:
      case tsqlParser::INSERTED:
      case tsqlParser::ISOLATION:
      case tsqlParser::IO:
      case tsqlParser::KEEP:
      case tsqlParser::KEEPFIXED:
      case tsqlParser::KEYSET:
      case tsqlParser::LAG:
      case tsqlParser::LAST:
      case tsqlParser::LAST_VALUE:
      case tsqlParser::LEAD:
      case tsqlParser::LEVEL:
      case tsqlParser::LOCAL:
      case tsqlParser::LOCK_ESCALATION:
      case tsqlParser::LOGIN:
      case tsqlParser::LOOP:
      case tsqlParser::MARK:
      case tsqlParser::MAX:
      case tsqlParser::MAXDOP:
      case tsqlParser::MAXRECURSION:
      case tsqlParser::MIN:
      case tsqlParser::MODIFY:
      case tsqlParser::NAME:
      case tsqlParser::NOCOUNT:
      case tsqlParser::NODES:
      case tsqlParser::NOEXPAND:
      case tsqlParser::NORECOMPUTE:
      case tsqlParser::NTILE:
      case tsqlParser::NUMBER:
      case tsqlParser::OFFSET:
      case tsqlParser::ONLINE:
      case tsqlParser::ONLY:
      case tsqlParser::OPTIMISTIC:
      case tsqlParser::OPTIMIZE:
      case tsqlParser::OUT:
      case tsqlParser::OUTPUT:
      case tsqlParser::OWNER:
      case tsqlParser::PARAMETERIZATION:
      case tsqlParser::PARTITION:
      case tsqlParser::PATH:
      case tsqlParser::PRECEDING:
      case tsqlParser::PRIOR:
      case tsqlParser::PRIVILEGES:
      case tsqlParser::QUERY:
      case tsqlParser::RANGE:
      case tsqlParser::RANK:
      case tsqlParser::READONLY:
      case tsqlParser::READ_ONLY:
      case tsqlParser::RECOMPILE:
      case tsqlParser::RELATIVE:
      case tsqlParser::REMOTE:
      case tsqlParser::REPEATABLE:
      case tsqlParser::ROBUST:
      case tsqlParser::ROOT:
      case tsqlParser::ROW:
      case tsqlParser::ROWGUID:
      case tsqlParser::ROWS:
      case tsqlParser::ROW_NUMBER:
      case tsqlParser::SAMPLE:
      case tsqlParser::SCHEMABINDING:
      case tsqlParser::SCROLL:
      case tsqlParser::SCROLL_LOCKS:
      case tsqlParser::SELF:
      case tsqlParser::SERIALIZABLE:
      case tsqlParser::SIMPLE:
      case tsqlParser::SIZE:
      case tsqlParser::SNAPSHOT:
      case tsqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case tsqlParser::STATIC:
      case tsqlParser::STATS_STREAM:
      case tsqlParser::STDEV:
      case tsqlParser::STDEVP:
      case tsqlParser::SUM:
      case tsqlParser::TEXTIMAGE_ON:
      case tsqlParser::THROW:
      case tsqlParser::TIES:
      case tsqlParser::TIME:
      case tsqlParser::TRY:
      case tsqlParser::TYPE:
      case tsqlParser::TYPE_WARNING:
      case tsqlParser::UNBOUNDED:
      case tsqlParser::UNCOMMITTED:
      case tsqlParser::UNKNOWN:
      case tsqlParser::USING:
      case tsqlParser::VAR:
      case tsqlParser::VARP:
      case tsqlParser::VIEWS:
      case tsqlParser::VIEW_METADATA:
      case tsqlParser::WORK:
      case tsqlParser::XML:
      case tsqlParser::XMLNAMESPACES:
      case tsqlParser::ZONE:
      case tsqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3425);
        simple_id();
        break;
      }

      case tsqlParser::DOUBLE_QUOTE_ID: {
        enterOuterAlt(_localctx, 2);
        setState(3426);
        match(tsqlParser::DOUBLE_QUOTE_ID);
        break;
      }

      case tsqlParser::SQUARE_BRACKET_ID: {
        enterOuterAlt(_localctx, 3);
        setState(3427);
        match(tsqlParser::SQUARE_BRACKET_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_idContext ------------------------------------------------------------------

tsqlParser::Simple_idContext::Simple_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Simple_idContext::ID() {
  return getToken(tsqlParser::ID, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::IO() {
  return getToken(tsqlParser::IO, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::ABSOLUTE() {
  return getToken(tsqlParser::ABSOLUTE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::APPLY() {
  return getToken(tsqlParser::APPLY, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::AUTO() {
  return getToken(tsqlParser::AUTO, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::AVG() {
  return getToken(tsqlParser::AVG, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::BASE64() {
  return getToken(tsqlParser::BASE64, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::CALLER() {
  return getToken(tsqlParser::CALLER, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::CAST() {
  return getToken(tsqlParser::CAST, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::CATCH() {
  return getToken(tsqlParser::CATCH, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::CHECKSUM_AGG() {
  return getToken(tsqlParser::CHECKSUM_AGG, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::COMMITTED() {
  return getToken(tsqlParser::COMMITTED, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::CONCAT() {
  return getToken(tsqlParser::CONCAT, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::CONTROL() {
  return getToken(tsqlParser::CONTROL, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::COOKIE() {
  return getToken(tsqlParser::COOKIE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::COUNT() {
  return getToken(tsqlParser::COUNT, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::COUNT_BIG() {
  return getToken(tsqlParser::COUNT_BIG, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::DATE() {
  return getToken(tsqlParser::DATE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::DELAY() {
  return getToken(tsqlParser::DELAY, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::DELETED() {
  return getToken(tsqlParser::DELETED, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::DENSE_RANK() {
  return getToken(tsqlParser::DENSE_RANK, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::DISABLE() {
  return getToken(tsqlParser::DISABLE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::DYNAMIC() {
  return getToken(tsqlParser::DYNAMIC, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::ENCRYPTION() {
  return getToken(tsqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::EXIST() {
  return getToken(tsqlParser::EXIST, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::EXPAND() {
  return getToken(tsqlParser::EXPAND, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::FAST() {
  return getToken(tsqlParser::FAST, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::FAST_FORWARD() {
  return getToken(tsqlParser::FAST_FORWARD, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::FIRST() {
  return getToken(tsqlParser::FIRST, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::FIRST_VALUE() {
  return getToken(tsqlParser::FIRST_VALUE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::FOLLOWING() {
  return getToken(tsqlParser::FOLLOWING, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::FORCE() {
  return getToken(tsqlParser::FORCE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::FORCESEEK() {
  return getToken(tsqlParser::FORCESEEK, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::FORWARD_ONLY() {
  return getToken(tsqlParser::FORWARD_ONLY, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::FULLSCAN() {
  return getToken(tsqlParser::FULLSCAN, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::GLOBAL() {
  return getToken(tsqlParser::GLOBAL, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::GROUPING() {
  return getToken(tsqlParser::GROUPING, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::GROUPING_ID() {
  return getToken(tsqlParser::GROUPING_ID, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::HASH() {
  return getToken(tsqlParser::HASH, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::IMPERSONATE() {
  return getToken(tsqlParser::IMPERSONATE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::INSENSITIVE() {
  return getToken(tsqlParser::INSENSITIVE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::INSERTED() {
  return getToken(tsqlParser::INSERTED, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::ISOLATION() {
  return getToken(tsqlParser::ISOLATION, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::KEEP() {
  return getToken(tsqlParser::KEEP, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::KEEPFIXED() {
  return getToken(tsqlParser::KEEPFIXED, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::FORCED() {
  return getToken(tsqlParser::FORCED, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::KEYSET() {
  return getToken(tsqlParser::KEYSET, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX() {
  return getToken(tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::LAG() {
  return getToken(tsqlParser::LAG, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::LAST() {
  return getToken(tsqlParser::LAST, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::LAST_VALUE() {
  return getToken(tsqlParser::LAST_VALUE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::LEAD() {
  return getToken(tsqlParser::LEAD, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::LEVEL() {
  return getToken(tsqlParser::LEVEL, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::LOCAL() {
  return getToken(tsqlParser::LOCAL, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::LOCK_ESCALATION() {
  return getToken(tsqlParser::LOCK_ESCALATION, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::LOGIN() {
  return getToken(tsqlParser::LOGIN, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::LOOP() {
  return getToken(tsqlParser::LOOP, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::MARK() {
  return getToken(tsqlParser::MARK, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::MAX() {
  return getToken(tsqlParser::MAX, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::MAXDOP() {
  return getToken(tsqlParser::MAXDOP, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::MAXRECURSION() {
  return getToken(tsqlParser::MAXRECURSION, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::MIN() {
  return getToken(tsqlParser::MIN, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::MODIFY() {
  return getToken(tsqlParser::MODIFY, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::NAME() {
  return getToken(tsqlParser::NAME, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::NEXT() {
  return getToken(tsqlParser::NEXT, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::NOCOUNT() {
  return getToken(tsqlParser::NOCOUNT, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::NODES() {
  return getToken(tsqlParser::NODES, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::NOEXPAND() {
  return getToken(tsqlParser::NOEXPAND, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::NORECOMPUTE() {
  return getToken(tsqlParser::NORECOMPUTE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::NTILE() {
  return getToken(tsqlParser::NTILE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::NUMBER() {
  return getToken(tsqlParser::NUMBER, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::NUMERIC() {
  return getToken(tsqlParser::NUMERIC, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::OFFSET() {
  return getToken(tsqlParser::OFFSET, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::ONLINE() {
  return getToken(tsqlParser::ONLINE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::ONLY() {
  return getToken(tsqlParser::ONLY, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::OPTIMISTIC() {
  return getToken(tsqlParser::OPTIMISTIC, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::OPTIMIZE() {
  return getToken(tsqlParser::OPTIMIZE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::OUT() {
  return getToken(tsqlParser::OUT, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::OUTPUT() {
  return getToken(tsqlParser::OUTPUT, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::OWNER() {
  return getToken(tsqlParser::OWNER, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::PARAMETERIZATION() {
  return getToken(tsqlParser::PARAMETERIZATION, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::PARTITION() {
  return getToken(tsqlParser::PARTITION, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::PATH() {
  return getToken(tsqlParser::PATH, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::PRECEDING() {
  return getToken(tsqlParser::PRECEDING, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::PRIOR() {
  return getToken(tsqlParser::PRIOR, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::PRIVILEGES() {
  return getToken(tsqlParser::PRIVILEGES, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::QUERY() {
  return getToken(tsqlParser::QUERY, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::RANGE() {
  return getToken(tsqlParser::RANGE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::RANK() {
  return getToken(tsqlParser::RANK, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::READONLY() {
  return getToken(tsqlParser::READONLY, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::READ_ONLY() {
  return getToken(tsqlParser::READ_ONLY, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::RECOMPILE() {
  return getToken(tsqlParser::RECOMPILE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::RELATIVE() {
  return getToken(tsqlParser::RELATIVE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::REMOTE() {
  return getToken(tsqlParser::REMOTE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::REPEATABLE() {
  return getToken(tsqlParser::REPEATABLE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::ROBUST() {
  return getToken(tsqlParser::ROBUST, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::ROOT() {
  return getToken(tsqlParser::ROOT, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::ROW() {
  return getToken(tsqlParser::ROW, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::ROWGUID() {
  return getToken(tsqlParser::ROWGUID, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::ROWS() {
  return getToken(tsqlParser::ROWS, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::ROW_NUMBER() {
  return getToken(tsqlParser::ROW_NUMBER, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::SAMPLE() {
  return getToken(tsqlParser::SAMPLE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::SCHEMABINDING() {
  return getToken(tsqlParser::SCHEMABINDING, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::SCROLL() {
  return getToken(tsqlParser::SCROLL, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::SCROLL_LOCKS() {
  return getToken(tsqlParser::SCROLL_LOCKS, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::SELF() {
  return getToken(tsqlParser::SELF, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::SERIALIZABLE() {
  return getToken(tsqlParser::SERIALIZABLE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::SIMPLE() {
  return getToken(tsqlParser::SIMPLE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::SIZE() {
  return getToken(tsqlParser::SIZE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::SNAPSHOT() {
  return getToken(tsqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::SPATIAL_WINDOW_MAX_CELLS() {
  return getToken(tsqlParser::SPATIAL_WINDOW_MAX_CELLS, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::STATIC() {
  return getToken(tsqlParser::STATIC, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::STATS_STREAM() {
  return getToken(tsqlParser::STATS_STREAM, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::STDEV() {
  return getToken(tsqlParser::STDEV, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::STDEVP() {
  return getToken(tsqlParser::STDEVP, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::SUM() {
  return getToken(tsqlParser::SUM, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::TEXTIMAGE_ON() {
  return getToken(tsqlParser::TEXTIMAGE_ON, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::THROW() {
  return getToken(tsqlParser::THROW, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::TIES() {
  return getToken(tsqlParser::TIES, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::TIME() {
  return getToken(tsqlParser::TIME, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::TRY() {
  return getToken(tsqlParser::TRY, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::TYPE() {
  return getToken(tsqlParser::TYPE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::TYPE_WARNING() {
  return getToken(tsqlParser::TYPE_WARNING, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::UNBOUNDED() {
  return getToken(tsqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::UNCOMMITTED() {
  return getToken(tsqlParser::UNCOMMITTED, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::UNKNOWN() {
  return getToken(tsqlParser::UNKNOWN, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::USING() {
  return getToken(tsqlParser::USING, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::VAR() {
  return getToken(tsqlParser::VAR, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::VARP() {
  return getToken(tsqlParser::VARP, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::VALUE() {
  return getToken(tsqlParser::VALUE, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::VIEW_METADATA() {
  return getToken(tsqlParser::VIEW_METADATA, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::VIEWS() {
  return getToken(tsqlParser::VIEWS, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::WORK() {
  return getToken(tsqlParser::WORK, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::XML() {
  return getToken(tsqlParser::XML, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::XMLNAMESPACES() {
  return getToken(tsqlParser::XMLNAMESPACES, 0);
}

tree::TerminalNode* tsqlParser::Simple_idContext::ZONE() {
  return getToken(tsqlParser::ZONE, 0);
}


size_t tsqlParser::Simple_idContext::getRuleIndex() const {
  return tsqlParser::RuleSimple_id;
}


antlrcpp::Any tsqlParser::Simple_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitSimple_id(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Simple_idContext* tsqlParser::simple_id() {
  Simple_idContext *_localctx = _tracker.createInstance<Simple_idContext>(_ctx, getState());
  enterRule(_localctx, 382, tsqlParser::RuleSimple_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3430);
    _la = _input->LA(1);
    if (!(((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & ((1ULL << (tsqlParser::FORCESEEK - 73))
      | (1ULL << (tsqlParser::NEXT - 73))
      | (1ULL << (tsqlParser::NUMERIC - 73)))) != 0) || ((((_la - 196) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 196)) & ((1ULL << (tsqlParser::VALUE - 196))
      | (1ULL << (tsqlParser::ABSOLUTE - 196))
      | (1ULL << (tsqlParser::APPLY - 196))
      | (1ULL << (tsqlParser::AUTO - 196))
      | (1ULL << (tsqlParser::AVG - 196))
      | (1ULL << (tsqlParser::BASE64 - 196))
      | (1ULL << (tsqlParser::CALLER - 196))
      | (1ULL << (tsqlParser::CAST - 196))
      | (1ULL << (tsqlParser::CATCH - 196))
      | (1ULL << (tsqlParser::CHECKSUM_AGG - 196))
      | (1ULL << (tsqlParser::COMMITTED - 196))
      | (1ULL << (tsqlParser::CONCAT - 196))
      | (1ULL << (tsqlParser::CONTROL - 196))
      | (1ULL << (tsqlParser::COOKIE - 196))
      | (1ULL << (tsqlParser::COUNT - 196))
      | (1ULL << (tsqlParser::COUNT_BIG - 196))
      | (1ULL << (tsqlParser::DATE - 196)))) != 0) || ((((_la - 261) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 261)) & ((1ULL << (tsqlParser::DELAY - 261))
      | (1ULL << (tsqlParser::DELETED - 261))
      | (1ULL << (tsqlParser::DENSE_RANK - 261))
      | (1ULL << (tsqlParser::DISABLE - 261))
      | (1ULL << (tsqlParser::DYNAMIC - 261))
      | (1ULL << (tsqlParser::ENCRYPTION - 261))
      | (1ULL << (tsqlParser::EXIST - 261))
      | (1ULL << (tsqlParser::EXPAND - 261))
      | (1ULL << (tsqlParser::FAST - 261))
      | (1ULL << (tsqlParser::FAST_FORWARD - 261))
      | (1ULL << (tsqlParser::FIRST - 261))
      | (1ULL << (tsqlParser::FIRST_VALUE - 261))
      | (1ULL << (tsqlParser::FOLLOWING - 261))
      | (1ULL << (tsqlParser::FORCE - 261))
      | (1ULL << (tsqlParser::FORCED - 261))
      | (1ULL << (tsqlParser::FORWARD_ONLY - 261))
      | (1ULL << (tsqlParser::FULLSCAN - 261))
      | (1ULL << (tsqlParser::GLOBAL - 261))
      | (1ULL << (tsqlParser::GROUPING - 261))
      | (1ULL << (tsqlParser::GROUPING_ID - 261))
      | (1ULL << (tsqlParser::HASH - 261))
      | (1ULL << (tsqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 261))
      | (1ULL << (tsqlParser::IMPERSONATE - 261))
      | (1ULL << (tsqlParser::INSENSITIVE - 261))
      | (1ULL << (tsqlParser::INSERTED - 261))
      | (1ULL << (tsqlParser::ISOLATION - 261))
      | (1ULL << (tsqlParser::IO - 261))
      | (1ULL << (tsqlParser::KEEP - 261))
      | (1ULL << (tsqlParser::KEEPFIXED - 261))
      | (1ULL << (tsqlParser::KEYSET - 261))
      | (1ULL << (tsqlParser::LAG - 261))
      | (1ULL << (tsqlParser::LAST - 261))
      | (1ULL << (tsqlParser::LAST_VALUE - 261))
      | (1ULL << (tsqlParser::LEAD - 261))
      | (1ULL << (tsqlParser::LEVEL - 261))
      | (1ULL << (tsqlParser::LOCAL - 261))
      | (1ULL << (tsqlParser::LOCK_ESCALATION - 261))
      | (1ULL << (tsqlParser::LOGIN - 261))
      | (1ULL << (tsqlParser::LOOP - 261))
      | (1ULL << (tsqlParser::MARK - 261))
      | (1ULL << (tsqlParser::MAX - 261))
      | (1ULL << (tsqlParser::MAXDOP - 261))
      | (1ULL << (tsqlParser::MAXRECURSION - 261)))) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 328)) & ((1ULL << (tsqlParser::MIN - 328))
      | (1ULL << (tsqlParser::MODIFY - 328))
      | (1ULL << (tsqlParser::NAME - 328))
      | (1ULL << (tsqlParser::NOCOUNT - 328))
      | (1ULL << (tsqlParser::NODES - 328))
      | (1ULL << (tsqlParser::NOEXPAND - 328))
      | (1ULL << (tsqlParser::NORECOMPUTE - 328))
      | (1ULL << (tsqlParser::NTILE - 328))
      | (1ULL << (tsqlParser::NUMBER - 328))
      | (1ULL << (tsqlParser::OFFSET - 328))
      | (1ULL << (tsqlParser::ONLINE - 328))
      | (1ULL << (tsqlParser::ONLY - 328))
      | (1ULL << (tsqlParser::OPTIMISTIC - 328))
      | (1ULL << (tsqlParser::OPTIMIZE - 328))
      | (1ULL << (tsqlParser::OUT - 328))
      | (1ULL << (tsqlParser::OUTPUT - 328))
      | (1ULL << (tsqlParser::OWNER - 328))
      | (1ULL << (tsqlParser::PARAMETERIZATION - 328))
      | (1ULL << (tsqlParser::PARTITION - 328))
      | (1ULL << (tsqlParser::PATH - 328))
      | (1ULL << (tsqlParser::PRECEDING - 328))
      | (1ULL << (tsqlParser::PRIOR - 328))
      | (1ULL << (tsqlParser::PRIVILEGES - 328))
      | (1ULL << (tsqlParser::QUERY - 328))
      | (1ULL << (tsqlParser::RANGE - 328))
      | (1ULL << (tsqlParser::RANK - 328))
      | (1ULL << (tsqlParser::READONLY - 328))
      | (1ULL << (tsqlParser::READ_ONLY - 328))
      | (1ULL << (tsqlParser::RECOMPILE - 328))
      | (1ULL << (tsqlParser::RELATIVE - 328))
      | (1ULL << (tsqlParser::REMOTE - 328))
      | (1ULL << (tsqlParser::REPEATABLE - 328))
      | (1ULL << (tsqlParser::ROBUST - 328))
      | (1ULL << (tsqlParser::ROOT - 328))
      | (1ULL << (tsqlParser::ROW - 328))
      | (1ULL << (tsqlParser::ROWGUID - 328))
      | (1ULL << (tsqlParser::ROWS - 328))
      | (1ULL << (tsqlParser::ROW_NUMBER - 328))
      | (1ULL << (tsqlParser::SAMPLE - 328))
      | (1ULL << (tsqlParser::SCHEMABINDING - 328))
      | (1ULL << (tsqlParser::SCROLL - 328))
      | (1ULL << (tsqlParser::SCROLL_LOCKS - 328)))) != 0) || ((((_la - 393) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 393)) & ((1ULL << (tsqlParser::SELF - 393))
      | (1ULL << (tsqlParser::SERIALIZABLE - 393))
      | (1ULL << (tsqlParser::SIMPLE - 393))
      | (1ULL << (tsqlParser::SIZE - 393))
      | (1ULL << (tsqlParser::SNAPSHOT - 393))
      | (1ULL << (tsqlParser::SPATIAL_WINDOW_MAX_CELLS - 393))
      | (1ULL << (tsqlParser::STATIC - 393))
      | (1ULL << (tsqlParser::STATS_STREAM - 393))
      | (1ULL << (tsqlParser::STDEV - 393))
      | (1ULL << (tsqlParser::STDEVP - 393))
      | (1ULL << (tsqlParser::SUM - 393))
      | (1ULL << (tsqlParser::TEXTIMAGE_ON - 393))
      | (1ULL << (tsqlParser::THROW - 393))
      | (1ULL << (tsqlParser::TIES - 393))
      | (1ULL << (tsqlParser::TIME - 393))
      | (1ULL << (tsqlParser::TRY - 393))
      | (1ULL << (tsqlParser::TYPE - 393))
      | (1ULL << (tsqlParser::TYPE_WARNING - 393))
      | (1ULL << (tsqlParser::UNBOUNDED - 393))
      | (1ULL << (tsqlParser::UNCOMMITTED - 393))
      | (1ULL << (tsqlParser::UNKNOWN - 393))
      | (1ULL << (tsqlParser::USING - 393))
      | (1ULL << (tsqlParser::VAR - 393))
      | (1ULL << (tsqlParser::VARP - 393))
      | (1ULL << (tsqlParser::VIEWS - 393))
      | (1ULL << (tsqlParser::VIEW_METADATA - 393))
      | (1ULL << (tsqlParser::WORK - 393))
      | (1ULL << (tsqlParser::XML - 393))
      | (1ULL << (tsqlParser::XMLNAMESPACES - 393))
      | (1ULL << (tsqlParser::ZONE - 393))
      | (1ULL << (tsqlParser::ID - 393)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comparison_operatorContext ------------------------------------------------------------------

tsqlParser::Comparison_operatorContext::Comparison_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Comparison_operatorContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tree::TerminalNode* tsqlParser::Comparison_operatorContext::GREATER() {
  return getToken(tsqlParser::GREATER, 0);
}

tree::TerminalNode* tsqlParser::Comparison_operatorContext::LESS() {
  return getToken(tsqlParser::LESS, 0);
}

tree::TerminalNode* tsqlParser::Comparison_operatorContext::EXCLAMATION() {
  return getToken(tsqlParser::EXCLAMATION, 0);
}


size_t tsqlParser::Comparison_operatorContext::getRuleIndex() const {
  return tsqlParser::RuleComparison_operator;
}


antlrcpp::Any tsqlParser::Comparison_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitComparison_operator(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Comparison_operatorContext* tsqlParser::comparison_operator() {
  Comparison_operatorContext *_localctx = _tracker.createInstance<Comparison_operatorContext>(_ctx, getState());
  enterRule(_localctx, 384, tsqlParser::RuleComparison_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3447);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 475, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3432);
      match(tsqlParser::EQUAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3433);
      match(tsqlParser::GREATER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3434);
      match(tsqlParser::LESS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3435);
      match(tsqlParser::LESS);
      setState(3436);
      match(tsqlParser::EQUAL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3437);
      match(tsqlParser::GREATER);
      setState(3438);
      match(tsqlParser::EQUAL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3439);
      match(tsqlParser::LESS);
      setState(3440);
      match(tsqlParser::GREATER);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3441);
      match(tsqlParser::EXCLAMATION);
      setState(3442);
      match(tsqlParser::EQUAL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3443);
      match(tsqlParser::EXCLAMATION);
      setState(3444);
      match(tsqlParser::GREATER);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3445);
      match(tsqlParser::EXCLAMATION);
      setState(3446);
      match(tsqlParser::LESS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_operatorContext ------------------------------------------------------------------

tsqlParser::Assignment_operatorContext::Assignment_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Assignment_operatorContext::PLUS_ASSIGN() {
  return getToken(tsqlParser::PLUS_ASSIGN, 0);
}

tree::TerminalNode* tsqlParser::Assignment_operatorContext::MINUS_ASSIGN() {
  return getToken(tsqlParser::MINUS_ASSIGN, 0);
}

tree::TerminalNode* tsqlParser::Assignment_operatorContext::MULT_ASSIGN() {
  return getToken(tsqlParser::MULT_ASSIGN, 0);
}

tree::TerminalNode* tsqlParser::Assignment_operatorContext::DIV_ASSIGN() {
  return getToken(tsqlParser::DIV_ASSIGN, 0);
}

tree::TerminalNode* tsqlParser::Assignment_operatorContext::MOD_ASSIGN() {
  return getToken(tsqlParser::MOD_ASSIGN, 0);
}

tree::TerminalNode* tsqlParser::Assignment_operatorContext::AND_ASSIGN() {
  return getToken(tsqlParser::AND_ASSIGN, 0);
}

tree::TerminalNode* tsqlParser::Assignment_operatorContext::XOR_ASSIGN() {
  return getToken(tsqlParser::XOR_ASSIGN, 0);
}

tree::TerminalNode* tsqlParser::Assignment_operatorContext::OR_ASSIGN() {
  return getToken(tsqlParser::OR_ASSIGN, 0);
}


size_t tsqlParser::Assignment_operatorContext::getRuleIndex() const {
  return tsqlParser::RuleAssignment_operator;
}


antlrcpp::Any tsqlParser::Assignment_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitAssignment_operator(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Assignment_operatorContext* tsqlParser::assignment_operator() {
  Assignment_operatorContext *_localctx = _tracker.createInstance<Assignment_operatorContext>(_ctx, getState());
  enterRule(_localctx, 386, tsqlParser::RuleAssignment_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3449);
    _la = _input->LA(1);
    if (!(((((_la - 459) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 459)) & ((1ULL << (tsqlParser::PLUS_ASSIGN - 459))
      | (1ULL << (tsqlParser::MINUS_ASSIGN - 459))
      | (1ULL << (tsqlParser::MULT_ASSIGN - 459))
      | (1ULL << (tsqlParser::DIV_ASSIGN - 459))
      | (1ULL << (tsqlParser::MOD_ASSIGN - 459))
      | (1ULL << (tsqlParser::AND_ASSIGN - 459))
      | (1ULL << (tsqlParser::XOR_ASSIGN - 459))
      | (1ULL << (tsqlParser::OR_ASSIGN - 459)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_sizeContext ------------------------------------------------------------------

tsqlParser::File_sizeContext::File_sizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::File_sizeContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

tree::TerminalNode* tsqlParser::File_sizeContext::KB() {
  return getToken(tsqlParser::KB, 0);
}

tree::TerminalNode* tsqlParser::File_sizeContext::MB() {
  return getToken(tsqlParser::MB, 0);
}

tree::TerminalNode* tsqlParser::File_sizeContext::GB() {
  return getToken(tsqlParser::GB, 0);
}

tree::TerminalNode* tsqlParser::File_sizeContext::TB() {
  return getToken(tsqlParser::TB, 0);
}

tree::TerminalNode* tsqlParser::File_sizeContext::MODULE() {
  return getToken(tsqlParser::MODULE, 0);
}


size_t tsqlParser::File_sizeContext::getRuleIndex() const {
  return tsqlParser::RuleFile_size;
}


antlrcpp::Any tsqlParser::File_sizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFile_size(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::File_sizeContext* tsqlParser::file_size() {
  File_sizeContext *_localctx = _tracker.createInstance<File_sizeContext>(_ctx, getState());
  enterRule(_localctx, 388, tsqlParser::RuleFile_size);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3451);
    match(tsqlParser::DECIMAL);
    setState(3453);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 289) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 289)) & ((1ULL << (tsqlParser::GB - 289))
      | (1ULL << (tsqlParser::KB - 289))
      | (1ULL << (tsqlParser::MB - 289)))) != 0) || _la == tsqlParser::TB

    || _la == tsqlParser::MODULE) {
      setState(3452);
      _la = _input->LA(1);
      if (!(((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & ((1ULL << (tsqlParser::GB - 289))
        | (1ULL << (tsqlParser::KB - 289))
        | (1ULL << (tsqlParser::MB - 289)))) != 0) || _la == tsqlParser::TB

      || _la == tsqlParser::MODULE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_or_alter_procedureContext ------------------------------------------------------------------

tsqlParser::Create_or_alter_procedureContext::Create_or_alter_procedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::Func_proc_nameContext* tsqlParser::Create_or_alter_procedureContext::func_proc_name() {
  return getRuleContext<tsqlParser::Func_proc_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

tsqlParser::Sql_clausesContext* tsqlParser::Create_or_alter_procedureContext::sql_clauses() {
  return getRuleContext<tsqlParser::Sql_clausesContext>(0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::ALTER() {
  return getToken(tsqlParser::ALTER, 0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::PROC() {
  return getToken(tsqlParser::PROC, 0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::PROCEDURE() {
  return getToken(tsqlParser::PROCEDURE, 0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::DECIMAL() {
  return getToken(tsqlParser::DECIMAL, 0);
}

std::vector<tsqlParser::Procedure_paramContext *> tsqlParser::Create_or_alter_procedureContext::procedure_param() {
  return getRuleContexts<tsqlParser::Procedure_paramContext>();
}

tsqlParser::Procedure_paramContext* tsqlParser::Create_or_alter_procedureContext::procedure_param(size_t i) {
  return getRuleContext<tsqlParser::Procedure_paramContext>(i);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

std::vector<tsqlParser::Procedure_optionContext *> tsqlParser::Create_or_alter_procedureContext::procedure_option() {
  return getRuleContexts<tsqlParser::Procedure_optionContext>();
}

tsqlParser::Procedure_optionContext* tsqlParser::Create_or_alter_procedureContext::procedure_option(size_t i) {
  return getRuleContext<tsqlParser::Procedure_optionContext>(i);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::FOR() {
  return getToken(tsqlParser::FOR, 0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::REPLICATION() {
  return getToken(tsqlParser::REPLICATION, 0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::CREATE() {
  return getToken(tsqlParser::CREATE, 0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_or_alter_procedureContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_procedureContext::OR() {
  return getToken(tsqlParser::OR, 0);
}


size_t tsqlParser::Create_or_alter_procedureContext::getRuleIndex() const {
  return tsqlParser::RuleCreate_or_alter_procedure;
}


antlrcpp::Any tsqlParser::Create_or_alter_procedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_or_alter_procedure(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Create_or_alter_procedureContext* tsqlParser::create_or_alter_procedure() {
  Create_or_alter_procedureContext *_localctx = _tracker.createInstance<Create_or_alter_procedureContext>(_ctx, getState());
  enterRule(_localctx, 390, tsqlParser::RuleCreate_or_alter_procedure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3461);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::CREATE: {
        setState(3455);
        match(tsqlParser::CREATE);
        setState(3458);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::OR) {
          setState(3456);
          match(tsqlParser::OR);
          setState(3457);
          match(tsqlParser::ALTER);
        }
        break;
      }

      case tsqlParser::ALTER: {
        setState(3460);
        match(tsqlParser::ALTER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3463);
    dynamic_cast<Create_or_alter_procedureContext *>(_localctx)->proc = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == tsqlParser::PROC

    || _la == tsqlParser::PROCEDURE)) {
      dynamic_cast<Create_or_alter_procedureContext *>(_localctx)->proc = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3464);
    func_proc_name();
    setState(3467);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::SEMI) {
      setState(3465);
      match(tsqlParser::SEMI);
      setState(3466);
      match(tsqlParser::DECIMAL);
    }
    setState(3483);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::LOCAL_ID

    || _la == tsqlParser::LR_BRACKET) {
      setState(3470);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::LR_BRACKET) {
        setState(3469);
        match(tsqlParser::LR_BRACKET);
      }
      setState(3472);
      procedure_param();
      setState(3477);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(3473);
        match(tsqlParser::COMMA);
        setState(3474);
        procedure_param();
        setState(3479);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3481);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::RR_BRACKET) {
        setState(3480);
        match(tsqlParser::RR_BRACKET);
      }
    }
    setState(3494);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WITH) {
      setState(3485);
      match(tsqlParser::WITH);
      setState(3486);
      procedure_option();
      setState(3491);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(3487);
        match(tsqlParser::COMMA);
        setState(3488);
        procedure_option();
        setState(3493);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(3498);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::FOR) {
      setState(3496);
      match(tsqlParser::FOR);
      setState(3497);
      match(tsqlParser::REPLICATION);
    }
    setState(3500);
    match(tsqlParser::AS);
    setState(3501);
    sql_clauses();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_or_alter_functionContext ------------------------------------------------------------------

tsqlParser::Create_or_alter_functionContext::Create_or_alter_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Create_or_alter_functionContext::FUNCTION() {
  return getToken(tsqlParser::FUNCTION, 0);
}

tsqlParser::Func_proc_nameContext* tsqlParser::Create_or_alter_functionContext::func_proc_name() {
  return getRuleContext<tsqlParser::Func_proc_nameContext>(0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_functionContext::ALTER() {
  return getToken(tsqlParser::ALTER, 0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_functionContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_functionContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tsqlParser::Func_body_returns_selectContext* tsqlParser::Create_or_alter_functionContext::func_body_returns_select() {
  return getRuleContext<tsqlParser::Func_body_returns_selectContext>(0);
}

tsqlParser::Func_body_returns_tableContext* tsqlParser::Create_or_alter_functionContext::func_body_returns_table() {
  return getRuleContext<tsqlParser::Func_body_returns_tableContext>(0);
}

tsqlParser::Func_body_returns_scalarContext* tsqlParser::Create_or_alter_functionContext::func_body_returns_scalar() {
  return getRuleContext<tsqlParser::Func_body_returns_scalarContext>(0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_functionContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

tree::TerminalNode* tsqlParser::Create_or_alter_functionContext::CREATE() {
  return getToken(tsqlParser::CREATE, 0);
}

std::vector<tsqlParser::Procedure_paramContext *> tsqlParser::Create_or_alter_functionContext::procedure_param() {
  return getRuleContexts<tsqlParser::Procedure_paramContext>();
}

tsqlParser::Procedure_paramContext* tsqlParser::Create_or_alter_functionContext::procedure_param(size_t i) {
  return getRuleContext<tsqlParser::Procedure_paramContext>(i);
}

tree::TerminalNode* tsqlParser::Create_or_alter_functionContext::OR() {
  return getToken(tsqlParser::OR, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Create_or_alter_functionContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Create_or_alter_functionContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Create_or_alter_functionContext::getRuleIndex() const {
  return tsqlParser::RuleCreate_or_alter_function;
}


antlrcpp::Any tsqlParser::Create_or_alter_functionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_or_alter_function(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Create_or_alter_functionContext* tsqlParser::create_or_alter_function() {
  Create_or_alter_functionContext *_localctx = _tracker.createInstance<Create_or_alter_functionContext>(_ctx, getState());
  enterRule(_localctx, 392, tsqlParser::RuleCreate_or_alter_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3509);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::CREATE: {
        setState(3503);
        match(tsqlParser::CREATE);
        setState(3506);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::OR) {
          setState(3504);
          match(tsqlParser::OR);
          setState(3505);
          match(tsqlParser::ALTER);
        }
        break;
      }

      case tsqlParser::ALTER: {
        setState(3508);
        match(tsqlParser::ALTER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3511);
    match(tsqlParser::FUNCTION);
    setState(3512);
    func_proc_name();
    setState(3526);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 490, _ctx)) {
    case 1: {
      setState(3513);
      match(tsqlParser::LR_BRACKET);
      setState(3514);
      procedure_param();
      setState(3519);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(3515);
        match(tsqlParser::COMMA);
        setState(3516);
        procedure_param();
        setState(3521);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3522);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(3524);
      match(tsqlParser::LR_BRACKET);
      setState(3525);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(3531);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 491, _ctx)) {
    case 1: {
      setState(3528);
      func_body_returns_select();
      break;
    }

    case 2: {
      setState(3529);
      func_body_returns_table();
      break;
    }

    case 3: {
      setState(3530);
      func_body_returns_scalar();
      break;
    }

    default:
      break;
    }
    setState(3534);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 492, _ctx)) {
    case 1: {
      setState(3533);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_body_returns_selectContext ------------------------------------------------------------------

tsqlParser::Func_body_returns_selectContext::Func_body_returns_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Func_body_returns_selectContext::RETURNS() {
  return getToken(tsqlParser::RETURNS, 0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_selectContext::TABLE() {
  return getToken(tsqlParser::TABLE, 0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_selectContext::RETURN() {
  return getToken(tsqlParser::RETURN, 0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_selectContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tsqlParser::Select_statementContext* tsqlParser::Func_body_returns_selectContext::select_statement() {
  return getRuleContext<tsqlParser::Select_statementContext>(0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_selectContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_selectContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

std::vector<tsqlParser::Function_optionContext *> tsqlParser::Func_body_returns_selectContext::function_option() {
  return getRuleContexts<tsqlParser::Function_optionContext>();
}

tsqlParser::Function_optionContext* tsqlParser::Func_body_returns_selectContext::function_option(size_t i) {
  return getRuleContext<tsqlParser::Function_optionContext>(i);
}

tree::TerminalNode* tsqlParser::Func_body_returns_selectContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Func_body_returns_selectContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Func_body_returns_selectContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Func_body_returns_selectContext::getRuleIndex() const {
  return tsqlParser::RuleFunc_body_returns_select;
}


antlrcpp::Any tsqlParser::Func_body_returns_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFunc_body_returns_select(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Func_body_returns_selectContext* tsqlParser::func_body_returns_select() {
  Func_body_returns_selectContext *_localctx = _tracker.createInstance<Func_body_returns_selectContext>(_ctx, getState());
  enterRule(_localctx, 394, tsqlParser::RuleFunc_body_returns_select);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3536);
    match(tsqlParser::RETURNS);
    setState(3537);
    match(tsqlParser::TABLE);
    setState(3547);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WITH) {
      setState(3538);
      match(tsqlParser::WITH);
      setState(3539);
      function_option();
      setState(3544);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(3540);
        match(tsqlParser::COMMA);
        setState(3541);
        function_option();
        setState(3546);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(3550);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::AS) {
      setState(3549);
      match(tsqlParser::AS);
    }
    setState(3552);
    match(tsqlParser::RETURN);
    setState(3558);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 496, _ctx)) {
    case 1: {
      setState(3553);
      match(tsqlParser::LR_BRACKET);
      setState(3554);
      select_statement();
      setState(3555);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(3557);
      select_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_body_returns_tableContext ------------------------------------------------------------------

tsqlParser::Func_body_returns_tableContext::Func_body_returns_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Func_body_returns_tableContext::RETURNS() {
  return getToken(tsqlParser::RETURNS, 0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_tableContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tsqlParser::Table_type_definitionContext* tsqlParser::Func_body_returns_tableContext::table_type_definition() {
  return getRuleContext<tsqlParser::Table_type_definitionContext>(0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_tableContext::BEGIN() {
  return getToken(tsqlParser::BEGIN, 0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_tableContext::RETURN() {
  return getToken(tsqlParser::RETURN, 0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_tableContext::END() {
  return getToken(tsqlParser::END, 0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_tableContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

std::vector<tsqlParser::Function_optionContext *> tsqlParser::Func_body_returns_tableContext::function_option() {
  return getRuleContexts<tsqlParser::Function_optionContext>();
}

tsqlParser::Function_optionContext* tsqlParser::Func_body_returns_tableContext::function_option(size_t i) {
  return getRuleContext<tsqlParser::Function_optionContext>(i);
}

tree::TerminalNode* tsqlParser::Func_body_returns_tableContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

std::vector<tsqlParser::Sql_clauseContext *> tsqlParser::Func_body_returns_tableContext::sql_clause() {
  return getRuleContexts<tsqlParser::Sql_clauseContext>();
}

tsqlParser::Sql_clauseContext* tsqlParser::Func_body_returns_tableContext::sql_clause(size_t i) {
  return getRuleContext<tsqlParser::Sql_clauseContext>(i);
}

std::vector<tree::TerminalNode *> tsqlParser::Func_body_returns_tableContext::SEMI() {
  return getTokens(tsqlParser::SEMI);
}

tree::TerminalNode* tsqlParser::Func_body_returns_tableContext::SEMI(size_t i) {
  return getToken(tsqlParser::SEMI, i);
}

std::vector<tree::TerminalNode *> tsqlParser::Func_body_returns_tableContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Func_body_returns_tableContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Func_body_returns_tableContext::getRuleIndex() const {
  return tsqlParser::RuleFunc_body_returns_table;
}


antlrcpp::Any tsqlParser::Func_body_returns_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFunc_body_returns_table(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Func_body_returns_tableContext* tsqlParser::func_body_returns_table() {
  Func_body_returns_tableContext *_localctx = _tracker.createInstance<Func_body_returns_tableContext>(_ctx, getState());
  enterRule(_localctx, 396, tsqlParser::RuleFunc_body_returns_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3560);
    match(tsqlParser::RETURNS);
    setState(3561);
    match(tsqlParser::LOCAL_ID);
    setState(3562);
    table_type_definition();
    setState(3572);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WITH) {
      setState(3563);
      match(tsqlParser::WITH);
      setState(3564);
      function_option();
      setState(3569);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(3565);
        match(tsqlParser::COMMA);
        setState(3566);
        function_option();
        setState(3571);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(3575);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::AS) {
      setState(3574);
      match(tsqlParser::AS);
    }
    setState(3577);
    match(tsqlParser::BEGIN);
    setState(3581);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 500, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3578);
        sql_clause(); 
      }
      setState(3583);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 500, _ctx);
    }
    setState(3584);
    match(tsqlParser::RETURN);
    setState(3586);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::SEMI) {
      setState(3585);
      match(tsqlParser::SEMI);
    }
    setState(3588);
    match(tsqlParser::END);
    setState(3590);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 502, _ctx)) {
    case 1: {
      setState(3589);
      match(tsqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_body_returns_scalarContext ------------------------------------------------------------------

tsqlParser::Func_body_returns_scalarContext::Func_body_returns_scalarContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Func_body_returns_scalarContext::RETURNS() {
  return getToken(tsqlParser::RETURNS, 0);
}

tsqlParser::Data_typeContext* tsqlParser::Func_body_returns_scalarContext::data_type() {
  return getRuleContext<tsqlParser::Data_typeContext>(0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_scalarContext::BEGIN() {
  return getToken(tsqlParser::BEGIN, 0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_scalarContext::RETURN() {
  return getToken(tsqlParser::RETURN, 0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_scalarContext::END() {
  return getToken(tsqlParser::END, 0);
}

tsqlParser::ExpressionContext* tsqlParser::Func_body_returns_scalarContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

tree::TerminalNode* tsqlParser::Func_body_returns_scalarContext::WITH() {
  return getToken(tsqlParser::WITH, 0);
}

std::vector<tsqlParser::Function_optionContext *> tsqlParser::Func_body_returns_scalarContext::function_option() {
  return getRuleContexts<tsqlParser::Function_optionContext>();
}

tsqlParser::Function_optionContext* tsqlParser::Func_body_returns_scalarContext::function_option(size_t i) {
  return getRuleContext<tsqlParser::Function_optionContext>(i);
}

tree::TerminalNode* tsqlParser::Func_body_returns_scalarContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

std::vector<tsqlParser::Sql_clauseContext *> tsqlParser::Func_body_returns_scalarContext::sql_clause() {
  return getRuleContexts<tsqlParser::Sql_clauseContext>();
}

tsqlParser::Sql_clauseContext* tsqlParser::Func_body_returns_scalarContext::sql_clause(size_t i) {
  return getRuleContext<tsqlParser::Sql_clauseContext>(i);
}

tree::TerminalNode* tsqlParser::Func_body_returns_scalarContext::SEMI() {
  return getToken(tsqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Func_body_returns_scalarContext::COMMA() {
  return getTokens(tsqlParser::COMMA);
}

tree::TerminalNode* tsqlParser::Func_body_returns_scalarContext::COMMA(size_t i) {
  return getToken(tsqlParser::COMMA, i);
}


size_t tsqlParser::Func_body_returns_scalarContext::getRuleIndex() const {
  return tsqlParser::RuleFunc_body_returns_scalar;
}


antlrcpp::Any tsqlParser::Func_body_returns_scalarContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFunc_body_returns_scalar(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Func_body_returns_scalarContext* tsqlParser::func_body_returns_scalar() {
  Func_body_returns_scalarContext *_localctx = _tracker.createInstance<Func_body_returns_scalarContext>(_ctx, getState());
  enterRule(_localctx, 398, tsqlParser::RuleFunc_body_returns_scalar);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3592);
    match(tsqlParser::RETURNS);
    setState(3593);
    data_type();
    setState(3603);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::WITH) {
      setState(3594);
      match(tsqlParser::WITH);
      setState(3595);
      function_option();
      setState(3600);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == tsqlParser::COMMA) {
        setState(3596);
        match(tsqlParser::COMMA);
        setState(3597);
        function_option();
        setState(3602);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(3606);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::AS) {
      setState(3605);
      match(tsqlParser::AS);
    }
    setState(3608);
    match(tsqlParser::BEGIN);
    setState(3612);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 506, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3609);
        sql_clause(); 
      }
      setState(3614);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 506, _ctx);
    }
    setState(3615);
    match(tsqlParser::RETURN);
    setState(3616);
    dynamic_cast<Func_body_returns_scalarContext *>(_localctx)->ret = expression(0);
    setState(3618);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::SEMI) {
      setState(3617);
      match(tsqlParser::SEMI);
    }
    setState(3620);
    match(tsqlParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedure_paramContext ------------------------------------------------------------------

tsqlParser::Procedure_paramContext::Procedure_paramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Procedure_paramContext::LOCAL_ID() {
  return getToken(tsqlParser::LOCAL_ID, 0);
}

tsqlParser::Data_typeContext* tsqlParser::Procedure_paramContext::data_type() {
  return getRuleContext<tsqlParser::Data_typeContext>(0);
}

tsqlParser::R_idContext* tsqlParser::Procedure_paramContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Procedure_paramContext::DOT() {
  return getToken(tsqlParser::DOT, 0);
}

tree::TerminalNode* tsqlParser::Procedure_paramContext::AS() {
  return getToken(tsqlParser::AS, 0);
}

tree::TerminalNode* tsqlParser::Procedure_paramContext::VARYING() {
  return getToken(tsqlParser::VARYING, 0);
}

tree::TerminalNode* tsqlParser::Procedure_paramContext::EQUAL() {
  return getToken(tsqlParser::EQUAL, 0);
}

tsqlParser::Default_valueContext* tsqlParser::Procedure_paramContext::default_value() {
  return getRuleContext<tsqlParser::Default_valueContext>(0);
}

tree::TerminalNode* tsqlParser::Procedure_paramContext::OUT() {
  return getToken(tsqlParser::OUT, 0);
}

tree::TerminalNode* tsqlParser::Procedure_paramContext::OUTPUT() {
  return getToken(tsqlParser::OUTPUT, 0);
}

tree::TerminalNode* tsqlParser::Procedure_paramContext::READONLY() {
  return getToken(tsqlParser::READONLY, 0);
}


size_t tsqlParser::Procedure_paramContext::getRuleIndex() const {
  return tsqlParser::RuleProcedure_param;
}


antlrcpp::Any tsqlParser::Procedure_paramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitProcedure_param(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Procedure_paramContext* tsqlParser::procedure_param() {
  Procedure_paramContext *_localctx = _tracker.createInstance<Procedure_paramContext>(_ctx, getState());
  enterRule(_localctx, 400, tsqlParser::RuleProcedure_param);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3622);
    match(tsqlParser::LOCAL_ID);
    setState(3626);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 508, _ctx)) {
    case 1: {
      setState(3623);
      r_id();
      setState(3624);
      match(tsqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3629);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::AS) {
      setState(3628);
      match(tsqlParser::AS);
    }
    setState(3631);
    data_type();
    setState(3633);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::VARYING) {
      setState(3632);
      match(tsqlParser::VARYING);
    }
    setState(3637);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == tsqlParser::EQUAL) {
      setState(3635);
      match(tsqlParser::EQUAL);
      setState(3636);
      dynamic_cast<Procedure_paramContext *>(_localctx)->default_val = default_value();
    }
    setState(3640);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 352) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 352)) & ((1ULL << (tsqlParser::OUT - 352))
      | (1ULL << (tsqlParser::OUTPUT - 352))
      | (1ULL << (tsqlParser::READONLY - 352)))) != 0)) {
      setState(3639);
      _la = _input->LA(1);
      if (!(((((_la - 352) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 352)) & ((1ULL << (tsqlParser::OUT - 352))
        | (1ULL << (tsqlParser::OUTPUT - 352))
        | (1ULL << (tsqlParser::READONLY - 352)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedure_optionContext ------------------------------------------------------------------

tsqlParser::Procedure_optionContext::Procedure_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Procedure_optionContext::ENCRYPTION() {
  return getToken(tsqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* tsqlParser::Procedure_optionContext::RECOMPILE() {
  return getToken(tsqlParser::RECOMPILE, 0);
}

tsqlParser::Execute_clauseContext* tsqlParser::Procedure_optionContext::execute_clause() {
  return getRuleContext<tsqlParser::Execute_clauseContext>(0);
}


size_t tsqlParser::Procedure_optionContext::getRuleIndex() const {
  return tsqlParser::RuleProcedure_option;
}


antlrcpp::Any tsqlParser::Procedure_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitProcedure_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Procedure_optionContext* tsqlParser::procedure_option() {
  Procedure_optionContext *_localctx = _tracker.createInstance<Procedure_optionContext>(_ctx, getState());
  enterRule(_localctx, 402, tsqlParser::RuleProcedure_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3645);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::ENCRYPTION: {
        enterOuterAlt(_localctx, 1);
        setState(3642);
        match(tsqlParser::ENCRYPTION);
        break;
      }

      case tsqlParser::RECOMPILE: {
        enterOuterAlt(_localctx, 2);
        setState(3643);
        match(tsqlParser::RECOMPILE);
        break;
      }

      case tsqlParser::EXECUTE: {
        enterOuterAlt(_localctx, 3);
        setState(3644);
        execute_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_optionContext ------------------------------------------------------------------

tsqlParser::Function_optionContext::Function_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Function_optionContext::ENCRYPTION() {
  return getToken(tsqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* tsqlParser::Function_optionContext::SCHEMABINDING() {
  return getToken(tsqlParser::SCHEMABINDING, 0);
}

tree::TerminalNode* tsqlParser::Function_optionContext::RETURNS() {
  return getToken(tsqlParser::RETURNS, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Function_optionContext::NULL_() {
  return getTokens(tsqlParser::NULL_);
}

tree::TerminalNode* tsqlParser::Function_optionContext::NULL_(size_t i) {
  return getToken(tsqlParser::NULL_, i);
}

tree::TerminalNode* tsqlParser::Function_optionContext::ON() {
  return getToken(tsqlParser::ON, 0);
}

tree::TerminalNode* tsqlParser::Function_optionContext::INPUT() {
  return getToken(tsqlParser::INPUT, 0);
}

tree::TerminalNode* tsqlParser::Function_optionContext::CALLED() {
  return getToken(tsqlParser::CALLED, 0);
}

tsqlParser::Execute_clauseContext* tsqlParser::Function_optionContext::execute_clause() {
  return getRuleContext<tsqlParser::Execute_clauseContext>(0);
}


size_t tsqlParser::Function_optionContext::getRuleIndex() const {
  return tsqlParser::RuleFunction_option;
}


antlrcpp::Any tsqlParser::Function_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitFunction_option(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Function_optionContext* tsqlParser::function_option() {
  Function_optionContext *_localctx = _tracker.createInstance<Function_optionContext>(_ctx, getState());
  enterRule(_localctx, 404, tsqlParser::RuleFunction_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3659);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case tsqlParser::ENCRYPTION: {
        enterOuterAlt(_localctx, 1);
        setState(3647);
        match(tsqlParser::ENCRYPTION);
        break;
      }

      case tsqlParser::SCHEMABINDING: {
        enterOuterAlt(_localctx, 2);
        setState(3648);
        match(tsqlParser::SCHEMABINDING);
        break;
      }

      case tsqlParser::RETURNS: {
        enterOuterAlt(_localctx, 3);
        setState(3649);
        match(tsqlParser::RETURNS);
        setState(3650);
        match(tsqlParser::NULL_);
        setState(3651);
        match(tsqlParser::ON);
        setState(3652);
        match(tsqlParser::NULL_);
        setState(3653);
        match(tsqlParser::INPUT);
        break;
      }

      case tsqlParser::CALLED: {
        enterOuterAlt(_localctx, 4);
        setState(3654);
        match(tsqlParser::CALLED);
        setState(3655);
        match(tsqlParser::ON);
        setState(3656);
        match(tsqlParser::NULL_);
        setState(3657);
        match(tsqlParser::INPUT);
        break;
      }

      case tsqlParser::EXECUTE: {
        enterOuterAlt(_localctx, 5);
        setState(3658);
        execute_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Percentile_contContext ------------------------------------------------------------------

tsqlParser::Percentile_contContext::Percentile_contContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::Percentile_contContext::PERCENTILE_CONT() {
  return getToken(tsqlParser::PERCENTILE_CONT, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Percentile_contContext::LR_BRACKET() {
  return getTokens(tsqlParser::LR_BRACKET);
}

tree::TerminalNode* tsqlParser::Percentile_contContext::LR_BRACKET(size_t i) {
  return getToken(tsqlParser::LR_BRACKET, i);
}

tsqlParser::ExpressionContext* tsqlParser::Percentile_contContext::expression() {
  return getRuleContext<tsqlParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> tsqlParser::Percentile_contContext::RR_BRACKET() {
  return getTokens(tsqlParser::RR_BRACKET);
}

tree::TerminalNode* tsqlParser::Percentile_contContext::RR_BRACKET(size_t i) {
  return getToken(tsqlParser::RR_BRACKET, i);
}

tree::TerminalNode* tsqlParser::Percentile_contContext::WITHIN() {
  return getToken(tsqlParser::WITHIN, 0);
}

tree::TerminalNode* tsqlParser::Percentile_contContext::GROUP() {
  return getToken(tsqlParser::GROUP, 0);
}

tsqlParser::Order_by_clauseContext* tsqlParser::Percentile_contContext::order_by_clause() {
  return getRuleContext<tsqlParser::Order_by_clauseContext>(0);
}

tsqlParser::Over_clauseContext* tsqlParser::Percentile_contContext::over_clause() {
  return getRuleContext<tsqlParser::Over_clauseContext>(0);
}


size_t tsqlParser::Percentile_contContext::getRuleIndex() const {
  return tsqlParser::RulePercentile_cont;
}


antlrcpp::Any tsqlParser::Percentile_contContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitPercentile_cont(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Percentile_contContext* tsqlParser::percentile_cont() {
  Percentile_contContext *_localctx = _tracker.createInstance<Percentile_contContext>(_ctx, getState());
  enterRule(_localctx, 406, tsqlParser::RulePercentile_cont);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3661);
    match(tsqlParser::PERCENTILE_CONT);
    setState(3662);
    match(tsqlParser::LR_BRACKET);
    setState(3663);
    expression(0);
    setState(3664);
    match(tsqlParser::RR_BRACKET);
    setState(3665);
    match(tsqlParser::WITHIN);
    setState(3666);
    match(tsqlParser::GROUP);
    setState(3667);
    match(tsqlParser::LR_BRACKET);
    setState(3668);
    order_by_clause();
    setState(3669);
    match(tsqlParser::RR_BRACKET);
    setState(3670);
    over_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- String_aggContext ------------------------------------------------------------------

tsqlParser::String_aggContext::String_aggContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* tsqlParser::String_aggContext::STRING_AGG() {
  return getToken(tsqlParser::STRING_AGG, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::String_aggContext::LR_BRACKET() {
  return getTokens(tsqlParser::LR_BRACKET);
}

tree::TerminalNode* tsqlParser::String_aggContext::LR_BRACKET(size_t i) {
  return getToken(tsqlParser::LR_BRACKET, i);
}

std::vector<tsqlParser::ExpressionContext *> tsqlParser::String_aggContext::expression() {
  return getRuleContexts<tsqlParser::ExpressionContext>();
}

tsqlParser::ExpressionContext* tsqlParser::String_aggContext::expression(size_t i) {
  return getRuleContext<tsqlParser::ExpressionContext>(i);
}

tree::TerminalNode* tsqlParser::String_aggContext::COMMA() {
  return getToken(tsqlParser::COMMA, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::String_aggContext::RR_BRACKET() {
  return getTokens(tsqlParser::RR_BRACKET);
}

tree::TerminalNode* tsqlParser::String_aggContext::RR_BRACKET(size_t i) {
  return getToken(tsqlParser::RR_BRACKET, i);
}

tree::TerminalNode* tsqlParser::String_aggContext::WITHIN() {
  return getToken(tsqlParser::WITHIN, 0);
}

tree::TerminalNode* tsqlParser::String_aggContext::GROUP() {
  return getToken(tsqlParser::GROUP, 0);
}

tsqlParser::Order_by_clauseContext* tsqlParser::String_aggContext::order_by_clause() {
  return getRuleContext<tsqlParser::Order_by_clauseContext>(0);
}


size_t tsqlParser::String_aggContext::getRuleIndex() const {
  return tsqlParser::RuleString_agg;
}


antlrcpp::Any tsqlParser::String_aggContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitString_agg(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::String_aggContext* tsqlParser::string_agg() {
  String_aggContext *_localctx = _tracker.createInstance<String_aggContext>(_ctx, getState());
  enterRule(_localctx, 408, tsqlParser::RuleString_agg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3672);
    match(tsqlParser::STRING_AGG);
    setState(3673);
    match(tsqlParser::LR_BRACKET);
    setState(3674);
    expression(0);
    setState(3675);
    match(tsqlParser::COMMA);
    setState(3676);
    expression(0);
    setState(3677);
    match(tsqlParser::RR_BRACKET);
    setState(3678);
    match(tsqlParser::WITHIN);
    setState(3679);
    match(tsqlParser::GROUP);
    setState(3680);
    match(tsqlParser::LR_BRACKET);
    setState(3681);
    order_by_clause();
    setState(3682);
    match(tsqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_typeContext ------------------------------------------------------------------

tsqlParser::Data_typeContext::Data_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tsqlParser::R_idContext* tsqlParser::Data_typeContext::r_id() {
  return getRuleContext<tsqlParser::R_idContext>(0);
}

tree::TerminalNode* tsqlParser::Data_typeContext::IDENTITY() {
  return getToken(tsqlParser::IDENTITY, 0);
}

tree::TerminalNode* tsqlParser::Data_typeContext::LR_BRACKET() {
  return getToken(tsqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* tsqlParser::Data_typeContext::RR_BRACKET() {
  return getToken(tsqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> tsqlParser::Data_typeContext::DECIMAL() {
  return getTokens(tsqlParser::DECIMAL);
}

tree::TerminalNode* tsqlParser::Data_typeContext::DECIMAL(size_t i) {
  return getToken(tsqlParser::DECIMAL, i);
}

tree::TerminalNode* tsqlParser::Data_typeContext::MAX() {
  return getToken(tsqlParser::MAX, 0);
}

tree::TerminalNode* tsqlParser::Data_typeContext::COMMA() {
  return getToken(tsqlParser::COMMA, 0);
}

tree::TerminalNode* tsqlParser::Data_typeContext::DATE() {
  return getToken(tsqlParser::DATE, 0);
}

tree::TerminalNode* tsqlParser::Data_typeContext::DATETIME2() {
  return getToken(tsqlParser::DATETIME2, 0);
}

tree::TerminalNode* tsqlParser::Data_typeContext::DOUBLE() {
  return getToken(tsqlParser::DOUBLE, 0);
}

tree::TerminalNode* tsqlParser::Data_typeContext::PRECISION() {
  return getToken(tsqlParser::PRECISION, 0);
}

tree::TerminalNode* tsqlParser::Data_typeContext::INT() {
  return getToken(tsqlParser::INT, 0);
}

tree::TerminalNode* tsqlParser::Data_typeContext::TINYINT() {
  return getToken(tsqlParser::TINYINT, 0);
}

tree::TerminalNode* tsqlParser::Data_typeContext::SMALLINT() {
  return getToken(tsqlParser::SMALLINT, 0);
}

tree::TerminalNode* tsqlParser::Data_typeContext::BIGINT() {
  return getToken(tsqlParser::BIGINT, 0);
}


size_t tsqlParser::Data_typeContext::getRuleIndex() const {
  return tsqlParser::RuleData_type;
}


antlrcpp::Any tsqlParser::Data_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<tsqlVisitor*>(visitor))
    return parserVisitor->visitData_type(this);
  else
    return visitor->visitChildren(this);
}

tsqlParser::Data_typeContext* tsqlParser::data_type() {
  Data_typeContext *_localctx = _tracker.createInstance<Data_typeContext>(_ctx, getState());
  enterRule(_localctx, 410, tsqlParser::RuleData_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3710);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 519, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3684);
      r_id();
      setState(3686);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 515, _ctx)) {
      case 1: {
        setState(3685);
        match(tsqlParser::IDENTITY);
        break;
      }

      default:
        break;
      }
      setState(3695);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 517, _ctx)) {
      case 1: {
        setState(3688);
        match(tsqlParser::LR_BRACKET);
        setState(3689);
        _la = _input->LA(1);
        if (!(_la == tsqlParser::MAX || _la == tsqlParser::DECIMAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3692);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == tsqlParser::COMMA) {
          setState(3690);
          match(tsqlParser::COMMA);
          setState(3691);
          match(tsqlParser::DECIMAL);
        }
        setState(3694);
        match(tsqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3697);
      match(tsqlParser::DATE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3698);
      match(tsqlParser::DATETIME2);
      setState(3699);
      match(tsqlParser::LR_BRACKET);
      setState(3700);
      match(tsqlParser::DECIMAL);
      setState(3701);
      match(tsqlParser::RR_BRACKET);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3702);
      match(tsqlParser::DOUBLE);
      setState(3704);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == tsqlParser::PRECISION) {
        setState(3703);
        match(tsqlParser::PRECISION);
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3706);
      match(tsqlParser::INT);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3707);
      match(tsqlParser::TINYINT);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3708);
      match(tsqlParser::SMALLINT);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3709);
      match(tsqlParser::BIGINT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool tsqlParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 103: return expressionSempred(dynamic_cast<ExpressionContext *>(context), predicateIndex);
    case 112: return search_conditionSempred(dynamic_cast<Search_conditionContext *>(context), predicateIndex);
    case 114: return query_expressionSempred(dynamic_cast<Query_expressionContext *>(context), predicateIndex);
    case 134: return table_sourceSempred(dynamic_cast<Table_sourceContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool tsqlParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 15);
    case 1: return precpred(_ctx, 8);
    case 2: return precpred(_ctx, 6);
    case 3: return precpred(_ctx, 5);
    case 4: return precpred(_ctx, 16);
    case 5: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool tsqlParser::search_conditionSempred(Search_conditionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return precpred(_ctx, 3);
    case 7: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool tsqlParser::query_expressionSempred(Query_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 8: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool tsqlParser::table_sourceSempred(Table_sourceContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 9: return precpred(_ctx, 3);
    case 10: return precpred(_ctx, 2);
    case 11: return precpred(_ctx, 4);

  default:
    break;
  }
  return true;
}

// Static vars and initialization.
std::vector<dfa::DFA> tsqlParser::_decisionToDFA;
atn::PredictionContextCache tsqlParser::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN tsqlParser::_atn;
std::vector<uint16_t> tsqlParser::_serializedATN;

std::vector<std::string> tsqlParser::_ruleNames = {
  "tsql_file", "batch", "sql_clauses", "sql_clause", "dml_clause", "ddl_clause", 
  "cfl_statement", "cfl_clause", "block_statement", "break_statement", "continue_statement", 
  "goto_statement", "if_statement", "if_block", "return_statement", "throw_statement", 
  "try_catch_statement", "waitfor_statement", "while_statement", "print_statement", 
  "raiseerror_statement", "another_statement", "delete_statement", "delete_statement_from", 
  "insert_statement", "insert_statement_value", "select_statement", "update_statement", 
  "where_clause_dml", "output_clause", "output_dml_list_elem", "output_column_name", 
  "create_database", "create_index", "create_statistics", "create_table", 
  "create_schema", "create_synonym", "create_view", "view_attribute", "alter_table", 
  "alter_database", "database_optionspec", "auto_option", "change_tracking_option", 
  "change_tracking_option_list", "containment_option", "cursor_option", 
  "date_correlation_optimization_option", "db_encryption_option", "db_state_option", 
  "db_update_option", "db_user_access_option", "delayed_durability_option", 
  "external_access_option", "hadr_options", "mixed_page_allocation_option", 
  "parameterization_option", "recovery_option", "service_broker_option", 
  "snapshot_option", "sql_option", "target_recovery_time_option", "termination", 
  "drop_index", "drop_procedure", "drop_statistics", "drop_table", "drop_database", 
  "drop_synonym", "drop_view", "drop_schema", "create_type", "drop_type", 
  "rowset_function_limited", "openquery", "opendatasource", "declare_statement", 
  "cursor_statement", "execute_statement", "execute_statement_arg", "execute_var_string", 
  "security_statement", "grant_permission", "set_statement", "transaction_statement", 
  "go_statement", "use_statement", "execute_clause", "declare_local", "table_type_definition", 
  "column_def_table_constraints", "column_def_table_constraint", "column_definition", 
  "column_constraint", "table_constraint", "index_options", "index_option", 
  "declare_cursor", "declare_set_cursor_common", "fetch_cursor", "set_special", 
  "constant_LOCAL_ID", "expression", "xml_method_call", "simple_xml_method_name", 
  "constant_expression", "subquery", "with_expression", "common_table_expression", 
  "update_elem", "search_condition_list", "search_condition", "predicate", 
  "query_expression", "union_op", "cross_apply_expression", "query_specification", 
  "group_by_grouping_sets", "grouping_set", "top_clause", "top_clause_dm", 
  "order_by_clause", "fetch_expression", "for_clause", "xml_common_directives", 
  "order_by_expression", "group_by_item", "option_clause", "option", "optimize_for_arg", 
  "select_list", "select_list_elem", "table_sources", "table_source", "table_source_item", 
  "tablesample_clause", "sample_number", "repeat_seed", "table_alias", "change_table", 
  "join_type", "table_name_with_hint", "rowset_function", "bulk_option", 
  "derived_table", "function_call", "switch_section", "switch_search_condition_section", 
  "with_table_hints", "insert_with_table_hints", "table_hint", "index_value", 
  "column_alias_list", "column_alias", "a_star", "table_value_constructor", 
  "expression_list", "value_list", "next_value_for", "next_value_for_function", 
  "ranking_windowed_function", "aggregate_windowed_function", "all_distinct", 
  "over_clause", "row_or_range_clause", "window_frame_extent", "window_frame_bound", 
  "window_frame_preceding", "window_frame_following", "create_database_option", 
  "database_filestream_option", "database_file_spec", "file_group", "file_spec", 
  "full_table_name", "table_name", "simple_name", "func_proc_name", "ddl_object", 
  "full_column_name", "column_name_list", "cursor_name", "on_off", "clustered", 
  "null_notnull", "scalar_function_name", "default_value", "constant", "sign", 
  "r_id", "simple_id", "comparison_operator", "assignment_operator", "file_size", 
  "create_or_alter_procedure", "create_or_alter_function", "func_body_returns_select", 
  "func_body_returns_table", "func_body_returns_scalar", "procedure_param", 
  "procedure_option", "function_option", "percentile_cont", "string_agg", 
  "data_type"
};

std::vector<std::string> tsqlParser::_literalNames = {
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "'='", "'>'", "'<'", "'!'", "'+='", "'-='", "'*='", 
  "'/='", "'%='", "'&='", "'^='", "'|='", "'.'", "'_'", "'@'", "'#'", "'$'", 
  "'('", "')'", "','", "';'", "':'", "'*'", "'/'", "'%'", "'+'", "'-'", 
  "'~'", "'|'", "'&'", "'^'"
};

std::vector<std::string> tsqlParser::_symbolicNames = {
  "", "ADD", "ALL", "ALTER", "AND", "ANY", "AS", "ASC", "AUTHORIZATION", 
  "BACKUP", "BEGIN", "BETWEEN", "BREAK", "BROWSE", "BULK", "BY", "CALLED", 
  "CASCADE", "CASE", "CHANGETABLE", "CHANGES", "CHECK", "CHECKPOINT", "CLOSE", 
  "CLUSTERED", "COALESCE", "COLLATE", "COLUMN", "COMMIT", "COMPUTE", "CONSTRAINT", 
  "CONTAINMENT", "CONTAINS", "CONTAINSTABLE", "CONTINUE", "CONVERT", "CREATE", 
  "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", 
  "CURRENT_USER", "CURSOR", "DATABASE", "DBCC", "DEALLOCATE", "DECLARE", 
  "DEFAULT", "DELETE", "DENY", "DESC", "DISK", "DISTINCT", "DISTRIBUTED", 
  "DOUBLE", "DROP", "DUMP", "ELSE", "END", "ERRLVL", "ESCAPE", "EXCEPT", 
  "EXECUTE", "EXISTS", "EXIT", "EXP", "EXTERNAL", "FETCH", "FILE", "FILENAME", 
  "FILLFACTOR", "FOR", "FORCESEEK", "FOREIGN", "FREETEXT", "FREETEXTTABLE", 
  "FROM", "FULL", "FUNCTION", "GOTO", "GRANT", "GROUP", "HAVING", "IDENTITY", 
  "IDENTITYCOL", "IDENTITY_INSERT", "IIF", "IF", "IN", "INDEX", "INCLUDE", 
  "INNER", "INSERT", "INTERSECT", "INTO", "IS", "JOIN", "KEY", "KILL", "LEFT", 
  "LIKE", "LINENO", "LOAD", "LOG", "LOG10", "MERGE", "NATIONAL", "NEXT", 
  "NOCHECK", "NONCLUSTERED", "NONE", "NOT", "NULL_", "NULLIF", "NUMERIC", 
  "OF", "OFF", "OFFSETS", "ON", "OPEN", "OPENDATASOURCE", "OPENQUERY", "OPENROWSET", 
  "OPENXML", "OPTION", "OR", "ORDER", "OUTER", "OVER", "PARTIAL", "PERCENT", 
  "PIVOT", "PLAN", "PRECISION", "PRIMARY", "PRINT", "PROC", "PROCEDURE", 
  "PUBLIC", "RAISERROR", "READ", "READTEXT", "RECONFIGURE", "REFERENCES", 
  "REPLICATION", "RESTORE", "RESTRICT", "RETURN", "RETURNS", "REVERT", "REVOKE", 
  "RIGHT", "ROLLBACK", "ROWCOUNT", "ROWGUIDCOL", "RULE", "SAVE", "SCHEMA", 
  "SECURITYAUDIT", "SELECT", "SEMANTICKEYPHRASETABLE", "SEMANTICSIMILARITYDETAILSTABLE", 
  "SEMANTICSIMILARITYTABLE", "SESSION_USER", "SET", "SETUSER", "SHUTDOWN", 
  "SIGN", "SOME", "STATISTICS", "SYNONYM", "SYSTEM", "SYSTEM_USER", "TABLE", 
  "TABLESAMPLE", "TEXTSIZE", "THEN", "TO", "TOP", "TRAN", "TRANSACTION", 
  "TRIGGER", "TRUNCATE", "TRY_CAST", "TRY_CONVERT", "TRY_PARSE", "TSEQUAL", 
  "UNION", "UNIQUE", "UNPIVOT", "UPDATE", "UPDATETEXT", "USE", "USER", "VALUES", 
  "VALUE", "VARYING", "VIEW", "WAITFOR", "WHEN", "WHERE", "WHILE", "WITH", 
  "WITHIN", "WRITETEXT", "ABSOLUTE", "AFTER", "ALLOWED", "ALLOW_SNAPSHOT_ISOLATION", 
  "ANSI_NULLS", "ANSI_NULL_DEFAULT", "ANSI_PADDING", "ANSI_WARNINGS", "APPLY", 
  "ARITHABORT", "AT", "AUTO", "AUTO_CLEANUP", "AUTO_CLOSE", "AUTO_CREATE_STATISTICS", 
  "AUTO_SHRINK", "AUTO_UPDATE_STATISTICS", "AUTO_UPDATE_STATISTICS_ASYNC", 
  "AVG", "BASE64", "BIGINT", "BINARY_CHECKSUM", "BULK_LOGGED", "CALLER", 
  "CAST", "CATCH", "CEILING", "CHANGE_RETENTION", "CHANGE_TRACKING", "CHECKSUM", 
  "CHECKSUM_AGG", "COMMITTED", "COMPATIBILITY_LEVEL", "CONCAT", "CONCAT_NULL_YIELDS_NULL", 
  "CONTROL", "COOKIE", "COS", "COUNT", "COUNT_BIG", "CUBE", "CURSOR_CLOSE_ON_COMMIT", 
  "CURSOR_DEFAULT", "DATE", "DATEADD", "DATEDIFF", "DATENAME", "DATEPART", 
  "DATETIME2", "DATETIMEOFFSETFROMPARTS", "DATE_CORRELATION_OPTIMIZATION", 
  "DAYS", "DB_CHAINING", "DEFAULT_FULLTEXT_LANGUAGE", "DEFAULT_LANGUAGE", 
  "DELAY", "DELAYED_DURABILITY", "DELETED", "DENSE_RANK", "DIRECTORY_NAME", 
  "DISABLE", "DISABLED", "DISABLE_BROKER", "DYNAMIC", "EMERGENCY", "ENABLE_BROKER", 
  "ENCRYPTION", "ERROR_BROKER_CONVERSATIONS", "EXIST", "EXPAND", "FAST", 
  "FAST_FORWARD", "FILEGROUP", "FILEGROWTH", "FILESTREAM", "FIRST", "FIRST_VALUE", 
  "FLOOR", "FOLLOWING", "FORCE", "FORCED", "FORWARD_ONLY", "FULLSCAN", "GB", 
  "GLOBAL", "GO", "GROUPING", "GROUPING_ID", "HADR", "HASH", "HONOR_BROKER_PRIORITY", 
  "HOURS", "IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX", "IMMEDIATE", "IMPERSONATE", 
  "INCREMENTAL", "INPUT", "INT", "INSENSITIVE", "INSERTED", "ISOLATION", 
  "IO", "KB", "KEEP", "KEEPFIXED", "KEYSET", "LAG", "LAST", "LAST_VALUE", 
  "LEAD", "LEVEL", "LOCAL", "LOCK_ESCALATION", "LOGIN", "LOOP", "MARK", 
  "MAX", "MAXDOP", "MAXRECURSION", "MAXSIZE", "MB", "MEMORY_OPTIMIZED_DATA", 
  "MIN", "MINUTES", "MIN_ACTIVE_ROWVERSION", "MIXED_PAGE_ALLOCATION", "MODIFY", 
  "MULTI_USER", "NAME", "NESTED_TRIGGERS", "NEW_BROKER", "NOCOUNT", "NODES", 
  "NOEXPAND", "NON_TRANSACTED_ACCESS", "NORECOMPUTE", "NO_WAIT", "NTILE", 
  "NUMBER", "NUMERIC_ROUNDABORT", "OFFLINE", "OFFSET", "ONLINE", "ONLY", 
  "OPTIMISTIC", "OPTIMIZE", "OUT", "OUTPUT", "OWNER", "PAGE_VERIFY", "PARAMETERIZATION", 
  "PARSE", "PARTITION", "PATH", "PERCENTILE_CONT", "POWER", "PRECEDING", 
  "PRIOR", "PRIVILEGES", "QUERY", "QUOTED_IDENTIFIER", "RANGE", "RANK", 
  "READONLY", "READ_COMMITTED_SNAPSHOT", "READ_ONLY", "READ_WRITE", "RECOMPILE", 
  "RECOVERY", "RECURSIVE_TRIGGERS", "RELATIVE", "REMOTE", "REPEATABLE", 
  "RESTRICTED_USER", "ROBUST", "ROLLUP", "ROOT", "ROUND", "ROW", "ROWGUID", 
  "ROWS", "ROW_NUMBER", "SAMPLE", "SCHEMABINDING", "SCROLL", "SCROLL_LOCKS", 
  "SECONDS", "SELF", "SERIALIZABLE", "SETS", "SHOWPLAN", "SIMPLE", "SIN", 
  "SINGLE_USER", "SIZE", "SMALLINT", "SNAPSHOT", "SPATIAL_WINDOW_MAX_CELLS", 
  "STATIC", "STATS_STREAM", "STDEV", "STDEVP", "STRING_AGG", "STRING_SPLIT", 
  "SUM", "SQRT", "SQUARE", "TAKE", "TAN", "TARGET_RECOVERY_TIME", "TB", 
  "TEXTIMAGE_ON", "THROW", "TIES", "TIME", "TINYINT", "TORN_PAGE_DETECTION", 
  "TRANSFORM_NOISE_WORDS", "TRUSTWORTHY", "TRY", "TWO_DIGIT_YEAR_CUTOFF", 
  "TYPE", "TYPE_WARNING", "UNBOUNDED", "UNCOMMITTED", "UNKNOWN", "UNLIMITED", 
  "USING", "VAR", "VARP", "VIEWS", "VIEW_METADATA", "WORK", "XML", "XMLNAMESPACES", 
  "ZONE", "DOLLAR_ACTION", "SPACE", "COMMENT", "LINE_COMMENT", "DOUBLE_QUOTE_ID", 
  "SQUARE_BRACKET_ID", "LOCAL_ID", "DECIMAL", "ID", "STRING", "BINARY", 
  "FLOAT", "REAL", "EQUAL", "GREATER", "LESS", "EXCLAMATION", "PLUS_ASSIGN", 
  "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", 
  "XOR_ASSIGN", "OR_ASSIGN", "DOT", "UNDERLINE", "AT_SIGN", "SHARP", "DOLLAR", 
  "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "COLON", "STAR", "DIVIDE", 
  "MODULE", "PLUS", "MINUS", "BIT_NOT", "BIT_OR", "BIT_AND", "BIT_XOR"
};

dfa::Vocabulary tsqlParser::_vocabulary(_literalNames, _symbolicNames);

std::vector<std::string> tsqlParser::_tokenNames;

tsqlParser::Initializer::Initializer() {
	for (size_t i = 0; i < _symbolicNames.size(); ++i) {
		std::string name = _vocabulary.getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back("<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}

  static const uint16_t serializedATNSegment0[] = {
    0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, 
       0x3, 0x1e7, 0xe83, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, 0x4, 0x4, 
       0x9, 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, 0x9, 
       0x7, 0x4, 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 0xa, 
       0x4, 0xb, 0x9, 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 0x4, 
       0xe, 0x9, 0xe, 0x4, 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 0x11, 
       0x9, 0x11, 0x4, 0x12, 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 0x14, 
       0x9, 0x14, 0x4, 0x15, 0x9, 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 0x17, 
       0x9, 0x17, 0x4, 0x18, 0x9, 0x18, 0x4, 0x19, 0x9, 0x19, 0x4, 0x1a, 
       0x9, 0x1a, 0x4, 0x1b, 0x9, 0x1b, 0x4, 0x1c, 0x9, 0x1c, 0x4, 0x1d, 
       0x9, 0x1d, 0x4, 0x1e, 0x9, 0x1e, 0x4, 0x1f, 0x9, 0x1f, 0x4, 0x20, 
       0x9, 0x20, 0x4, 0x21, 0x9, 0x21, 0x4, 0x22, 0x9, 0x22, 0x4, 0x23, 
       0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, 0x25, 0x9, 0x25, 0x4, 0x26, 
       0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, 0x9, 0x28, 0x4, 0x29, 
       0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, 0x2b, 0x4, 0x2c, 
       0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, 0x4, 0x2f, 
       0x9, 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, 0x32, 
       0x9, 0x32, 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 0x35, 
       0x9, 0x35, 0x4, 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 0x38, 
       0x9, 0x38, 0x4, 0x39, 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 0x3b, 
       0x9, 0x3b, 0x4, 0x3c, 0x9, 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 0x3e, 
       0x9, 0x3e, 0x4, 0x3f, 0x9, 0x3f, 0x4, 0x40, 0x9, 0x40, 0x4, 0x41, 
       0x9, 0x41, 0x4, 0x42, 0x9, 0x42, 0x4, 0x43, 0x9, 0x43, 0x4, 0x44, 
       0x9, 0x44, 0x4, 0x45, 0x9, 0x45, 0x4, 0x46, 0x9, 0x46, 0x4, 0x47, 
       0x9, 0x47, 0x4, 0x48, 0x9, 0x48, 0x4, 0x49, 0x9, 0x49, 0x4, 0x4a, 
       0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, 0x4c, 0x9, 0x4c, 0x4, 0x4d, 
       0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, 0x9, 0x4f, 0x4, 0x50, 
       0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, 0x52, 0x4, 0x53, 
       0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, 0x4, 0x56, 
       0x9, 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, 0x59, 
       0x9, 0x59, 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 0x5c, 
       0x9, 0x5c, 0x4, 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 0x5f, 
       0x9, 0x5f, 0x4, 0x60, 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 0x62, 
       0x9, 0x62, 0x4, 0x63, 0x9, 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 0x65, 
       0x9, 0x65, 0x4, 0x66, 0x9, 0x66, 0x4, 0x67, 0x9, 0x67, 0x4, 0x68, 
       0x9, 0x68, 0x4, 0x69, 0x9, 0x69, 0x4, 0x6a, 0x9, 0x6a, 0x4, 0x6b, 
       0x9, 0x6b, 0x4, 0x6c, 0x9, 0x6c, 0x4, 0x6d, 0x9, 0x6d, 0x4, 0x6e, 
       0x9, 0x6e, 0x4, 0x6f, 0x9, 0x6f, 0x4, 0x70, 0x9, 0x70, 0x4, 0x71, 
       0x9, 0x71, 0x4, 0x72, 0x9, 0x72, 0x4, 0x73, 0x9, 0x73, 0x4, 0x74, 
       0x9, 0x74, 0x4, 0x75, 0x9, 0x75, 0x4, 0x76, 0x9, 0x76, 0x4, 0x77, 
       0x9, 0x77, 0x4, 0x78, 0x9, 0x78, 0x4, 0x79, 0x9, 0x79, 0x4, 0x7a, 
       0x9, 0x7a, 0x4, 0x7b, 0x9, 0x7b, 0x4, 0x7c, 0x9, 0x7c, 0x4, 0x7d, 
       0x9, 0x7d, 0x4, 0x7e, 0x9, 0x7e, 0x4, 0x7f, 0x9, 0x7f, 0x4, 0x80, 
       0x9, 0x80, 0x4, 0x81, 0x9, 0x81, 0x4, 0x82, 0x9, 0x82, 0x4, 0x83, 
       0x9, 0x83, 0x4, 0x84, 0x9, 0x84, 0x4, 0x85, 0x9, 0x85, 0x4, 0x86, 
       0x9, 0x86, 0x4, 0x87, 0x9, 0x87, 0x4, 0x88, 0x9, 0x88, 0x4, 0x89, 
       0x9, 0x89, 0x4, 0x8a, 0x9, 0x8a, 0x4, 0x8b, 0x9, 0x8b, 0x4, 0x8c, 
       0x9, 0x8c, 0x4, 0x8d, 0x9, 0x8d, 0x4, 0x8e, 0x9, 0x8e, 0x4, 0x8f, 
       0x9, 0x8f, 0x4, 0x90, 0x9, 0x90, 0x4, 0x91, 0x9, 0x91, 0x4, 0x92, 
       0x9, 0x92, 0x4, 0x93, 0x9, 0x93, 0x4, 0x94, 0x9, 0x94, 0x4, 0x95, 
       0x9, 0x95, 0x4, 0x96, 0x9, 0x96, 0x4, 0x97, 0x9, 0x97, 0x4, 0x98, 
       0x9, 0x98, 0x4, 0x99, 0x9, 0x99, 0x4, 0x9a, 0x9, 0x9a, 0x4, 0x9b, 
       0x9, 0x9b, 0x4, 0x9c, 0x9, 0x9c, 0x4, 0x9d, 0x9, 0x9d, 0x4, 0x9e, 
       0x9, 0x9e, 0x4, 0x9f, 0x9, 0x9f, 0x4, 0xa0, 0x9, 0xa0, 0x4, 0xa1, 
       0x9, 0xa1, 0x4, 0xa2, 0x9, 0xa2, 0x4, 0xa3, 0x9, 0xa3, 0x4, 0xa4, 
       0x9, 0xa4, 0x4, 0xa5, 0x9, 0xa5, 0x4, 0xa6, 0x9, 0xa6, 0x4, 0xa7, 
       0x9, 0xa7, 0x4, 0xa8, 0x9, 0xa8, 0x4, 0xa9, 0x9, 0xa9, 0x4, 0xaa, 
       0x9, 0xaa, 0x4, 0xab, 0x9, 0xab, 0x4, 0xac, 0x9, 0xac, 0x4, 0xad, 
       0x9, 0xad, 0x4, 0xae, 0x9, 0xae, 0x4, 0xaf, 0x9, 0xaf, 0x4, 0xb0, 
       0x9, 0xb0, 0x4, 0xb1, 0x9, 0xb1, 0x4, 0xb2, 0x9, 0xb2, 0x4, 0xb3, 
       0x9, 0xb3, 0x4, 0xb4, 0x9, 0xb4, 0x4, 0xb5, 0x9, 0xb5, 0x4, 0xb6, 
       0x9, 0xb6, 0x4, 0xb7, 0x9, 0xb7, 0x4, 0xb8, 0x9, 0xb8, 0x4, 0xb9, 
       0x9, 0xb9, 0x4, 0xba, 0x9, 0xba, 0x4, 0xbb, 0x9, 0xbb, 0x4, 0xbc, 
       0x9, 0xbc, 0x4, 0xbd, 0x9, 0xbd, 0x4, 0xbe, 0x9, 0xbe, 0x4, 0xbf, 
       0x9, 0xbf, 0x4, 0xc0, 0x9, 0xc0, 0x4, 0xc1, 0x9, 0xc1, 0x4, 0xc2, 
       0x9, 0xc2, 0x4, 0xc3, 0x9, 0xc3, 0x4, 0xc4, 0x9, 0xc4, 0x4, 0xc5, 
       0x9, 0xc5, 0x4, 0xc6, 0x9, 0xc6, 0x4, 0xc7, 0x9, 0xc7, 0x4, 0xc8, 
       0x9, 0xc8, 0x4, 0xc9, 0x9, 0xc9, 0x4, 0xca, 0x9, 0xca, 0x4, 0xcb, 
       0x9, 0xcb, 0x4, 0xcc, 0x9, 0xcc, 0x4, 0xcd, 0x9, 0xcd, 0x4, 0xce, 
       0x9, 0xce, 0x4, 0xcf, 0x9, 0xcf, 0x3, 0x2, 0x7, 0x2, 0x1a0, 0xa, 
       0x2, 0xc, 0x2, 0xe, 0x2, 0x1a3, 0xb, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 
       0x3, 0x5, 0x3, 0x1a8, 0xa, 0x3, 0x3, 0x3, 0x3, 0x3, 0x5, 0x3, 0x1ac, 
       0xa, 0x3, 0x3, 0x4, 0x3, 0x4, 0x5, 0x4, 0x1b0, 0xa, 0x4, 0x6, 0x4, 
       0x1b2, 0xa, 0x4, 0xd, 0x4, 0xe, 0x4, 0x1b3, 0x3, 0x5, 0x3, 0x5, 0x3, 
       0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x1bd, 0xa, 
       0x5, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x5, 0x6, 0x1c3, 0xa, 
       0x6, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 
       0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 
       0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 
       0x3, 0x7, 0x3, 0x7, 0x5, 0x7, 0x1da, 0xa, 0x7, 0x3, 0x8, 0x3, 0x8, 
       0x3, 0x8, 0x3, 0x8, 0x5, 0x8, 0x1e0, 0xa, 0x8, 0x3, 0x9, 0x3, 0x9, 
       0x3, 0x9, 0x3, 0x9, 0x3, 0x9, 0x3, 0x9, 0x3, 0x9, 0x5, 0x9, 0x1e9, 
       0xa, 0x9, 0x3, 0xa, 0x3, 0xa, 0x5, 0xa, 0x1ed, 0xa, 0xa, 0x3, 0xa, 
       0x5, 0xa, 0x1f0, 0xa, 0xa, 0x3, 0xa, 0x3, 0xa, 0x5, 0xa, 0x1f4, 0xa, 
       0xa, 0x3, 0xb, 0x3, 0xb, 0x5, 0xb, 0x1f8, 0xa, 0xb, 0x3, 0xc, 0x3, 
       0xc, 0x5, 0xc, 0x1fc, 0xa, 0xc, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x5, 
       0xd, 0x201, 0xa, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x5, 0xd, 0x206, 
       0xa, 0xd, 0x5, 0xd, 0x208, 0xa, 0xd, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 
       0x3, 0xe, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x5, 0xf, 0x211, 0xa, 0xf, 
       0x3, 0xf, 0x5, 0xf, 0x214, 0xa, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 
       0x5, 0xf, 0x219, 0xa, 0xf, 0x3, 0xf, 0x5, 0xf, 0x21c, 0xa, 0xf, 0x5, 
       0xf, 0x21e, 0xa, 0xf, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 0x222, 0xa, 
       0x10, 0x3, 0x10, 0x5, 0x10, 0x225, 0xa, 0x10, 0x3, 0x11, 0x3, 0x11, 
       0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x5, 0x11, 0x22d, 0xa, 
       0x11, 0x3, 0x11, 0x5, 0x11, 0x230, 0xa, 0x11, 0x3, 0x12, 0x3, 0x12, 
       0x3, 0x12, 0x5, 0x12, 0x235, 0xa, 0x12, 0x3, 0x12, 0x5, 0x12, 0x238, 
       0xa, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x5, 0x12, 0x23d, 0xa, 
       0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x5, 0x12, 0x242, 0xa, 0x12, 
       0x3, 0x12, 0x5, 0x12, 0x245, 0xa, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 
       0x12, 0x5, 0x12, 0x24a, 0xa, 0x12, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 
       0x3, 0x13, 0x5, 0x13, 0x250, 0xa, 0x13, 0x3, 0x14, 0x3, 0x14, 0x3, 
       0x14, 0x3, 0x14, 0x3, 0x14, 0x5, 0x14, 0x257, 0xa, 0x14, 0x3, 0x14, 
       0x3, 0x14, 0x5, 0x14, 0x25b, 0xa, 0x14, 0x5, 0x14, 0x25d, 0xa, 0x14, 
       0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 0x262, 0xa, 0x15, 0x3, 
       0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 
       0x16, 0x3, 0x16, 0x3, 0x16, 0x7, 0x16, 0x26d, 0xa, 0x16, 0xc, 0x16, 
       0xe, 0x16, 0x270, 0xb, 0x16, 0x3, 0x16, 0x3, 0x16, 0x5, 0x16, 0x274, 
       0xa, 0x16, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 
       0x3, 0x17, 0x5, 0x17, 0x27c, 0xa, 0x17, 0x3, 0x18, 0x5, 0x18, 0x27f, 
       0xa, 0x18, 0x3, 0x18, 0x3, 0x18, 0x5, 0x18, 0x283, 0xa, 0x18, 0x3, 
       0x18, 0x5, 0x18, 0x286, 0xa, 0x18, 0x3, 0x18, 0x3, 0x18, 0x5, 0x18, 
       0x28a, 0xa, 0x18, 0x3, 0x18, 0x5, 0x18, 0x28d, 0xa, 0x18, 0x3, 0x18, 
       0x3, 0x18, 0x5, 0x18, 0x291, 0xa, 0x18, 0x3, 0x18, 0x5, 0x18, 0x294, 
       0xa, 0x18, 0x3, 0x18, 0x5, 0x18, 0x297, 0xa, 0x18, 0x3, 0x18, 0x5, 
       0x18, 0x29a, 0xa, 0x18, 0x3, 0x18, 0x5, 0x18, 0x29d, 0xa, 0x18, 0x3, 
       0x19, 0x3, 0x19, 0x5, 0x19, 0x2a1, 0xa, 0x19, 0x3, 0x19, 0x3, 0x19, 
       0x3, 0x19, 0x5, 0x19, 0x2a6, 0xa, 0x19, 0x3, 0x1a, 0x5, 0x1a, 0x2a9, 
       0xa, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x2ad, 0xa, 0x1a, 0x3, 
       0x1a, 0x5, 0x1a, 0x2b0, 0xa, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 
       0x2b4, 0xa, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x2b7, 0xa, 0x1a, 0x3, 0x1a, 
       0x3, 0x1a, 0x5, 0x1a, 0x2bb, 0xa, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x3, 
       0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x2c1, 0xa, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 
       0x2c4, 0xa, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x2c8, 0xa, 0x1a, 
       0x3, 0x1a, 0x5, 0x1a, 0x2cb, 0xa, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x2ce, 
       0xa, 0x1a, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 
       0x5, 0x1b, 0x2d5, 0xa, 0x1b, 0x3, 0x1c, 0x5, 0x1c, 0x2d8, 0xa, 0x1c, 
       0x3, 0x1c, 0x3, 0x1c, 0x5, 0x1c, 0x2dc, 0xa, 0x1c, 0x3, 0x1c, 0x5, 
       0x1c, 0x2df, 0xa, 0x1c, 0x3, 0x1c, 0x5, 0x1c, 0x2e2, 0xa, 0x1c, 0x3, 
       0x1c, 0x5, 0x1c, 0x2e5, 0xa, 0x1c, 0x3, 0x1d, 0x5, 0x1d, 0x2e8, 0xa, 
       0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x5, 0x1d, 0x2ec, 0xa, 0x1d, 0x3, 0x1d, 
       0x3, 0x1d, 0x5, 0x1d, 0x2f0, 0xa, 0x1d, 0x3, 0x1d, 0x5, 0x1d, 0x2f3, 
       0xa, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x7, 0x1d, 
       0x2f9, 0xa, 0x1d, 0xc, 0x1d, 0xe, 0x1d, 0x2fc, 0xb, 0x1d, 0x3, 0x1d, 
       0x5, 0x1d, 0x2ff, 0xa, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x5, 0x1d, 0x303, 
       0xa, 0x1d, 0x3, 0x1d, 0x5, 0x1d, 0x306, 0xa, 0x1d, 0x3, 0x1d, 0x5, 
       0x1d, 0x309, 0xa, 0x1d, 0x3, 0x1d, 0x5, 0x1d, 0x30c, 0xa, 0x1d, 0x3, 
       0x1d, 0x5, 0x1d, 0x30f, 0xa, 0x1d, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 
       0x3, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 0x316, 0xa, 0x1e, 0x3, 0x1e, 0x3, 
       0x1e, 0x5, 0x1e, 0x31a, 0xa, 0x1e, 0x5, 0x1e, 0x31c, 0xa, 0x1e, 0x3, 
       0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x7, 0x1f, 0x322, 0xa, 0x1f, 
       0xc, 0x1f, 0xe, 0x1f, 0x325, 0xb, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 
       0x1f, 0x5, 0x1f, 0x32a, 0xa, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 
       0x3, 0x1f, 0x5, 0x1f, 0x330, 0xa, 0x1f, 0x5, 0x1f, 0x332, 0xa, 0x1f, 
       0x3, 0x20, 0x3, 0x20, 0x5, 0x20, 0x336, 0xa, 0x20, 0x3, 0x20, 0x5, 
       0x20, 0x339, 0xa, 0x20, 0x3, 0x20, 0x5, 0x20, 0x33c, 0xa, 0x20, 0x3, 
       0x21, 0x3, 0x21, 0x3, 0x21, 0x5, 0x21, 0x341, 0xa, 0x21, 0x3, 0x21, 
       0x3, 0x21, 0x3, 0x21, 0x5, 0x21, 0x346, 0xa, 0x21, 0x3, 0x21, 0x5, 
       0x21, 0x349, 0xa, 0x21, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 
       0x3, 0x22, 0x3, 0x22, 0x5, 0x22, 0x351, 0xa, 0x22, 0x3, 0x22, 0x3, 
       0x22, 0x5, 0x22, 0x355, 0xa, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 
       0x7, 0x22, 0x35a, 0xa, 0x22, 0xc, 0x22, 0xe, 0x22, 0x35d, 0xb, 0x22, 
       0x5, 0x22, 0x35f, 0xa, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 
       0x22, 0x3, 0x22, 0x7, 0x22, 0x366, 0xa, 0x22, 0xc, 0x22, 0xe, 0x22, 
       0x369, 0xb, 0x22, 0x5, 0x22, 0x36b, 0xa, 0x22, 0x3, 0x22, 0x3, 0x22, 
       0x5, 0x22, 0x36f, 0xa, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 
       0x22, 0x7, 0x22, 0x375, 0xa, 0x22, 0xc, 0x22, 0xe, 0x22, 0x378, 0xb, 
       0x22, 0x5, 0x22, 0x37a, 0xa, 0x22, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 
       0x37e, 0xa, 0x23, 0x3, 0x23, 0x5, 0x23, 0x381, 0xa, 0x23, 0x3, 0x23, 
       0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 
       0x5, 0x23, 0x38a, 0xa, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 
       0x23, 0x3, 0x23, 0x5, 0x23, 0x391, 0xa, 0x23, 0x3, 0x23, 0x3, 0x23, 
       0x5, 0x23, 0x395, 0xa, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x399, 
       0xa, 0x23, 0x3, 0x23, 0x5, 0x23, 0x39c, 0xa, 0x23, 0x3, 0x23, 0x3, 
       0x23, 0x5, 0x23, 0x3a0, 0xa, 0x23, 0x3, 0x23, 0x5, 0x23, 0x3a3, 0xa, 
       0x23, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 
       0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 
       0x24, 0x3, 0x24, 0x3, 0x24, 0x5, 0x24, 0x3b3, 0xa, 0x24, 0x3, 0x24, 
       0x3, 0x24, 0x5, 0x24, 0x3b7, 0xa, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 
       0x24, 0x3, 0x24, 0x5, 0x24, 0x3bd, 0xa, 0x24, 0x5, 0x24, 0x3bf, 0xa, 
       0x24, 0x3, 0x24, 0x5, 0x24, 0x3c2, 0xa, 0x24, 0x3, 0x25, 0x3, 0x25, 
       0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x3ca, 0xa, 
       0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x3d0, 
       0xa, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x3d5, 0xa, 
       0x25, 0x3, 0x25, 0x5, 0x25, 0x3d8, 0xa, 0x25, 0x3, 0x26, 0x3, 0x26, 
       0x3, 0x26, 0x3, 0x26, 0x5, 0x26, 0x3de, 0xa, 0x26, 0x3, 0x27, 0x3, 
       0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x5, 0x27, 0x3e6, 
       0xa, 0x27, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 
       0x3, 0x28, 0x3, 0x28, 0x5, 0x28, 0x3ef, 0xa, 0x28, 0x3, 0x28, 0x3, 
       0x28, 0x3, 0x28, 0x3, 0x28, 0x7, 0x28, 0x3f5, 0xa, 0x28, 0xc, 0x28, 
       0xe, 0x28, 0x3f8, 0xb, 0x28, 0x5, 0x28, 0x3fa, 0xa, 0x28, 0x3, 0x28, 
       0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x5, 0x28, 0x401, 0xa, 
       0x28, 0x3, 0x28, 0x5, 0x28, 0x404, 0xa, 0x28, 0x3, 0x29, 0x3, 0x29, 
       0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x5, 0x2a, 0x42c, 0xa, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x42f, 0xa, 0x2a, 
       0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x5, 0x2b, 0x435, 0xa, 
       0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 
       0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x5, 0x2b, 0x441, 
       0xa, 0x2b, 0x5, 0x2b, 0x443, 0xa, 0x2b, 0x3, 0x2b, 0x5, 0x2b, 0x446, 
       0xa, 0x2b, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 
       0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 
       0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 
       0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 
       0x45e, 0xa, 0x2c, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 
       0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x5, 0x2d, 0x469, 
       0xa, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 
       0x3, 0x2d, 0x5, 0x2d, 0x471, 0xa, 0x2d, 0x3, 0x2e, 0x3, 0x2e, 0x3, 
       0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x7, 0x2e, 0x47a, 
       0xa, 0x2e, 0xc, 0x2e, 0xe, 0x2e, 0x47d, 0xb, 0x2e, 0x7, 0x2e, 0x47f, 
       0xa, 0x2e, 0xc, 0x2e, 0xe, 0x2e, 0x482, 0xb, 0x2e, 0x5, 0x2e, 0x484, 
       0xa, 0x2e, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 
       0x3, 0x2f, 0x5, 0x2f, 0x48c, 0xa, 0x2f, 0x3, 0x30, 0x3, 0x30, 0x3, 
       0x30, 0x3, 0x30, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x5, 
       0x31, 0x496, 0xa, 0x31, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x33, 
       0x3, 0x33, 0x3, 0x33, 0x3, 0x34, 0x3, 0x34, 0x3, 0x35, 0x3, 0x35, 
       0x3, 0x36, 0x3, 0x36, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 
       0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 
       0x3, 0x38, 0x3, 0x38, 0x5, 0x38, 0x4b0, 0xa, 0x38, 0x3, 0x38, 0x3, 
       0x38, 0x3, 0x38, 0x3, 0x38, 0x5, 0x38, 0x4b6, 0xa, 0x38, 0x3, 0x38, 
       0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 
       0x3, 0x38, 0x3, 0x38, 0x5, 0x38, 0x4c1, 0xa, 0x38, 0x3, 0x39, 0x3, 
       0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x3a, 0x3, 0x3a, 0x3, 
       0x3a, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3c, 0x3, 0x3c, 0x3, 
       0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x5, 0x3c, 0x4d4, 0xa, 0x3c, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x5, 0x3d, 0x4dc, 0xa, 0x3d, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 
       0x3e, 0x3, 0x3e, 0x5, 0x3e, 0x4e3, 0xa, 0x3e, 0x3, 0x3f, 0x3, 0x3f, 
       0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 
       0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 
       0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 
       0x3, 0x3f, 0x5, 0x3f, 0x4fa, 0xa, 0x3f, 0x3, 0x40, 0x3, 0x40, 0x3, 
       0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 
       0x41, 0x3, 0x41, 0x3, 0x41, 0x5, 0x41, 0x507, 0xa, 0x41, 0x3, 0x42, 
       0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x5, 0x42, 0x50d, 0xa, 0x42, 0x3, 
       0x42, 0x3, 0x42, 0x3, 0x42, 0x5, 0x42, 0x512, 0xa, 0x42, 0x3, 0x42, 
       0x5, 0x42, 0x515, 0xa, 0x42, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 
       0x43, 0x5, 0x43, 0x51b, 0xa, 0x43, 0x3, 0x43, 0x3, 0x43, 0x5, 0x43, 
       0x51f, 0xa, 0x43, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 
       0x44, 0x5, 0x44, 0x526, 0xa, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 
       0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x5, 0x45, 0x52f, 0xa, 
       0x45, 0x3, 0x45, 0x3, 0x45, 0x5, 0x45, 0x533, 0xa, 0x45, 0x3, 0x46, 
       0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x5, 0x46, 0x539, 0xa, 0x46, 0x3, 
       0x46, 0x3, 0x46, 0x5, 0x46, 0x53d, 0xa, 0x46, 0x3, 0x46, 0x5, 0x46, 
       0x540, 0xa, 0x46, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x5, 
       0x47, 0x546, 0xa, 0x47, 0x3, 0x47, 0x3, 0x47, 0x5, 0x47, 0x54a, 0xa, 
       0x47, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x5, 0x48, 0x550, 
       0xa, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x7, 0x48, 0x555, 0xa, 
       0x48, 0xc, 0x48, 0xe, 0x48, 0x558, 0xb, 0x48, 0x3, 0x48, 0x5, 0x48, 
       0x55b, 0xa, 0x48, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x5, 
       0x49, 0x561, 0xa, 0x49, 0x3, 0x49, 0x3, 0x49, 0x5, 0x49, 0x565, 0xa, 
       0x49, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 
       0x4a, 0x3, 0x4a, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x5, 
       0x4b, 0x572, 0xa, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4c, 0x3, 0x4c, 
       0x5, 0x4c, 0x578, 0xa, 0x4c, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 
       0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4e, 0x3, 0x4e, 0x3, 
       0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x5, 
       0x4e, 0x589, 0xa, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x5, 0x4e, 0x58d, 0xa, 
       0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4f, 0x3, 0x4f, 0x3, 
       0x4f, 0x5, 0x4f, 0x595, 0xa, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x5, 0x4f, 
       0x599, 0xa, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x7, 
       0x4f, 0x59f, 0xa, 0x4f, 0xc, 0x4f, 0xe, 0x4f, 0x5a2, 0xb, 0x4f, 0x3, 
       0x4f, 0x5, 0x4f, 0x5a5, 0xa, 0x4f, 0x5, 0x4f, 0x5a7, 0xa, 0x4f, 0x3, 
       0x50, 0x3, 0x50, 0x5, 0x50, 0x5ab, 0xa, 0x50, 0x3, 0x50, 0x3, 0x50, 
       0x5, 0x50, 0x5af, 0xa, 0x50, 0x3, 0x50, 0x3, 0x50, 0x5, 0x50, 0x5b3, 
       0xa, 0x50, 0x3, 0x50, 0x3, 0x50, 0x5, 0x50, 0x5b7, 0xa, 0x50, 0x3, 
       0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x5, 0x50, 0x5bd, 0xa, 0x50, 
       0x3, 0x50, 0x3, 0x50, 0x5, 0x50, 0x5c1, 0xa, 0x50, 0x5, 0x50, 0x5c3, 
       0xa, 0x50, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x5, 0x51, 0x5c8, 0xa, 
       0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x7, 0x51, 0x5ce, 
       0xa, 0x51, 0xc, 0x51, 0xe, 0x51, 0x5d1, 0xb, 0x51, 0x5, 0x51, 0x5d3, 
       0xa, 0x51, 0x3, 0x51, 0x5, 0x51, 0x5d6, 0xa, 0x51, 0x3, 0x51, 0x3, 
       0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x7, 0x51, 0x5dd, 0xa, 0x51, 
       0xc, 0x51, 0xe, 0x51, 0x5e0, 0xb, 0x51, 0x3, 0x51, 0x3, 0x51, 0x5, 
       0x51, 0x5e4, 0xa, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x5, 0x51, 
       0x5e9, 0xa, 0x51, 0x3, 0x51, 0x5, 0x51, 0x5ec, 0xa, 0x51, 0x5, 0x51, 
       0x5ee, 0xa, 0x51, 0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x5f2, 0xa, 0x52, 
       0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x5f6, 0xa, 0x52, 0x3, 0x52, 0x5, 
       0x52, 0x5f9, 0xa, 0x52, 0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x5fd, 0xa, 
       0x52, 0x3, 0x53, 0x3, 0x53, 0x3, 0x54, 0x3, 0x54, 0x5, 0x54, 0x603, 
       0xa, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x5, 0x54, 0x608, 0xa, 
       0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x5, 
       0x54, 0x60f, 0xa, 0x54, 0x5, 0x54, 0x611, 0xa, 0x54, 0x3, 0x54, 0x3, 
       0x54, 0x5, 0x54, 0x615, 0xa, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 
       0x3, 0x54, 0x3, 0x54, 0x5, 0x54, 0x61c, 0xa, 0x54, 0x3, 0x54, 0x3, 
       0x54, 0x5, 0x54, 0x620, 0xa, 0x54, 0x3, 0x54, 0x5, 0x54, 0x623, 0xa, 
       0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 
       0x54, 0x3, 0x54, 0x5, 0x54, 0x62c, 0xa, 0x54, 0x3, 0x54, 0x5, 0x54, 
       0x62f, 0xa, 0x54, 0x5, 0x54, 0x631, 0xa, 0x54, 0x3, 0x55, 0x3, 0x55, 
       0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x5, 0x55, 
       0x63a, 0xa, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 
       0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x5, 0x55, 0x645, 
       0xa, 0x55, 0x3, 0x55, 0x3, 0x55, 0x5, 0x55, 0x649, 0xa, 0x55, 0x5, 
       0x55, 0x64b, 0xa, 0x55, 0x5, 0x55, 0x64d, 0xa, 0x55, 0x3, 0x56, 0x3, 
       0x56, 0x3, 0x56, 0x3, 0x56, 0x5, 0x56, 0x653, 0xa, 0x56, 0x3, 0x56, 
       0x3, 0x56, 0x3, 0x56, 0x5, 0x56, 0x658, 0xa, 0x56, 0x3, 0x56, 0x3, 
       0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x5, 0x56, 0x65f, 0xa, 0x56, 
       0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 
       0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x5, 0x56, 
       0x66c, 0xa, 0x56, 0x5, 0x56, 0x66e, 0xa, 0x56, 0x5, 0x56, 0x670, 
       0xa, 0x56, 0x3, 0x56, 0x5, 0x56, 0x673, 0xa, 0x56, 0x3, 0x56, 0x5, 
       0x56, 0x676, 0xa, 0x56, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 
       0x3, 0x57, 0x5, 0x57, 0x67d, 0xa, 0x57, 0x3, 0x57, 0x5, 0x57, 0x680, 
       0xa, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x5, 0x57, 
       0x686, 0xa, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x5, 0x57, 0x68b, 
       0xa, 0x57, 0x5, 0x57, 0x68d, 0xa, 0x57, 0x3, 0x57, 0x5, 0x57, 0x690, 
       0xa, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x5, 0x57, 
       0x696, 0xa, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 
       0x57, 0x3, 0x57, 0x5, 0x57, 0x69e, 0xa, 0x57, 0x5, 0x57, 0x6a0, 0xa, 
       0x57, 0x3, 0x57, 0x5, 0x57, 0x6a3, 0xa, 0x57, 0x3, 0x57, 0x3, 0x57, 
       0x5, 0x57, 0x6a7, 0xa, 0x57, 0x3, 0x57, 0x5, 0x57, 0x6aa, 0xa, 0x57, 
       0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x5, 0x57, 0x6b0, 0xa, 
       0x57, 0x3, 0x57, 0x5, 0x57, 0x6b3, 0xa, 0x57, 0x3, 0x57, 0x3, 0x57, 
       0x5, 0x57, 0x6b7, 0xa, 0x57, 0x3, 0x57, 0x5, 0x57, 0x6ba, 0xa, 0x57, 
       0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x5, 0x57, 0x6c0, 0xa, 
       0x57, 0x3, 0x57, 0x5, 0x57, 0x6c3, 0xa, 0x57, 0x5, 0x57, 0x6c5, 0xa, 
       0x57, 0x3, 0x58, 0x3, 0x58, 0x5, 0x58, 0x6c9, 0xa, 0x58, 0x3, 0x59, 
       0x3, 0x59, 0x3, 0x59, 0x5, 0x59, 0x6ce, 0xa, 0x59, 0x3, 0x5a, 0x3, 
       0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5b, 0x3, 0x5b, 0x5, 0x5b, 0x6d6, 
       0xa, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x5, 0x5b, 0x6db, 0xa, 
       0x5b, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 
       0x5d, 0x3, 0x5d, 0x5, 0x5d, 0x6e4, 0xa, 0x5d, 0x3, 0x5d, 0x7, 0x5d, 
       0x6e7, 0xa, 0x5d, 0xc, 0x5d, 0xe, 0x5d, 0x6ea, 0xb, 0x5d, 0x3, 0x5e, 
       0x3, 0x5e, 0x5, 0x5e, 0x6ee, 0xa, 0x5e, 0x3, 0x5f, 0x3, 0x5f, 0x3, 
       0x5f, 0x3, 0x5f, 0x5, 0x5f, 0x6f4, 0xa, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 
       0x5, 0x5f, 0x6f8, 0xa, 0x5f, 0x3, 0x5f, 0x5, 0x5f, 0x6fb, 0xa, 0x5f, 
       0x3, 0x5f, 0x3, 0x5f, 0x5, 0x5f, 0x6ff, 0xa, 0x5f, 0x3, 0x5f, 0x3, 
       0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x5, 0x5f, 0x705, 0xa, 0x5f, 0x3, 0x5f, 
       0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x5, 0x5f, 
       0x70d, 0xa, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x5, 0x5f, 0x712, 
       0xa, 0x5f, 0x5, 0x5f, 0x714, 0xa, 0x5f, 0x3, 0x5f, 0x5, 0x5f, 0x717, 
       0xa, 0x5f, 0x3, 0x5f, 0x7, 0x5f, 0x71a, 0xa, 0x5f, 0xc, 0x5f, 0xe, 
       0x5f, 0x71d, 0xb, 0x5f, 0x3, 0x60, 0x3, 0x60, 0x5, 0x60, 0x721, 0xa, 
       0x60, 0x3, 0x60, 0x5, 0x60, 0x724, 0xa, 0x60, 0x3, 0x60, 0x3, 0x60, 
       0x3, 0x60, 0x5, 0x60, 0x729, 0xa, 0x60, 0x3, 0x60, 0x5, 0x60, 0x72c, 
       0xa, 0x60, 0x3, 0x60, 0x5, 0x60, 0x72f, 0xa, 0x60, 0x3, 0x60, 0x3, 
       0x60, 0x3, 0x60, 0x3, 0x60, 0x5, 0x60, 0x735, 0xa, 0x60, 0x3, 0x60, 
       0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x5, 0x60, 0x73b, 0xa, 0x60, 0x3, 
       0x61, 0x3, 0x61, 0x5, 0x61, 0x73f, 0xa, 0x61, 0x3, 0x61, 0x3, 0x61, 
       0x3, 0x61, 0x5, 0x61, 0x744, 0xa, 0x61, 0x3, 0x61, 0x5, 0x61, 0x747, 
       0xa, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x5, 0x61, 0x74c, 0xa, 
       0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x5, 0x61, 0x751, 0xa, 0x61, 
       0x7, 0x61, 0x753, 0xa, 0x61, 0xc, 0x61, 0xe, 0x61, 0x756, 0xb, 0x61, 
       0x3, 0x61, 0x3, 0x61, 0x5, 0x61, 0x75a, 0xa, 0x61, 0x3, 0x61, 0x3, 
       0x61, 0x5, 0x61, 0x75e, 0xa, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 
       0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 
       0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 
       0x5, 0x61, 0x76f, 0xa, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 
       0x61, 0x5, 0x61, 0x775, 0xa, 0x61, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 
       0x3, 0x62, 0x3, 0x62, 0x7, 0x62, 0x77c, 0xa, 0x62, 0xc, 0x62, 0xe, 
       0x62, 0x77f, 0xb, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x63, 0x3, 0x63, 
       0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x5, 0x63, 0x788, 0xa, 0x63, 0x3, 
       0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 
       0x64, 0x3, 0x64, 0x5, 0x64, 0x792, 0xa, 0x64, 0x5, 0x64, 0x794, 0xa, 
       0x64, 0x5, 0x64, 0x796, 0xa, 0x64, 0x3, 0x64, 0x5, 0x64, 0x799, 0xa, 
       0x64, 0x3, 0x64, 0x5, 0x64, 0x79c, 0xa, 0x64, 0x3, 0x64, 0x3, 0x64, 
       0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 
       0x3, 0x64, 0x5, 0x64, 0x7a7, 0xa, 0x64, 0x5, 0x64, 0x7a9, 0xa, 0x64, 
       0x5, 0x64, 0x7ab, 0xa, 0x64, 0x3, 0x64, 0x5, 0x64, 0x7ae, 0xa, 0x64, 
       0x3, 0x65, 0x5, 0x65, 0x7b1, 0xa, 0x65, 0x3, 0x65, 0x5, 0x65, 0x7b4, 
       0xa, 0x65, 0x3, 0x65, 0x5, 0x65, 0x7b7, 0xa, 0x65, 0x3, 0x65, 0x5, 
       0x65, 0x7ba, 0xa, 0x65, 0x3, 0x65, 0x5, 0x65, 0x7bd, 0xa, 0x65, 0x3, 
       0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 
       0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x5, 0x66, 0x7c9, 0xa, 0x66, 
       0x3, 0x66, 0x5, 0x66, 0x7cc, 0xa, 0x66, 0x3, 0x66, 0x5, 0x66, 0x7cf, 
       0xa, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 
       0x7, 0x66, 0x7d6, 0xa, 0x66, 0xc, 0x66, 0xe, 0x66, 0x7d9, 0xb, 0x66, 
       0x5, 0x66, 0x7db, 0xa, 0x66, 0x3, 0x66, 0x5, 0x66, 0x7de, 0xa, 0x66, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 
       0x7e5, 0xa, 0x67, 0x3, 0x67, 0x5, 0x67, 0x7e8, 0xa, 0x67, 0x3, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 
       0x7f6, 0xa, 0x67, 0x3, 0x67, 0x5, 0x67, 0x7f9, 0xa, 0x67, 0x3, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x800, 0xa, 
       0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x5, 0x67, 0x80f, 0xa, 0x67, 0x3, 0x68, 0x3, 0x68, 
       0x5, 0x68, 0x813, 0xa, 0x68, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 
       0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x6, 
       0x69, 0x81e, 0xa, 0x69, 0xd, 0x69, 0xe, 0x69, 0x81f, 0x3, 0x69, 0x3, 
       0x69, 0x5, 0x69, 0x824, 0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 
       0x3, 0x69, 0x6, 0x69, 0x82a, 0xa, 0x69, 0xd, 0x69, 0xe, 0x69, 0x82b, 
       0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0x830, 0xa, 0x69, 0x3, 0x69, 0x3, 
       0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 
       0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 
       0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0x844, 
       0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 
       0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 
       0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 
       0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x7, 0x69, 0x85b, 0xa, 
       0x69, 0xc, 0x69, 0xe, 0x69, 0x85e, 0xb, 0x69, 0x3, 0x6a, 0x3, 0x6a, 
       0x3, 0x6a, 0x5, 0x6a, 0x863, 0xa, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 
       0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x5, 0x6a, 0x86a, 0xa, 0x6a, 0x3, 0x6a, 
       0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 
       0x5, 0x6a, 0x873, 0xa, 0x6a, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6c, 0x3, 
       0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 
       0x6c, 0x5, 0x6c, 0x87f, 0xa, 0x6c, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6e, 
       0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 0x886, 0xa, 0x6e, 0x3, 0x6e, 0x3, 
       0x6e, 0x3, 0x6e, 0x7, 0x6e, 0x88b, 0xa, 0x6e, 0xc, 0x6e, 0xe, 0x6e, 
       0x88e, 0xb, 0x6e, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 
       0x6f, 0x5, 0x6f, 0x895, 0xa, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 
       0x3, 0x6f, 0x3, 0x6f, 0x3, 0x70, 0x3, 0x70, 0x5, 0x70, 0x89e, 0xa, 
       0x70, 0x3, 0x70, 0x3, 0x70, 0x5, 0x70, 0x8a2, 0xa, 0x70, 0x3, 0x70, 
       0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 
       0x3, 0x70, 0x5, 0x70, 0x8ac, 0xa, 0x70, 0x3, 0x71, 0x3, 0x71, 0x3, 
       0x71, 0x7, 0x71, 0x8b1, 0xa, 0x71, 0xc, 0x71, 0xe, 0x71, 0x8b4, 0xb, 
       0x71, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 
       0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x7, 0x72, 0x8bf, 0xa, 0x72, 
       0xc, 0x72, 0xe, 0x72, 0x8c2, 0xb, 0x72, 0x3, 0x73, 0x3, 0x73, 0x3, 
       0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 
       0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 
       0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x5, 
       0x73, 0x8d8, 0xa, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 
       0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x5, 0x73, 0x8e1, 0xa, 0x73, 0x3, 
       0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x5, 0x73, 0x8e7, 0xa, 0x73, 
       0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x5, 0x73, 0x8ed, 0xa, 
       0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x5, 0x73, 0x8f3, 
       0xa, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 
       0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x5, 0x73, 0x8fe, 0xa, 
       0x73, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 
       0x74, 0x5, 0x74, 0x906, 0xa, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 
       0x3, 0x74, 0x7, 0x74, 0x90c, 0xa, 0x74, 0xc, 0x74, 0xe, 0x74, 0x90f, 
       0xb, 0x74, 0x3, 0x75, 0x3, 0x75, 0x5, 0x75, 0x913, 0xa, 0x75, 0x3, 
       0x75, 0x3, 0x75, 0x5, 0x75, 0x917, 0xa, 0x75, 0x3, 0x76, 0x3, 0x76, 
       0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x5, 0x76, 
       0x920, 0xa, 0x76, 0x3, 0x77, 0x3, 0x77, 0x5, 0x77, 0x924, 0xa, 0x77, 
       0x3, 0x77, 0x5, 0x77, 0x927, 0xa, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 
       0x77, 0x5, 0x77, 0x92c, 0xa, 0x77, 0x3, 0x77, 0x3, 0x77, 0x5, 0x77, 
       0x930, 0xa, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x5, 
       0x77, 0x936, 0xa, 0x77, 0x5, 0x77, 0x938, 0xa, 0x77, 0x3, 0x77, 0x3, 
       0x77, 0x5, 0x77, 0x93c, 0xa, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 
       0x3, 0x77, 0x3, 0x77, 0x7, 0x77, 0x943, 0xa, 0x77, 0xc, 0x77, 0xe, 
       0x77, 0x946, 0xb, 0x77, 0x5, 0x77, 0x948, 0xa, 0x77, 0x3, 0x77, 0x5, 
       0x77, 0x94b, 0xa, 0x77, 0x3, 0x77, 0x3, 0x77, 0x5, 0x77, 0x94f, 0xa, 
       0x77, 0x3, 0x77, 0x3, 0x77, 0x5, 0x77, 0x953, 0xa, 0x77, 0x3, 0x78, 
       0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 
       0x3, 0x78, 0x7, 0x78, 0x95d, 0xa, 0x78, 0xc, 0x78, 0xe, 0x78, 0x960, 
       0xb, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 
       0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x7, 0x79, 0x96b, 0xa, 
       0x79, 0xc, 0x79, 0xe, 0x79, 0x96e, 0xb, 0x79, 0x3, 0x79, 0x3, 0x79, 
       0x5, 0x79, 0x972, 0xa, 0x79, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x5, 
       0x7a, 0x977, 0xa, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x5, 0x7a, 0x97b, 0xa, 
       0x7a, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x5, 
       0x7b, 0x982, 0xa, 0x7b, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 
       0x3, 0x7c, 0x7, 0x7c, 0x989, 0xa, 0x7c, 0xc, 0x7c, 0xe, 0x7c, 0x98c, 
       0xb, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x5, 0x7c, 
       0x992, 0xa, 0x7c, 0x5, 0x7c, 0x994, 0xa, 0x7c, 0x3, 0x7d, 0x3, 0x7d, 
       0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7e, 0x3, 0x7e, 
       0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x5, 0x7e, 0x9a2, 0xa, 
       0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 
       0x7e, 0x5, 0x7e, 0x9aa, 0xa, 0x7e, 0x3, 0x7e, 0x5, 0x7e, 0x9ad, 0xa, 
       0x7e, 0x5, 0x7e, 0x9af, 0xa, 0x7e, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 
       0x3, 0x7f, 0x3, 0x7f, 0x5, 0x7f, 0x9b6, 0xa, 0x7f, 0x3, 0x80, 0x3, 
       0x80, 0x5, 0x80, 0x9ba, 0xa, 0x80, 0x3, 0x81, 0x3, 0x81, 0x3, 0x82, 
       0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x7, 0x82, 0x9c3, 0xa, 
       0x82, 0xc, 0x82, 0xe, 0x82, 0x9c6, 0xb, 0x82, 0x3, 0x82, 0x3, 0x82, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x7, 0x83, 0x9e5, 0xa, 0x83, 0xc, 
       0x83, 0xe, 0x83, 0x9e8, 0xb, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x5, 0x83, 0x9f7, 0xa, 
       0x83, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x5, 0x84, 0x9fd, 
       0xa, 0x84, 0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 0x7, 0x85, 0xa02, 0xa, 
       0x85, 0xc, 0x85, 0xe, 0x85, 0xa05, 0xb, 0x85, 0x3, 0x86, 0x3, 0x86, 
       0x3, 0x86, 0x5, 0x86, 0xa0a, 0xa, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 
       0x86, 0x5, 0x86, 0xa0f, 0xa, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 
       0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x5, 0x86, 0xa17, 0xa, 0x86, 0x3, 
       0x86, 0x5, 0x86, 0xa1a, 0xa, 0x86, 0x5, 0x86, 0xa1c, 0xa, 0x86, 0x3, 
       0x87, 0x3, 0x87, 0x3, 0x87, 0x7, 0x87, 0xa21, 0xa, 0x87, 0xc, 0x87, 
       0xe, 0x87, 0xa24, 0xb, 0x87, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 
       0x88, 0x3, 0x88, 0x3, 0x88, 0x5, 0x88, 0xa2c, 0xa, 0x88, 0x3, 0x88, 
       0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 
       0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 
       0x3, 0x88, 0x3, 0x88, 0x7, 0x88, 0xa3d, 0xa, 0x88, 0xc, 0x88, 0xe, 
       0x88, 0xa40, 0xb, 0x88, 0x3, 0x89, 0x3, 0x89, 0x5, 0x89, 0xa44, 0xa, 
       0x89, 0x3, 0x89, 0x5, 0x89, 0xa47, 0xa, 0x89, 0x3, 0x89, 0x5, 0x89, 
       0xa4a, 0xa, 0x89, 0x3, 0x89, 0x3, 0x89, 0x5, 0x89, 0xa4e, 0xa, 0x89, 
       0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x5, 0x89, 0xa53, 0xa, 0x89, 0x5, 
       0x89, 0xa55, 0xa, 0x89, 0x3, 0x89, 0x3, 0x89, 0x5, 0x89, 0xa59, 0xa, 
       0x89, 0x3, 0x89, 0x3, 0x89, 0x5, 0x89, 0xa5d, 0xa, 0x89, 0x3, 0x89, 
       0x3, 0x89, 0x5, 0x89, 0xa61, 0xa, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 
       0x89, 0x3, 0x89, 0x3, 0x89, 0x5, 0x89, 0xa68, 0xa, 0x89, 0x5, 0x89, 
       0xa6a, 0xa, 0x89, 0x5, 0x89, 0xa6c, 0xa, 0x89, 0x3, 0x8a, 0x3, 0x8a, 
       0x5, 0x8a, 0xa70, 0xa, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x5, 
       0x8a, 0xa75, 0xa, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x5, 0x8a, 
       0xa7a, 0xa, 0x8a, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8c, 0x3, 0x8c, 0x3, 
       0x8d, 0x5, 0x8d, 0xa81, 0xa, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8e, 
       0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 
       0x3, 0x8e, 0x3, 0x8f, 0x5, 0x8f, 0xa8e, 0xa, 0x8f, 0x3, 0x8f, 0x3, 
       0x8f, 0x5, 0x8f, 0xa92, 0xa, 0x8f, 0x5, 0x8f, 0xa94, 0xa, 0x8f, 0x3, 
       0x8f, 0x5, 0x8f, 0xa97, 0xa, 0x8f, 0x3, 0x90, 0x3, 0x90, 0x5, 0x90, 
       0xa9b, 0xa, 0x90, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 
       0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 
       0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x7, 
       0x91, 0xaad, 0xa, 0x91, 0xc, 0x91, 0xe, 0x91, 0xab0, 0xb, 0x91, 0x3, 
       0x91, 0x5, 0x91, 0xab3, 0xa, 0x91, 0x3, 0x91, 0x3, 0x91, 0x5, 0x91, 
       0xab7, 0xa, 0x91, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 
       0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 
       0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x5, 0x93, 0xac8, 
       0xa, 0x93, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x5, 0x94, 0xacf, 0xa, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x5, 
       0x94, 0xae6, 0xa, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0xb31, 0xa, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x5, 0x94, 0xb35, 0xa, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x5, 0x94, 0xb51, 0xa, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0xb73, 
       0xa, 0x94, 0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0xb77, 0xa, 0x94, 0x3, 
       0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x96, 0x3, 
       0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x97, 0x5, 0x97, 0xb84, 
       0xa, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x7, 0x97, 
       0xb8a, 0xa, 0x97, 0xc, 0x97, 0xe, 0x97, 0xb8d, 0xb, 0x97, 0x3, 0x97, 
       0x3, 0x97, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 
       0x7, 0x98, 0xb96, 0xa, 0x98, 0xc, 0x98, 0xe, 0x98, 0xb99, 0xb, 0x98, 
       0x3, 0x98, 0x3, 0x98, 0x3, 0x99, 0x5, 0x99, 0xb9e, 0xa, 0x99, 0x3, 
       0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x7, 0x99, 0xba5, 
       0xa, 0x99, 0xc, 0x99, 0xe, 0x99, 0xba8, 0xb, 0x99, 0x3, 0x99, 0x3, 
       0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 
       0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x7, 0x99, 0xbb6, 
       0xa, 0x99, 0xc, 0x99, 0xe, 0x99, 0xbb9, 0xb, 0x99, 0x3, 0x99, 0x3, 
       0x99, 0x3, 0x99, 0x5, 0x99, 0xbbe, 0xa, 0x99, 0x3, 0x99, 0x3, 0x99, 
       0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x5, 0x99, 0xbc6, 0xa, 
       0x99, 0x3, 0x9a, 0x3, 0x9a, 0x5, 0x9a, 0xbca, 0xa, 0x9a, 0x3, 0x9b, 
       0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x7, 0x9b, 0xbd0, 0xa, 0x9b, 0xc, 
       0x9b, 0xe, 0x9b, 0xbd3, 0xb, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9c, 
       0x3, 0x9c, 0x5, 0x9c, 0xbd9, 0xa, 0x9c, 0x3, 0x9d, 0x3, 0x9d, 0x3, 
       0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x7, 0x9e, 0xbe1, 0xa, 0x9e, 
       0xc, 0x9e, 0xe, 0x9e, 0xbe4, 0xb, 0x9e, 0x3, 0x9f, 0x3, 0x9f, 0x3, 
       0x9f, 0x7, 0x9f, 0xbe9, 0xa, 0x9f, 0xc, 0x9f, 0xe, 0x9f, 0xbec, 0xb, 
       0x9f, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa1, 0x3, 
       0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 
       0xa2, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 
       0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 
       0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x7, 0xa3, 0xc09, 0xa, 0xa3, 
       0xc, 0xa3, 0xe, 0xa3, 0xc0c, 0xb, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 
       0xa3, 0x5, 0xa3, 0xc11, 0xa, 0xa3, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 
       0x5, 0xa4, 0xc16, 0xa, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x5, 
       0xa4, 0xc1b, 0xa, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 
       0x5, 0xa4, 0xc21, 0xa, 0xa4, 0x3, 0xa4, 0x5, 0xa4, 0xc24, 0xa, 0xa4, 
       0x3, 0xa4, 0x3, 0xa4, 0x5, 0xa4, 0xc28, 0xa, 0xa4, 0x3, 0xa4, 0x3, 
       0xa4, 0x3, 0xa4, 0x5, 0xa4, 0xc2d, 0xa, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 
       0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 
       0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x5, 0xa4, 
       0xc3c, 0xa, 0xa4, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa6, 0x3, 0xa6, 0x3, 
       0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x5, 0xa6, 0xc45, 0xa, 0xa6, 0x3, 0xa6, 
       0x5, 0xa6, 0xc48, 0xa, 0xa6, 0x3, 0xa6, 0x5, 0xa6, 0xc4b, 0xa, 0xa6, 
       0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa8, 
       0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x5, 0xa8, 
       0xc58, 0xa, 0xa8, 0x3, 0xa9, 0x3, 0xa9, 0x5, 0xa9, 0xc5c, 0xa, 0xa9, 
       0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 
       0x5, 0xaa, 0xc64, 0xa, 0xaa, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 
       0xab, 0x5, 0xab, 0xc6a, 0xa, 0xab, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 
       0x3, 0xac, 0x7, 0xac, 0xc70, 0xa, 0xac, 0xc, 0xac, 0xe, 0xac, 0xc73, 
       0xb, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x5, 0xac, 
       0xc79, 0xa, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x5, 
       0xac, 0xc7f, 0xa, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 
       0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 
       0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x5, 0xac, 0xc8e, 0xa, 0xac, 0x3, 
       0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 
       0xad, 0x5, 0xad, 0xc97, 0xa, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xae, 
       0x3, 0xae, 0x5, 0xae, 0xc9d, 0xa, 0xae, 0x3, 0xaf, 0x3, 0xaf, 0x3, 
       0xaf, 0x3, 0xaf, 0x5, 0xaf, 0xca3, 0xa, 0xaf, 0x3, 0xaf, 0x5, 0xaf, 
       0xca6, 0xa, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x5, 0xaf, 0xcaa, 0xa, 0xaf, 
       0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x7, 0xaf, 0xcaf, 0xa, 0xaf, 0xc, 
       0xaf, 0xe, 0xaf, 0xcb2, 0xb, 0xaf, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 
       0x3, 0xb0, 0x3, 0xb0, 0x5, 0xb0, 0xcb9, 0xa, 0xb0, 0x3, 0xb0, 0x5, 
       0xb0, 0xcbc, 0xa, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 
       0x5, 0xb0, 0xcc2, 0xa, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 
       0xb0, 0x5, 0xb0, 0xcc8, 0xa, 0xb0, 0x5, 0xb0, 0xcca, 0xa, 0xb0, 0x3, 
       0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x5, 0xb0, 0xcd0, 0xa, 0xb0, 
       0x3, 0xb0, 0x5, 0xb0, 0xcd3, 0xa, 0xb0, 0x5, 0xb0, 0xcd5, 0xa, 0xb0, 
       0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x5, 0xb0, 0xcdb, 0xa, 
       0xb0, 0x5, 0xb0, 0xcdd, 0xa, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb1, 
       0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 
       0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x5, 0xb1, 0xceb, 0xa, 0xb1, 0x3, 
       0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x5, 0xb1, 0xcf2, 
       0xa, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 
       0x5, 0xb2, 0xcf9, 0xa, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 
       0xb2, 0x3, 0xb2, 0x5, 0xb2, 0xd00, 0xa, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 
       0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xd07, 0xa, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x5, 0xb4, 0xd0e, 
       0xa, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 
       0x5, 0xb4, 0xd15, 0xa, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb5, 0x3, 
       0xb5, 0x5, 0xb5, 0xd1b, 0xa, 0xb5, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 
       0x5, 0xb6, 0xd20, 0xa, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb7, 0x3, 
       0xb7, 0x3, 0xb7, 0x7, 0xb7, 0xd27, 0xa, 0xb7, 0xc, 0xb7, 0xe, 0xb7, 
       0xd2a, 0xb, 0xb7, 0x3, 0xb8, 0x3, 0xb8, 0x5, 0xb8, 0xd2e, 0xa, 0xb8, 
       0x3, 0xb9, 0x3, 0xb9, 0x3, 0xba, 0x3, 0xba, 0x3, 0xbb, 0x5, 0xbb, 
       0xd35, 0xa, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbc, 0x3, 0xbc, 0x3, 
       0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 
       0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 
       0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xd4b, 0xa, 0xbc, 
       0x3, 0xbd, 0x3, 0xbd, 0x5, 0xbd, 0xd4f, 0xa, 0xbd, 0x3, 0xbe, 0x3, 
       0xbe, 0x3, 0xbe, 0x5, 0xbe, 0xd54, 0xa, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 
       0x5, 0xbe, 0xd58, 0xa, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x5, 0xbe, 0xd5c, 
       0xa, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x5, 0xbe, 0xd60, 0xa, 0xbe, 0x3, 
       0xbf, 0x3, 0xbf, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x5, 0xc0, 0xd67, 
       0xa, 0xc0, 0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 
       0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 
       0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 
       0x5, 0xc2, 0xd7a, 0xa, 0xc2, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc4, 0x3, 
       0xc4, 0x5, 0xc4, 0xd80, 0xa, 0xc4, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 
       0x5, 0xc5, 0xd85, 0xa, 0xc5, 0x3, 0xc5, 0x5, 0xc5, 0xd88, 0xa, 0xc5, 
       0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x5, 0xc5, 0xd8e, 0xa, 
       0xc5, 0x3, 0xc5, 0x5, 0xc5, 0xd91, 0xa, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 
       0x3, 0xc5, 0x7, 0xc5, 0xd96, 0xa, 0xc5, 0xc, 0xc5, 0xe, 0xc5, 0xd99, 
       0xb, 0xc5, 0x3, 0xc5, 0x5, 0xc5, 0xd9c, 0xa, 0xc5, 0x5, 0xc5, 0xd9e, 
       0xa, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x7, 0xc5, 
       0xda4, 0xa, 0xc5, 0xc, 0xc5, 0xe, 0xc5, 0xda7, 0xb, 0xc5, 0x5, 0xc5, 
       0xda9, 0xa, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x5, 0xc5, 0xdad, 0xa, 0xc5, 
       0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x5, 0xc6, 0xdb5, 0xa, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xdb8, 0xa, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x7, 0xc6, 0xdc0, 0xa, 0xc6, 0xc, 0xc6, 0xe, 0xc6, 0xdc3, 0xb, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xdc9, 0xa, 
       0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xdce, 0xa, 0xc6, 
       0x3, 0xc6, 0x5, 0xc6, 0xdd1, 0xa, 0xc6, 0x3, 0xc7, 0x3, 0xc7, 0x3, 
       0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x7, 0xc7, 0xdd9, 0xa, 0xc7, 
       0xc, 0xc7, 0xe, 0xc7, 0xddc, 0xb, 0xc7, 0x5, 0xc7, 0xdde, 0xa, 0xc7, 
       0x3, 0xc7, 0x5, 0xc7, 0xde1, 0xa, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 
       0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x5, 0xc7, 0xde9, 0xa, 0xc7, 
       0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 
       0x3, 0xc8, 0x7, 0xc8, 0xdf2, 0xa, 0xc8, 0xc, 0xc8, 0xe, 0xc8, 0xdf5, 
       0xb, 0xc8, 0x5, 0xc8, 0xdf7, 0xa, 0xc8, 0x3, 0xc8, 0x5, 0xc8, 0xdfa, 
       0xa, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x7, 0xc8, 0xdfe, 0xa, 0xc8, 0xc, 
       0xc8, 0xe, 0xc8, 0xe01, 0xb, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x5, 0xc8, 
       0xe05, 0xa, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x5, 0xc8, 0xe09, 0xa, 0xc8, 
       0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 
       0x7, 0xc9, 0xe11, 0xa, 0xc9, 0xc, 0xc9, 0xe, 0xc9, 0xe14, 0xb, 0xc9, 
       0x5, 0xc9, 0xe16, 0xa, 0xc9, 0x3, 0xc9, 0x5, 0xc9, 0xe19, 0xa, 0xc9, 
       0x3, 0xc9, 0x3, 0xc9, 0x7, 0xc9, 0xe1d, 0xa, 0xc9, 0xc, 0xc9, 0xe, 
       0xc9, 0xe20, 0xb, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x5, 0xc9, 
       0xe25, 0xa, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x5, 0xca, 0xe2d, 0xa, 0xca, 0x3, 0xca, 0x5, 0xca, 
       0xe30, 0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xe34, 0xa, 0xca, 
       0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xe38, 0xa, 0xca, 0x3, 0xca, 0x5, 
       0xca, 0xe3b, 0xa, 0xca, 0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcb, 0x5, 0xcb, 
       0xe40, 0xa, 0xcb, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 
       0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 
       0xcc, 0x3, 0xcc, 0x5, 0xcc, 0xe4e, 0xa, 0xcc, 0x3, 0xcd, 0x3, 0xcd, 
       0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 
       0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xcf, 0x3, 0xcf, 0x5, 0xcf, 
       0xe69, 0xa, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x5, 
       0xcf, 0xe6f, 0xa, 0xcf, 0x3, 0xcf, 0x5, 0xcf, 0xe72, 0xa, 0xcf, 0x3, 
       0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 
       0xcf, 0x5, 0xcf, 0xe7b, 0xa, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 
       0x3, 0xcf, 0x5, 0xcf, 0xe81, 0xa, 0xcf, 0x3, 0xcf, 0x2, 0x6, 0xd0, 
       0xe2, 0xe6, 0x10e, 0xd0, 0x2, 0x4, 0x6, 0x8, 0xa, 0xc, 0xe, 0x10, 
       0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 
       0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 
       0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 
       0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x62, 0x64, 0x66, 0x68, 
       0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 
       0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 
       0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 
       0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 
       0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 
       0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 
       0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x100, 0x102, 
       0x104, 0x106, 0x108, 0x10a, 0x10c, 0x10e, 0x110, 0x112, 0x114, 0x116, 
       0x118, 0x11a, 0x11c, 0x11e, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12a, 
       0x12c, 0x12e, 0x130, 0x132, 0x134, 0x136, 0x138, 0x13a, 0x13c, 0x13e, 
       0x140, 0x142, 0x144, 0x146, 0x148, 0x14a, 0x14c, 0x14e, 0x150, 0x152, 
       0x154, 0x156, 0x158, 0x15a, 0x15c, 0x15e, 0x160, 0x162, 0x164, 0x166, 
       0x168, 0x16a, 0x16c, 0x16e, 0x170, 0x172, 0x174, 0x176, 0x178, 0x17a, 
       0x17c, 0x17e, 0x180, 0x182, 0x184, 0x186, 0x188, 0x18a, 0x18c, 0x18e, 
       0x190, 0x192, 0x194, 0x196, 0x198, 0x19a, 0x19c, 0x2, 0x42, 0x3, 
       0x2, 0x1c2, 0x1c3, 0x4, 0x2, 0x1c2, 0x1c2, 0x1c5, 0x1c5, 0x4, 0x2, 
       0x107, 0x107, 0x1a6, 0x1a6, 0x4, 0x2, 0x1c2, 0x1c3, 0x1c5, 0x1c5, 
       0x4, 0x2, 0x71, 0x71, 0x84, 0x84, 0x4, 0x2, 0x9, 0x9, 0x35, 0x35, 
       0x4, 0x2, 0x85, 0x85, 0x184, 0x184, 0x5, 0x2, 0x112, 0x112, 0x187, 
       0x187, 0x1b7, 0x1b7, 0x5, 0x2, 0xb0, 0xb0, 0xdb, 0xdb, 0x10c, 0x10c, 
       0x4, 0x2, 0x77, 0x77, 0x79, 0x79, 0x5, 0x2, 0x103, 0x103, 0x12b, 
       0x12b, 0x14b, 0x14b, 0x4, 0x2, 0x124, 0x124, 0x13f, 0x13f, 0x5, 0x2, 
       0x110, 0x110, 0x15c, 0x15c, 0x15e, 0x15e, 0x3, 0x2, 0x175, 0x176, 
       0x5, 0x2, 0x14f, 0x14f, 0x17d, 0x17d, 0x191, 0x191, 0x5, 0x2, 0xd2, 
       0xd2, 0x10d, 0x10d, 0x120, 0x120, 0x4, 0x2, 0x120, 0x120, 0x18f, 
       0x18f, 0x5, 0x2, 0x50, 0x50, 0xe6, 0xe6, 0x18f, 0x18f, 0x5, 0x2, 
       0x71, 0x71, 0xed, 0xed, 0x1a8, 0x1a8, 0x4, 0x2, 0x14b, 0x14b, 0x18a, 
       0x18a, 0x4, 0x2, 0xc4, 0xc4, 0x141, 0x141, 0x3, 0x2, 0x162, 0x163, 
       0x4, 0x2, 0xb0, 0xb0, 0xc8, 0xc8, 0x3, 0x2, 0xb6, 0xb7, 0x6, 0x2, 
       0xe7, 0xe7, 0x164, 0x164, 0x18b, 0x18b, 0x1c5, 0x1c5, 0x4, 0x2, 0x121, 
       0x121, 0x188, 0x188, 0x6, 0x2, 0x10f, 0x10f, 0x117, 0x117, 0x139, 
       0x139, 0x196, 0x196, 0x5, 0x2, 0x160, 0x160, 0x175, 0x175, 0x189, 
       0x189, 0x4, 0x2, 0xd0, 0xd0, 0x17a, 0x17a, 0x4, 0x2, 0x135, 0x135, 
       0x1a6, 0x1a6, 0x3, 0x2, 0x1e2, 0x1e3, 0x3, 0x2, 0x1df, 0x1e1, 0x4, 
       0x2, 0x1e2, 0x1e3, 0x1e5, 0x1e7, 0x5, 0x2, 0xc6, 0xc6, 0x114, 0x114, 
       0x16f, 0x16f, 0x5, 0x2, 0x4, 0x4, 0x7, 0x7, 0xab, 0xab, 0x4, 0x2, 
       0x4, 0x4, 0x37, 0x37, 0x4, 0x2, 0xf8, 0xf8, 0x17f, 0x17f, 0x4, 0x2, 
       0x182, 0x182, 0x184, 0x184, 0x4, 0x2, 0x6e, 0x6e, 0x11b, 0x11b, 0x4, 
       0x2, 0x81, 0x81, 0x129, 0x129, 0x5, 0x2, 0x6c, 0x6c, 0xf1, 0xf1, 
       0x129, 0x129, 0x5, 0x2, 0x6c, 0x6c, 0x129, 0x129, 0x142, 0x142, 0x4, 
       0x2, 0x56, 0x56, 0x183, 0x183, 0x4, 0x2, 0x27, 0x27, 0x82, 0x82, 
       0x4, 0x2, 0x73, 0x73, 0x1c2, 0x1c3, 0x5, 0x2, 0x50, 0x50, 0x66, 0x66, 
       0x9a, 0x9a, 0x6, 0x2, 0x6c, 0x6c, 0x129, 0x129, 0x142, 0x142, 0x17b, 
       0x17b, 0x4, 0x2, 0x1c3, 0x1c3, 0x1c5, 0x1c5, 0x5, 0x2, 0x10a, 0x10a, 
       0x172, 0x172, 0x185, 0x185, 0x5, 0x2, 0x11c, 0x11c, 0x13c, 0x13c, 
       0x159, 0x159, 0x4, 0x2, 0x13a, 0x13a, 0x13d, 0x13d, 0x8, 0x2, 0xe2, 
       0xe2, 0x144, 0x144, 0x14a, 0x14a, 0x198, 0x199, 0x19c, 0x19c, 0x1b4, 
       0x1b5, 0x3, 0x2, 0xf6, 0xf7, 0x4, 0x2, 0x171, 0x171, 0x184, 0x184, 
       0x5, 0x2, 0x50, 0x50, 0x77, 0x77, 0x175, 0x175, 0x4, 0x2, 0x1a, 0x1a, 
       0x70, 0x70, 0x3, 0x2, 0x1c7, 0x1c8, 0x4, 0x2, 0x1c3, 0x1c3, 0x1c7, 
       0x1c7, 0x3a, 0x2, 0x4b, 0x4b, 0x6e, 0x6e, 0x75, 0x75, 0xc6, 0xc6, 
       0xd0, 0xd0, 0xd8, 0xd8, 0xdb, 0xdb, 0xe2, 0xe3, 0xe7, 0xe9, 0xee, 
       0xef, 0xf1, 0xf1, 0xf3, 0xf4, 0xf6, 0xf7, 0xfb, 0xfb, 0x107, 0x107, 
       0x109, 0x10a, 0x10c, 0x10c, 0x10f, 0x10f, 0x112, 0x112, 0x114, 0x117, 
       0x11b, 0x11c, 0x11e, 0x122, 0x124, 0x124, 0x126, 0x127, 0x129, 0x129, 
       0x12c, 0x12c, 0x12e, 0x12e, 0x132, 0x135, 0x137, 0x146, 0x14a, 0x14a, 
       0x14e, 0x14e, 0x150, 0x150, 0x153, 0x155, 0x157, 0x157, 0x159, 0x15a, 
       0x15d, 0x164, 0x166, 0x166, 0x168, 0x169, 0x16c, 0x16f, 0x171, 0x173, 
       0x175, 0x175, 0x177, 0x177, 0x17a, 0x17c, 0x17e, 0x17e, 0x180, 0x180, 
       0x182, 0x189, 0x18b, 0x18c, 0x18f, 0x18f, 0x192, 0x192, 0x194, 0x199, 
       0x19c, 0x19c, 0x1a3, 0x1a6, 0x1ab, 0x1ab, 0x1ad, 0x1b1, 0x1b3, 0x1bb, 
       0x1c4, 0x1c4, 0x3, 0x2, 0x1cd, 0x1d4, 0x7, 0x2, 0x123, 0x123, 0x136, 
       0x136, 0x148, 0x148, 0x1a2, 0x1a2, 0x1e1, 0x1e1, 0x3, 0x2, 0x8b, 
       0x8c, 0x4, 0x2, 0x162, 0x163, 0x173, 0x173, 0x4, 0x2, 0x144, 0x144, 
       0x1c3, 0x1c3, 0x2, 0x10cf, 0x2, 0x1a1, 0x3, 0x2, 0x2, 0x2, 0x4, 0x1a7, 
       0x3, 0x2, 0x2, 0x2, 0x6, 0x1b1, 0x3, 0x2, 0x2, 0x2, 0x8, 0x1bc, 0x3, 
       0x2, 0x2, 0x2, 0xa, 0x1c2, 0x3, 0x2, 0x2, 0x2, 0xc, 0x1d9, 0x3, 0x2, 
       0x2, 0x2, 0xe, 0x1df, 0x3, 0x2, 0x2, 0x2, 0x10, 0x1e8, 0x3, 0x2, 
       0x2, 0x2, 0x12, 0x1ea, 0x3, 0x2, 0x2, 0x2, 0x14, 0x1f5, 0x3, 0x2, 
       0x2, 0x2, 0x16, 0x1f9, 0x3, 0x2, 0x2, 0x2, 0x18, 0x207, 0x3, 0x2, 
       0x2, 0x2, 0x1a, 0x209, 0x3, 0x2, 0x2, 0x2, 0x1c, 0x21d, 0x3, 0x2, 
       0x2, 0x2, 0x1e, 0x21f, 0x3, 0x2, 0x2, 0x2, 0x20, 0x226, 0x3, 0x2, 
       0x2, 0x2, 0x22, 0x231, 0x3, 0x2, 0x2, 0x2, 0x24, 0x24b, 0x3, 0x2, 
       0x2, 0x2, 0x26, 0x251, 0x3, 0x2, 0x2, 0x2, 0x28, 0x25e, 0x3, 0x2, 
       0x2, 0x2, 0x2a, 0x263, 0x3, 0x2, 0x2, 0x2, 0x2c, 0x27b, 0x3, 0x2, 
       0x2, 0x2, 0x2e, 0x27e, 0x3, 0x2, 0x2, 0x2, 0x30, 0x2a5, 0x3, 0x2, 
       0x2, 0x2, 0x32, 0x2a8, 0x3, 0x2, 0x2, 0x2, 0x34, 0x2d4, 0x3, 0x2, 
       0x2, 0x2, 0x36, 0x2d7, 0x3, 0x2, 0x2, 0x2, 0x38, 0x2e7, 0x3, 0x2, 
       0x2, 0x2, 0x3a, 0x310, 0x3, 0x2, 0x2, 0x2, 0x3c, 0x31d, 0x3, 0x2, 
       0x2, 0x2, 0x3e, 0x335, 0x3, 0x2, 0x2, 0x2, 0x40, 0x348, 0x3, 0x2, 
       0x2, 0x2, 0x42, 0x34a, 0x3, 0x2, 0x2, 0x2, 0x44, 0x37b, 0x3, 0x2, 
       0x2, 0x2, 0x46, 0x3a4, 0x3, 0x2, 0x2, 0x2, 0x48, 0x3c3, 0x3, 0x2, 
       0x2, 0x2, 0x4a, 0x3d9, 0x3, 0x2, 0x2, 0x2, 0x4c, 0x3df, 0x3, 0x2, 
       0x2, 0x2, 0x4e, 0x3e7, 0x3, 0x2, 0x2, 0x2, 0x50, 0x405, 0x3, 0x2, 
       0x2, 0x2, 0x52, 0x407, 0x3, 0x2, 0x2, 0x2, 0x54, 0x430, 0x3, 0x2, 
       0x2, 0x2, 0x56, 0x45d, 0x3, 0x2, 0x2, 0x2, 0x58, 0x470, 0x3, 0x2, 
       0x2, 0x2, 0x5a, 0x472, 0x3, 0x2, 0x2, 0x2, 0x5c, 0x48b, 0x3, 0x2, 
       0x2, 0x2, 0x5e, 0x48d, 0x3, 0x2, 0x2, 0x2, 0x60, 0x495, 0x3, 0x2, 
       0x2, 0x2, 0x62, 0x497, 0x3, 0x2, 0x2, 0x2, 0x64, 0x49a, 0x3, 0x2, 
       0x2, 0x2, 0x66, 0x49d, 0x3, 0x2, 0x2, 0x2, 0x68, 0x49f, 0x3, 0x2, 
       0x2, 0x2, 0x6a, 0x4a1, 0x3, 0x2, 0x2, 0x2, 0x6c, 0x4a3, 0x3, 0x2, 
       0x2, 0x2, 0x6e, 0x4c0, 0x3, 0x2, 0x2, 0x2, 0x70, 0x4c2, 0x3, 0x2, 
       0x2, 0x2, 0x72, 0x4c7, 0x3, 0x2, 0x2, 0x2, 0x74, 0x4ca, 0x3, 0x2, 
       0x2, 0x2, 0x76, 0x4d3, 0x3, 0x2, 0x2, 0x2, 0x78, 0x4db, 0x3, 0x2, 
       0x2, 0x2, 0x7a, 0x4e2, 0x3, 0x2, 0x2, 0x2, 0x7c, 0x4f9, 0x3, 0x2, 
       0x2, 0x2, 0x7e, 0x4fb, 0x3, 0x2, 0x2, 0x2, 0x80, 0x506, 0x3, 0x2, 
       0x2, 0x2, 0x82, 0x508, 0x3, 0x2, 0x2, 0x2, 0x84, 0x516, 0x3, 0x2, 
       0x2, 0x2, 0x86, 0x520, 0x3, 0x2, 0x2, 0x2, 0x88, 0x52a, 0x3, 0x2, 
       0x2, 0x2, 0x8a, 0x534, 0x3, 0x2, 0x2, 0x2, 0x8c, 0x541, 0x3, 0x2, 
       0x2, 0x2, 0x8e, 0x54b, 0x3, 0x2, 0x2, 0x2, 0x90, 0x55c, 0x3, 0x2, 
       0x2, 0x2, 0x92, 0x566, 0x3, 0x2, 0x2, 0x2, 0x94, 0x56d, 0x3, 0x2, 
       0x2, 0x2, 0x96, 0x577, 0x3, 0x2, 0x2, 0x2, 0x98, 0x579, 0x3, 0x2, 
       0x2, 0x2, 0x9a, 0x580, 0x3, 0x2, 0x2, 0x2, 0x9c, 0x5a6, 0x3, 0x2, 
       0x2, 0x2, 0x9e, 0x5c2, 0x3, 0x2, 0x2, 0x2, 0xa0, 0x5ed, 0x3, 0x2, 
       0x2, 0x2, 0xa2, 0x5f1, 0x3, 0x2, 0x2, 0x2, 0xa4, 0x5fe, 0x3, 0x2, 
       0x2, 0x2, 0xa6, 0x630, 0x3, 0x2, 0x2, 0x2, 0xa8, 0x64c, 0x3, 0x2, 
       0x2, 0x2, 0xaa, 0x675, 0x3, 0x2, 0x2, 0x2, 0xac, 0x6c4, 0x3, 0x2, 
       0x2, 0x2, 0xae, 0x6c6, 0x3, 0x2, 0x2, 0x2, 0xb0, 0x6ca, 0x3, 0x2, 
       0x2, 0x2, 0xb2, 0x6cf, 0x3, 0x2, 0x2, 0x2, 0xb4, 0x6d3, 0x3, 0x2, 
       0x2, 0x2, 0xb6, 0x6dc, 0x3, 0x2, 0x2, 0x2, 0xb8, 0x6e1, 0x3, 0x2, 
       0x2, 0x2, 0xba, 0x6ed, 0x3, 0x2, 0x2, 0x2, 0xbc, 0x6ef, 0x3, 0x2, 
       0x2, 0x2, 0xbe, 0x720, 0x3, 0x2, 0x2, 0x2, 0xc0, 0x73e, 0x3, 0x2, 
       0x2, 0x2, 0xc2, 0x776, 0x3, 0x2, 0x2, 0x2, 0xc4, 0x782, 0x3, 0x2, 
       0x2, 0x2, 0xc6, 0x789, 0x3, 0x2, 0x2, 0x2, 0xc8, 0x7b0, 0x3, 0x2, 
       0x2, 0x2, 0xca, 0x7c1, 0x3, 0x2, 0x2, 0x2, 0xcc, 0x80e, 0x3, 0x2, 
       0x2, 0x2, 0xce, 0x812, 0x3, 0x2, 0x2, 0x2, 0xd0, 0x843, 0x3, 0x2, 
       0x2, 0x2, 0xd2, 0x872, 0x3, 0x2, 0x2, 0x2, 0xd4, 0x874, 0x3, 0x2, 
       0x2, 0x2, 0xd6, 0x87e, 0x3, 0x2, 0x2, 0x2, 0xd8, 0x880, 0x3, 0x2, 
       0x2, 0x2, 0xda, 0x882, 0x3, 0x2, 0x2, 0x2, 0xdc, 0x88f, 0x3, 0x2, 
       0x2, 0x2, 0xde, 0x8ab, 0x3, 0x2, 0x2, 0x2, 0xe0, 0x8ad, 0x3, 0x2, 
       0x2, 0x2, 0xe2, 0x8b5, 0x3, 0x2, 0x2, 0x2, 0xe4, 0x8fd, 0x3, 0x2, 
       0x2, 0x2, 0xe6, 0x905, 0x3, 0x2, 0x2, 0x2, 0xe8, 0x916, 0x3, 0x2, 
       0x2, 0x2, 0xea, 0x91f, 0x3, 0x2, 0x2, 0x2, 0xec, 0x921, 0x3, 0x2, 
       0x2, 0x2, 0xee, 0x954, 0x3, 0x2, 0x2, 0x2, 0xf0, 0x971, 0x3, 0x2, 
       0x2, 0x2, 0xf2, 0x973, 0x3, 0x2, 0x2, 0x2, 0xf4, 0x97c, 0x3, 0x2, 
       0x2, 0x2, 0xf6, 0x983, 0x3, 0x2, 0x2, 0x2, 0xf8, 0x995, 0x3, 0x2, 
       0x2, 0x2, 0xfa, 0x9ae, 0x3, 0x2, 0x2, 0x2, 0xfc, 0x9b0, 0x3, 0x2, 
       0x2, 0x2, 0xfe, 0x9b7, 0x3, 0x2, 0x2, 0x2, 0x100, 0x9bb, 0x3, 0x2, 
       0x2, 0x2, 0x102, 0x9bd, 0x3, 0x2, 0x2, 0x2, 0x104, 0x9f6, 0x3, 0x2, 
       0x2, 0x2, 0x106, 0x9f8, 0x3, 0x2, 0x2, 0x2, 0x108, 0x9fe, 0x3, 0x2, 
       0x2, 0x2, 0x10a, 0xa1b, 0x3, 0x2, 0x2, 0x2, 0x10c, 0xa1d, 0x3, 0x2, 
       0x2, 0x2, 0x10e, 0xa2b, 0x3, 0x2, 0x2, 0x2, 0x110, 0xa6b, 0x3, 0x2, 
       0x2, 0x2, 0x112, 0xa6d, 0x3, 0x2, 0x2, 0x2, 0x114, 0xa7b, 0x3, 0x2, 
       0x2, 0x2, 0x116, 0xa7d, 0x3, 0x2, 0x2, 0x2, 0x118, 0xa80, 0x3, 0x2, 
       0x2, 0x2, 0x11a, 0xa84, 0x3, 0x2, 0x2, 0x2, 0x11c, 0xa93, 0x3, 0x2, 
       0x2, 0x2, 0x11e, 0xa98, 0x3, 0x2, 0x2, 0x2, 0x120, 0xab6, 0x3, 0x2, 
       0x2, 0x2, 0x122, 0xab8, 0x3, 0x2, 0x2, 0x2, 0x124, 0xac7, 0x3, 0x2, 
       0x2, 0x2, 0x126, 0xb76, 0x3, 0x2, 0x2, 0x2, 0x128, 0xb78, 0x3, 0x2, 
       0x2, 0x2, 0x12a, 0xb7d, 0x3, 0x2, 0x2, 0x2, 0x12c, 0xb83, 0x3, 0x2, 
       0x2, 0x2, 0x12e, 0xb90, 0x3, 0x2, 0x2, 0x2, 0x130, 0xb9d, 0x3, 0x2, 
       0x2, 0x2, 0x132, 0xbc9, 0x3, 0x2, 0x2, 0x2, 0x134, 0xbcb, 0x3, 0x2, 
       0x2, 0x2, 0x136, 0xbd8, 0x3, 0x2, 0x2, 0x2, 0x138, 0xbda, 0x3, 0x2, 
       0x2, 0x2, 0x13a, 0xbdc, 0x3, 0x2, 0x2, 0x2, 0x13c, 0xbe5, 0x3, 0x2, 
       0x2, 0x2, 0x13e, 0xbed, 0x3, 0x2, 0x2, 0x2, 0x140, 0xbf1, 0x3, 0x2, 
       0x2, 0x2, 0x142, 0xbf5, 0x3, 0x2, 0x2, 0x2, 0x144, 0xc10, 0x3, 0x2, 
       0x2, 0x2, 0x146, 0xc3b, 0x3, 0x2, 0x2, 0x2, 0x148, 0xc3d, 0x3, 0x2, 
       0x2, 0x2, 0x14a, 0xc3f, 0x3, 0x2, 0x2, 0x2, 0x14c, 0xc4e, 0x3, 0x2, 
       0x2, 0x2, 0x14e, 0xc57, 0x3, 0x2, 0x2, 0x2, 0x150, 0xc5b, 0x3, 0x2, 
       0x2, 0x2, 0x152, 0xc63, 0x3, 0x2, 0x2, 0x2, 0x154, 0xc69, 0x3, 0x2, 
       0x2, 0x2, 0x156, 0xc8d, 0x3, 0x2, 0x2, 0x2, 0x158, 0xc8f, 0x3, 0x2, 
       0x2, 0x2, 0x15a, 0xc9c, 0x3, 0x2, 0x2, 0x2, 0x15c, 0xc9e, 0x3, 0x2, 
       0x2, 0x2, 0x15e, 0xcb3, 0x3, 0x2, 0x2, 0x2, 0x160, 0xcf1, 0x3, 0x2, 
       0x2, 0x2, 0x162, 0xcff, 0x3, 0x2, 0x2, 0x2, 0x164, 0xd06, 0x3, 0x2, 
       0x2, 0x2, 0x166, 0xd14, 0x3, 0x2, 0x2, 0x2, 0x168, 0xd1a, 0x3, 0x2, 
       0x2, 0x2, 0x16a, 0xd1f, 0x3, 0x2, 0x2, 0x2, 0x16c, 0xd23, 0x3, 0x2, 
       0x2, 0x2, 0x16e, 0xd2d, 0x3, 0x2, 0x2, 0x2, 0x170, 0xd2f, 0x3, 0x2, 
       0x2, 0x2, 0x172, 0xd31, 0x3, 0x2, 0x2, 0x2, 0x174, 0xd34, 0x3, 0x2, 
       0x2, 0x2, 0x176, 0xd4a, 0x3, 0x2, 0x2, 0x2, 0x178, 0xd4e, 0x3, 0x2, 
       0x2, 0x2, 0x17a, 0xd5f, 0x3, 0x2, 0x2, 0x2, 0x17c, 0xd61, 0x3, 0x2, 
       0x2, 0x2, 0x17e, 0xd66, 0x3, 0x2, 0x2, 0x2, 0x180, 0xd68, 0x3, 0x2, 
       0x2, 0x2, 0x182, 0xd79, 0x3, 0x2, 0x2, 0x2, 0x184, 0xd7b, 0x3, 0x2, 
       0x2, 0x2, 0x186, 0xd7d, 0x3, 0x2, 0x2, 0x2, 0x188, 0xd87, 0x3, 0x2, 
       0x2, 0x2, 0x18a, 0xdb7, 0x3, 0x2, 0x2, 0x2, 0x18c, 0xdd2, 0x3, 0x2, 
       0x2, 0x2, 0x18e, 0xdea, 0x3, 0x2, 0x2, 0x2, 0x190, 0xe0a, 0x3, 0x2, 
       0x2, 0x2, 0x192, 0xe28, 0x3, 0x2, 0x2, 0x2, 0x194, 0xe3f, 0x3, 0x2, 
       0x2, 0x2, 0x196, 0xe4d, 0x3, 0x2, 0x2, 0x2, 0x198, 0xe4f, 0x3, 0x2, 
       0x2, 0x2, 0x19a, 0xe5a, 0x3, 0x2, 0x2, 0x2, 0x19c, 0xe80, 0x3, 0x2, 
       0x2, 0x2, 0x19e, 0x1a0, 0x5, 0x4, 0x3, 0x2, 0x19f, 0x19e, 0x3, 0x2, 
       0x2, 0x2, 0x1a0, 0x1a3, 0x3, 0x2, 0x2, 0x2, 0x1a1, 0x19f, 0x3, 0x2, 
       0x2, 0x2, 0x1a1, 0x1a2, 0x3, 0x2, 0x2, 0x2, 0x1a2, 0x1a4, 0x3, 0x2, 
       0x2, 0x2, 0x1a3, 0x1a1, 0x3, 0x2, 0x2, 0x2, 0x1a4, 0x1a5, 0x7, 0x2, 
       0x2, 0x3, 0x1a5, 0x3, 0x3, 0x2, 0x2, 0x2, 0x1a6, 0x1a8, 0x5, 0xae, 
       0x58, 0x2, 0x1a7, 0x1a6, 0x3, 0x2, 0x2, 0x2, 0x1a7, 0x1a8, 0x3, 0x2, 
       0x2, 0x2, 0x1a8, 0x1a9, 0x3, 0x2, 0x2, 0x2, 0x1a9, 0x1ab, 0x5, 0x6, 
       0x4, 0x2, 0x1aa, 0x1ac, 0x5, 0xae, 0x58, 0x2, 0x1ab, 0x1aa, 0x3, 
       0x2, 0x2, 0x2, 0x1ab, 0x1ac, 0x3, 0x2, 0x2, 0x2, 0x1ac, 0x5, 0x3, 
       0x2, 0x2, 0x2, 0x1ad, 0x1af, 0x5, 0x8, 0x5, 0x2, 0x1ae, 0x1b0, 0x7, 
       0x1dd, 0x2, 0x2, 0x1af, 0x1ae, 0x3, 0x2, 0x2, 0x2, 0x1af, 0x1b0, 
       0x3, 0x2, 0x2, 0x2, 0x1b0, 0x1b2, 0x3, 0x2, 0x2, 0x2, 0x1b1, 0x1ad, 
       0x3, 0x2, 0x2, 0x2, 0x1b2, 0x1b3, 0x3, 0x2, 0x2, 0x2, 0x1b3, 0x1b1, 
       0x3, 0x2, 0x2, 0x2, 0x1b3, 0x1b4, 0x3, 0x2, 0x2, 0x2, 0x1b4, 0x7, 
       0x3, 0x2, 0x2, 0x2, 0x1b5, 0x1bd, 0x5, 0xa, 0x6, 0x2, 0x1b6, 0x1bd, 
       0x5, 0xc, 0x7, 0x2, 0x1b7, 0x1bd, 0x5, 0xe, 0x8, 0x2, 0x1b8, 0x1bd, 
       0x5, 0x2c, 0x17, 0x2, 0x1b9, 0x1bd, 0x5, 0x10, 0x9, 0x2, 0x1ba, 0x1bd, 
       0x5, 0x9c, 0x4f, 0x2, 0x1bb, 0x1bd, 0x5, 0x28, 0x15, 0x2, 0x1bc, 
       0x1b5, 0x3, 0x2, 0x2, 0x2, 0x1bc, 0x1b6, 0x3, 0x2, 0x2, 0x2, 0x1bc, 
       0x1b7, 0x3, 0x2, 0x2, 0x2, 0x1bc, 0x1b8, 0x3, 0x2, 0x2, 0x2, 0x1bc, 
       0x1b9, 0x3, 0x2, 0x2, 0x2, 0x1bc, 0x1ba, 0x3, 0x2, 0x2, 0x2, 0x1bc, 
       0x1bb, 0x3, 0x2, 0x2, 0x2, 0x1bd, 0x9, 0x3, 0x2, 0x2, 0x2, 0x1be, 
       0x1c3, 0x5, 0x2e, 0x18, 0x2, 0x1bf, 0x1c3, 0x5, 0x32, 0x1a, 0x2, 
       0x1c0, 0x1c3, 0x5, 0x36, 0x1c, 0x2, 0x1c1, 0x1c3, 0x5, 0x38, 0x1d, 
       0x2, 0x1c2, 0x1be, 0x3, 0x2, 0x2, 0x2, 0x1c2, 0x1bf, 0x3, 0x2, 0x2, 
       0x2, 0x1c2, 0x1c0, 0x3, 0x2, 0x2, 0x2, 0x1c2, 0x1c1, 0x3, 0x2, 0x2, 
       0x2, 0x1c3, 0xb, 0x3, 0x2, 0x2, 0x2, 0x1c4, 0x1da, 0x5, 0x42, 0x22, 
       0x2, 0x1c5, 0x1da, 0x5, 0x44, 0x23, 0x2, 0x1c6, 0x1da, 0x5, 0x18a, 
       0xc6, 0x2, 0x1c7, 0x1da, 0x5, 0x188, 0xc5, 0x2, 0x1c8, 0x1da, 0x5, 
       0x46, 0x24, 0x2, 0x1c9, 0x1da, 0x5, 0x4a, 0x26, 0x2, 0x1ca, 0x1da, 
       0x5, 0x4c, 0x27, 0x2, 0x1cb, 0x1da, 0x5, 0x48, 0x25, 0x2, 0x1cc, 
       0x1da, 0x5, 0x92, 0x4a, 0x2, 0x1cd, 0x1da, 0x5, 0x4e, 0x28, 0x2, 
       0x1ce, 0x1da, 0x5, 0x52, 0x2a, 0x2, 0x1cf, 0x1da, 0x5, 0x54, 0x2b, 
       0x2, 0x1d0, 0x1da, 0x5, 0x82, 0x42, 0x2, 0x1d1, 0x1da, 0x5, 0x84, 
       0x43, 0x2, 0x1d2, 0x1da, 0x5, 0x86, 0x44, 0x2, 0x1d3, 0x1da, 0x5, 
       0x8c, 0x47, 0x2, 0x1d4, 0x1da, 0x5, 0x88, 0x45, 0x2, 0x1d5, 0x1da, 
       0x5, 0x94, 0x4b, 0x2, 0x1d6, 0x1da, 0x5, 0x8e, 0x48, 0x2, 0x1d7, 
       0x1da, 0x5, 0x8a, 0x46, 0x2, 0x1d8, 0x1da, 0x5, 0x90, 0x49, 0x2, 
       0x1d9, 0x1c4, 0x3, 0x2, 0x2, 0x2, 0x1d9, 0x1c5, 0x3, 0x2, 0x2, 0x2, 
       0x1d9, 0x1c6, 0x3, 0x2, 0x2, 0x2, 0x1d9, 0x1c7, 0x3, 0x2, 0x2, 0x2, 
       0x1d9, 0x1c8, 0x3, 0x2, 0x2, 0x2, 0x1d9, 0x1c9, 0x3, 0x2, 0x2, 0x2, 
       0x1d9, 0x1ca, 0x3, 0x2, 0x2, 0x2, 0x1d9, 0x1cb, 0x3, 0x2, 0x2, 0x2, 
       0x1d9, 0x1cc, 0x3, 0x2, 0x2, 0x2, 0x1d9, 0x1cd, 0x3, 0x2, 0x2, 0x2, 
       0x1d9, 0x1ce, 0x3, 0x2, 0x2, 0x2, 0x1d9, 0x1cf, 0x3, 0x2, 0x2, 0x2, 
       0x1d9, 0x1d0, 0x3, 0x2, 0x2, 0x2, 0x1d9, 0x1d1, 0x3, 0x2, 0x2, 0x2, 
       0x1d9, 0x1d2, 0x3, 0x2, 0x2, 0x2, 0x1d9, 0x1d3, 0x3, 0x2, 0x2, 0x2, 
       0x1d9, 0x1d4, 0x3, 0x2, 0x2, 0x2, 0x1d9, 0x1d5, 0x3, 0x2, 0x2, 0x2, 
       0x1d9, 0x1d6, 0x3, 0x2, 0x2, 0x2, 0x1d9, 0x1d7, 0x3, 0x2, 0x2, 0x2, 
       0x1d9, 0x1d8, 0x3, 0x2, 0x2, 0x2, 0x1da, 0xd, 0x3, 0x2, 0x2, 0x2, 
       0x1db, 0x1e0, 0x5, 0x1a, 0xe, 0x2, 0x1dc, 0x1e0, 0x5, 0x22, 0x12, 
       0x2, 0x1dd, 0x1e0, 0x5, 0x24, 0x13, 0x2, 0x1de, 0x1e0, 0x5, 0x26, 
       0x14, 0x2, 0x1df, 0x1db, 0x3, 0x2, 0x2, 0x2, 0x1df, 0x1dc, 0x3, 0x2, 
       0x2, 0x2, 0x1df, 0x1dd, 0x3, 0x2, 0x2, 0x2, 0x1df, 0x1de, 0x3, 0x2, 
       0x2, 0x2, 0x1e0, 0xf, 0x3, 0x2, 0x2, 0x2, 0x1e1, 0x1e9, 0x5, 0x12, 
       0xa, 0x2, 0x1e2, 0x1e9, 0x5, 0x14, 0xb, 0x2, 0x1e3, 0x1e9, 0x5, 0x16, 
       0xc, 0x2, 0x1e4, 0x1e9, 0x5, 0x18, 0xd, 0x2, 0x1e5, 0x1e9, 0x5, 0x1e, 
       0x10, 0x2, 0x1e6, 0x1e9, 0x5, 0x20, 0x11, 0x2, 0x1e7, 0x1e9, 0x5, 
       0x2a, 0x16, 0x2, 0x1e8, 0x1e1, 0x3, 0x2, 0x2, 0x2, 0x1e8, 0x1e2, 
       0x3, 0x2, 0x2, 0x2, 0x1e8, 0x1e3, 0x3, 0x2, 0x2, 0x2, 0x1e8, 0x1e4, 
       0x3, 0x2, 0x2, 0x2, 0x1e8, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x1e8, 0x1e6, 
       0x3, 0x2, 0x2, 0x2, 0x1e8, 0x1e7, 0x3, 0x2, 0x2, 0x2, 0x1e9, 0x11, 
       0x3, 0x2, 0x2, 0x2, 0x1ea, 0x1ec, 0x7, 0xc, 0x2, 0x2, 0x1eb, 0x1ed, 
       0x7, 0x1dd, 0x2, 0x2, 0x1ec, 0x1eb, 0x3, 0x2, 0x2, 0x2, 0x1ec, 0x1ed, 
       0x3, 0x2, 0x2, 0x2, 0x1ed, 0x1ef, 0x3, 0x2, 0x2, 0x2, 0x1ee, 0x1f0, 
       0x5, 0x6, 0x4, 0x2, 0x1ef, 0x1ee, 0x3, 0x2, 0x2, 0x2, 0x1ef, 0x1f0, 
       0x3, 0x2, 0x2, 0x2, 0x1f0, 0x1f1, 0x3, 0x2, 0x2, 0x2, 0x1f1, 0x1f3, 
       0x7, 0x3d, 0x2, 0x2, 0x1f2, 0x1f4, 0x7, 0x1dd, 0x2, 0x2, 0x1f3, 0x1f2, 
       0x3, 0x2, 0x2, 0x2, 0x1f3, 0x1f4, 0x3, 0x2, 0x2, 0x2, 0x1f4, 0x13, 
       0x3, 0x2, 0x2, 0x2, 0x1f5, 0x1f7, 0x7, 0xe, 0x2, 0x2, 0x1f6, 0x1f8, 
       0x7, 0x1dd, 0x2, 0x2, 0x1f7, 0x1f6, 0x3, 0x2, 0x2, 0x2, 0x1f7, 0x1f8, 
       0x3, 0x2, 0x2, 0x2, 0x1f8, 0x15, 0x3, 0x2, 0x2, 0x2, 0x1f9, 0x1fb, 
       0x7, 0x24, 0x2, 0x2, 0x1fa, 0x1fc, 0x7, 0x1dd, 0x2, 0x2, 0x1fb, 0x1fa, 
       0x3, 0x2, 0x2, 0x2, 0x1fb, 0x1fc, 0x3, 0x2, 0x2, 0x2, 0x1fc, 0x17, 
       0x3, 0x2, 0x2, 0x2, 0x1fd, 0x1fe, 0x7, 0x52, 0x2, 0x2, 0x1fe, 0x200, 
       0x5, 0x17e, 0xc0, 0x2, 0x1ff, 0x201, 0x7, 0x1dd, 0x2, 0x2, 0x200, 
       0x1ff, 0x3, 0x2, 0x2, 0x2, 0x200, 0x201, 0x3, 0x2, 0x2, 0x2, 0x201, 
       0x208, 0x3, 0x2, 0x2, 0x2, 0x202, 0x203, 0x5, 0x17e, 0xc0, 0x2, 0x203, 
       0x205, 0x7, 0x1de, 0x2, 0x2, 0x204, 0x206, 0x7, 0x1dd, 0x2, 0x2, 
       0x205, 0x204, 0x3, 0x2, 0x2, 0x2, 0x205, 0x206, 0x3, 0x2, 0x2, 0x2, 
       0x206, 0x208, 0x3, 0x2, 0x2, 0x2, 0x207, 0x1fd, 0x3, 0x2, 0x2, 0x2, 
       0x207, 0x202, 0x3, 0x2, 0x2, 0x2, 0x208, 0x19, 0x3, 0x2, 0x2, 0x2, 
       0x209, 0x20a, 0x7, 0x5a, 0x2, 0x2, 0x20a, 0x20b, 0x5, 0xe2, 0x72, 
       0x2, 0x20b, 0x20c, 0x5, 0x1c, 0xf, 0x2, 0x20c, 0x1b, 0x3, 0x2, 0x2, 
       0x2, 0x20d, 0x210, 0x5, 0x8, 0x5, 0x2, 0x20e, 0x20f, 0x7, 0x3c, 0x2, 
       0x2, 0x20f, 0x211, 0x5, 0x8, 0x5, 0x2, 0x210, 0x20e, 0x3, 0x2, 0x2, 
       0x2, 0x210, 0x211, 0x3, 0x2, 0x2, 0x2, 0x211, 0x213, 0x3, 0x2, 0x2, 
       0x2, 0x212, 0x214, 0x7, 0x1dd, 0x2, 0x2, 0x213, 0x212, 0x3, 0x2, 
       0x2, 0x2, 0x213, 0x214, 0x3, 0x2, 0x2, 0x2, 0x214, 0x21e, 0x3, 0x2, 
       0x2, 0x2, 0x215, 0x218, 0x5, 0x12, 0xa, 0x2, 0x216, 0x217, 0x7, 0x3c, 
       0x2, 0x2, 0x217, 0x219, 0x5, 0x12, 0xa, 0x2, 0x218, 0x216, 0x3, 0x2, 
       0x2, 0x2, 0x218, 0x219, 0x3, 0x2, 0x2, 0x2, 0x219, 0x21b, 0x3, 0x2, 
       0x2, 0x2, 0x21a, 0x21c, 0x7, 0x1dd, 0x2, 0x2, 0x21b, 0x21a, 0x3, 
       0x2, 0x2, 0x2, 0x21b, 0x21c, 0x3, 0x2, 0x2, 0x2, 0x21c, 0x21e, 0x3, 
       0x2, 0x2, 0x2, 0x21d, 0x20d, 0x3, 0x2, 0x2, 0x2, 0x21d, 0x215, 0x3, 
       0x2, 0x2, 0x2, 0x21e, 0x1d, 0x3, 0x2, 0x2, 0x2, 0x21f, 0x221, 0x7, 
       0x96, 0x2, 0x2, 0x220, 0x222, 0x5, 0xd0, 0x69, 0x2, 0x221, 0x220, 
       0x3, 0x2, 0x2, 0x2, 0x221, 0x222, 0x3, 0x2, 0x2, 0x2, 0x222, 0x224, 
       0x3, 0x2, 0x2, 0x2, 0x223, 0x225, 0x7, 0x1dd, 0x2, 0x2, 0x224, 0x223, 
       0x3, 0x2, 0x2, 0x2, 0x224, 0x225, 0x3, 0x2, 0x2, 0x2, 0x225, 0x1f, 
       0x3, 0x2, 0x2, 0x2, 0x226, 0x22c, 0x7, 0x1a4, 0x2, 0x2, 0x227, 0x228, 
       0x9, 0x2, 0x2, 0x2, 0x228, 0x229, 0x7, 0x1dc, 0x2, 0x2, 0x229, 0x22a, 
       0x9, 0x3, 0x2, 0x2, 0x22a, 0x22b, 0x7, 0x1dc, 0x2, 0x2, 0x22b, 0x22d, 
       0x9, 0x2, 0x2, 0x2, 0x22c, 0x227, 0x3, 0x2, 0x2, 0x2, 0x22c, 0x22d, 
       0x3, 0x2, 0x2, 0x2, 0x22d, 0x22f, 0x3, 0x2, 0x2, 0x2, 0x22e, 0x230, 
       0x7, 0x1dd, 0x2, 0x2, 0x22f, 0x22e, 0x3, 0x2, 0x2, 0x2, 0x22f, 0x230, 
       0x3, 0x2, 0x2, 0x2, 0x230, 0x21, 0x3, 0x2, 0x2, 0x2, 0x231, 0x232, 
       0x7, 0xc, 0x2, 0x2, 0x232, 0x234, 0x7, 0x1ab, 0x2, 0x2, 0x233, 0x235, 
       0x7, 0x1dd, 0x2, 0x2, 0x234, 0x233, 0x3, 0x2, 0x2, 0x2, 0x234, 0x235, 
       0x3, 0x2, 0x2, 0x2, 0x235, 0x237, 0x3, 0x2, 0x2, 0x2, 0x236, 0x238, 
       0x5, 0x6, 0x4, 0x2, 0x237, 0x236, 0x3, 0x2, 0x2, 0x2, 0x237, 0x238, 
       0x3, 0x2, 0x2, 0x2, 0x238, 0x239, 0x3, 0x2, 0x2, 0x2, 0x239, 0x23a, 
       0x7, 0x3d, 0x2, 0x2, 0x23a, 0x23c, 0x7, 0x1ab, 0x2, 0x2, 0x23b, 0x23d, 
       0x7, 0x1dd, 0x2, 0x2, 0x23c, 0x23b, 0x3, 0x2, 0x2, 0x2, 0x23c, 0x23d, 
       0x3, 0x2, 0x2, 0x2, 0x23d, 0x23e, 0x3, 0x2, 0x2, 0x2, 0x23e, 0x23f, 
       0x7, 0xc, 0x2, 0x2, 0x23f, 0x241, 0x7, 0xe9, 0x2, 0x2, 0x240, 0x242, 
       0x7, 0x1dd, 0x2, 0x2, 0x241, 0x240, 0x3, 0x2, 0x2, 0x2, 0x241, 0x242, 
       0x3, 0x2, 0x2, 0x2, 0x242, 0x244, 0x3, 0x2, 0x2, 0x2, 0x243, 0x245, 
       0x5, 0x6, 0x4, 0x2, 0x244, 0x243, 0x3, 0x2, 0x2, 0x2, 0x244, 0x245, 
       0x3, 0x2, 0x2, 0x2, 0x245, 0x246, 0x3, 0x2, 0x2, 0x2, 0x246, 0x247, 
       0x7, 0x3d, 0x2, 0x2, 0x247, 0x249, 0x7, 0xe9, 0x2, 0x2, 0x248, 0x24a, 
       0x7, 0x1dd, 0x2, 0x2, 0x249, 0x248, 0x3, 0x2, 0x2, 0x2, 0x249, 0x24a, 
       0x3, 0x2, 0x2, 0x2, 0x24a, 0x23, 0x3, 0x2, 0x2, 0x2, 0x24b, 0x24c, 
       0x7, 0xc9, 0x2, 0x2, 0x24c, 0x24d, 0x9, 0x4, 0x2, 0x2, 0x24d, 0x24f, 
       0x5, 0xd0, 0x69, 0x2, 0x24e, 0x250, 0x7, 0x1dd, 0x2, 0x2, 0x24f, 
       0x24e, 0x3, 0x2, 0x2, 0x2, 0x24f, 0x250, 0x3, 0x2, 0x2, 0x2, 0x250, 
       0x25, 0x3, 0x2, 0x2, 0x2, 0x251, 0x252, 0x7, 0xcc, 0x2, 0x2, 0x252, 
       0x25c, 0x5, 0xe2, 0x72, 0x2, 0x253, 0x25d, 0x5, 0x8, 0x5, 0x2, 0x254, 
       0x256, 0x7, 0xe, 0x2, 0x2, 0x255, 0x257, 0x7, 0x1dd, 0x2, 0x2, 0x256, 
       0x255, 0x3, 0x2, 0x2, 0x2, 0x256, 0x257, 0x3, 0x2, 0x2, 0x2, 0x257, 
       0x25d, 0x3, 0x2, 0x2, 0x2, 0x258, 0x25a, 0x7, 0x24, 0x2, 0x2, 0x259, 
       0x25b, 0x7, 0x1dd, 0x2, 0x2, 0x25a, 0x259, 0x3, 0x2, 0x2, 0x2, 0x25a, 
       0x25b, 0x3, 0x2, 0x2, 0x2, 0x25b, 0x25d, 0x3, 0x2, 0x2, 0x2, 0x25c, 
       0x253, 0x3, 0x2, 0x2, 0x2, 0x25c, 0x254, 0x3, 0x2, 0x2, 0x2, 0x25c, 
       0x258, 0x3, 0x2, 0x2, 0x2, 0x25d, 0x27, 0x3, 0x2, 0x2, 0x2, 0x25e, 
       0x25f, 0x7, 0x8a, 0x2, 0x2, 0x25f, 0x261, 0x5, 0xd0, 0x69, 0x2, 0x260, 
       0x262, 0x7, 0x1dd, 0x2, 0x2, 0x261, 0x260, 0x3, 0x2, 0x2, 0x2, 0x261, 
       0x262, 0x3, 0x2, 0x2, 0x2, 0x262, 0x29, 0x3, 0x2, 0x2, 0x2, 0x263, 
       0x264, 0x7, 0x8e, 0x2, 0x2, 0x264, 0x265, 0x7, 0x1da, 0x2, 0x2, 0x265, 
       0x266, 0x9, 0x5, 0x2, 0x2, 0x266, 0x267, 0x7, 0x1dc, 0x2, 0x2, 0x267, 
       0x268, 0x5, 0xce, 0x68, 0x2, 0x268, 0x269, 0x7, 0x1dc, 0x2, 0x2, 
       0x269, 0x26e, 0x5, 0xce, 0x68, 0x2, 0x26a, 0x26b, 0x7, 0x1dc, 0x2, 
       0x2, 0x26b, 0x26d, 0x5, 0xce, 0x68, 0x2, 0x26c, 0x26a, 0x3, 0x2, 
       0x2, 0x2, 0x26d, 0x270, 0x3, 0x2, 0x2, 0x2, 0x26e, 0x26c, 0x3, 0x2, 
       0x2, 0x2, 0x26e, 0x26f, 0x3, 0x2, 0x2, 0x2, 0x26f, 0x271, 0x3, 0x2, 
       0x2, 0x2, 0x270, 0x26e, 0x3, 0x2, 0x2, 0x2, 0x271, 0x273, 0x7, 0x1db, 
       0x2, 0x2, 0x272, 0x274, 0x7, 0x1dd, 0x2, 0x2, 0x273, 0x272, 0x3, 
       0x2, 0x2, 0x2, 0x273, 0x274, 0x3, 0x2, 0x2, 0x2, 0x274, 0x2b, 0x3, 
       0x2, 0x2, 0x2, 0x275, 0x27c, 0x5, 0x9e, 0x50, 0x2, 0x276, 0x27c, 
       0x5, 0xa0, 0x51, 0x2, 0x277, 0x27c, 0x5, 0xa6, 0x54, 0x2, 0x278, 
       0x27c, 0x5, 0xaa, 0x56, 0x2, 0x279, 0x27c, 0x5, 0xac, 0x57, 0x2, 
       0x27a, 0x27c, 0x5, 0xb0, 0x59, 0x2, 0x27b, 0x275, 0x3, 0x2, 0x2, 
       0x2, 0x27b, 0x276, 0x3, 0x2, 0x2, 0x2, 0x27b, 0x277, 0x3, 0x2, 0x2, 
       0x2, 0x27b, 0x278, 0x3, 0x2, 0x2, 0x2, 0x27b, 0x279, 0x3, 0x2, 0x2, 
       0x2, 0x27b, 0x27a, 0x3, 0x2, 0x2, 0x2, 0x27c, 0x2d, 0x3, 0x2, 0x2, 
       0x2, 0x27d, 0x27f, 0x5, 0xda, 0x6e, 0x2, 0x27e, 0x27d, 0x3, 0x2, 
       0x2, 0x2, 0x27e, 0x27f, 0x3, 0x2, 0x2, 0x2, 0x27f, 0x280, 0x3, 0x2, 
       0x2, 0x2, 0x280, 0x282, 0x7, 0x33, 0x2, 0x2, 0x281, 0x283, 0x5, 0xf4, 
       0x7b, 0x2, 0x282, 0x281, 0x3, 0x2, 0x2, 0x2, 0x282, 0x283, 0x3, 0x2, 
       0x2, 0x2, 0x283, 0x285, 0x3, 0x2, 0x2, 0x2, 0x284, 0x286, 0x7, 0x4f, 
       0x2, 0x2, 0x285, 0x284, 0x3, 0x2, 0x2, 0x2, 0x285, 0x286, 0x3, 0x2, 
       0x2, 0x2, 0x286, 0x287, 0x3, 0x2, 0x2, 0x2, 0x287, 0x289, 0x5, 0x30, 
       0x19, 0x2, 0x288, 0x28a, 0x5, 0x12e, 0x98, 0x2, 0x289, 0x288, 0x3, 
       0x2, 0x2, 0x2, 0x289, 0x28a, 0x3, 0x2, 0x2, 0x2, 0x28a, 0x28c, 0x3, 
       0x2, 0x2, 0x2, 0x28b, 0x28d, 0x5, 0x3c, 0x1f, 0x2, 0x28c, 0x28b, 
       0x3, 0x2, 0x2, 0x2, 0x28c, 0x28d, 0x3, 0x2, 0x2, 0x2, 0x28d, 0x290, 
       0x3, 0x2, 0x2, 0x2, 0x28e, 0x28f, 0x7, 0x4f, 0x2, 0x2, 0x28f, 0x291, 
       0x5, 0x10c, 0x87, 0x2, 0x290, 0x28e, 0x3, 0x2, 0x2, 0x2, 0x290, 0x291, 
       0x3, 0x2, 0x2, 0x2, 0x291, 0x293, 0x3, 0x2, 0x2, 0x2, 0x292, 0x294, 
       0x5, 0x3a, 0x1e, 0x2, 0x293, 0x292, 0x3, 0x2, 0x2, 0x2, 0x293, 0x294, 
       0x3, 0x2, 0x2, 0x2, 0x294, 0x296, 0x3, 0x2, 0x2, 0x2, 0x295, 0x297, 
       0x5, 0xfa, 0x7e, 0x2, 0x296, 0x295, 0x3, 0x2, 0x2, 0x2, 0x296, 0x297, 
       0x3, 0x2, 0x2, 0x2, 0x297, 0x299, 0x3, 0x2, 0x2, 0x2, 0x298, 0x29a, 
       0x5, 0x102, 0x82, 0x2, 0x299, 0x298, 0x3, 0x2, 0x2, 0x2, 0x299, 0x29a, 
       0x3, 0x2, 0x2, 0x2, 0x29a, 0x29c, 0x3, 0x2, 0x2, 0x2, 0x29b, 0x29d, 
       0x7, 0x1dd, 0x2, 0x2, 0x29c, 0x29b, 0x3, 0x2, 0x2, 0x2, 0x29c, 0x29d, 
       0x3, 0x2, 0x2, 0x2, 0x29d, 0x2f, 0x3, 0x2, 0x2, 0x2, 0x29e, 0x2a0, 
       0x5, 0x17e, 0xc0, 0x2, 0x29f, 0x2a1, 0x5, 0x12c, 0x97, 0x2, 0x2a0, 
       0x29f, 0x3, 0x2, 0x2, 0x2, 0x2a0, 0x2a1, 0x3, 0x2, 0x2, 0x2, 0x2a1, 
       0x2a6, 0x3, 0x2, 0x2, 0x2, 0x2a2, 0x2a6, 0x5, 0x168, 0xb5, 0x2, 0x2a3, 
       0x2a6, 0x5, 0x96, 0x4c, 0x2, 0x2a4, 0x2a6, 0x7, 0x1c2, 0x2, 0x2, 
       0x2a5, 0x29e, 0x3, 0x2, 0x2, 0x2, 0x2a5, 0x2a2, 0x3, 0x2, 0x2, 0x2, 
       0x2a5, 0x2a3, 0x3, 0x2, 0x2, 0x2, 0x2a5, 0x2a4, 0x3, 0x2, 0x2, 0x2, 
       0x2a6, 0x31, 0x3, 0x2, 0x2, 0x2, 0x2a7, 0x2a9, 0x5, 0xda, 0x6e, 0x2, 
       0x2a8, 0x2a7, 0x3, 0x2, 0x2, 0x2, 0x2a8, 0x2a9, 0x3, 0x2, 0x2, 0x2, 
       0x2a9, 0x2aa, 0x3, 0x2, 0x2, 0x2, 0x2aa, 0x2ac, 0x7, 0x5f, 0x2, 0x2, 
       0x2ab, 0x2ad, 0x5, 0xf4, 0x7b, 0x2, 0x2ac, 0x2ab, 0x3, 0x2, 0x2, 
       0x2, 0x2ac, 0x2ad, 0x3, 0x2, 0x2, 0x2, 0x2ad, 0x2af, 0x3, 0x2, 0x2, 
       0x2, 0x2ae, 0x2b0, 0x7, 0x61, 0x2, 0x2, 0x2af, 0x2ae, 0x3, 0x2, 0x2, 
       0x2, 0x2af, 0x2b0, 0x3, 0x2, 0x2, 0x2, 0x2b0, 0x2b3, 0x3, 0x2, 0x2, 
       0x2, 0x2b1, 0x2b4, 0x5, 0x168, 0xb5, 0x2, 0x2b2, 0x2b4, 0x5, 0x96, 
       0x4c, 0x2, 0x2b3, 0x2b1, 0x3, 0x2, 0x2, 0x2, 0x2b3, 0x2b2, 0x3, 0x2, 
       0x2, 0x2, 0x2b4, 0x2b6, 0x3, 0x2, 0x2, 0x2, 0x2b5, 0x2b7, 0x5, 0x12e, 
       0x98, 0x2, 0x2b6, 0x2b5, 0x3, 0x2, 0x2, 0x2, 0x2b6, 0x2b7, 0x3, 0x2, 
       0x2, 0x2, 0x2b7, 0x2ba, 0x3, 0x2, 0x2, 0x2, 0x2b8, 0x2b9, 0x7, 0x4f, 
       0x2, 0x2, 0x2b9, 0x2bb, 0x5, 0x124, 0x93, 0x2, 0x2ba, 0x2b8, 0x3, 
       0x2, 0x2, 0x2, 0x2ba, 0x2bb, 0x3, 0x2, 0x2, 0x2, 0x2bb, 0x2c0, 0x3, 
       0x2, 0x2, 0x2, 0x2bc, 0x2bd, 0x7, 0x1da, 0x2, 0x2, 0x2bd, 0x2be, 
       0x5, 0x16c, 0xb7, 0x2, 0x2be, 0x2bf, 0x7, 0x1db, 0x2, 0x2, 0x2bf, 
       0x2c1, 0x3, 0x2, 0x2, 0x2, 0x2c0, 0x2bc, 0x3, 0x2, 0x2, 0x2, 0x2c0, 
       0x2c1, 0x3, 0x2, 0x2, 0x2, 0x2c1, 0x2c3, 0x3, 0x2, 0x2, 0x2, 0x2c2, 
       0x2c4, 0x5, 0x3c, 0x1f, 0x2, 0x2c3, 0x2c2, 0x3, 0x2, 0x2, 0x2, 0x2c3, 
       0x2c4, 0x3, 0x2, 0x2, 0x2, 0x2c4, 0x2c5, 0x3, 0x2, 0x2, 0x2, 0x2c5, 
       0x2c7, 0x5, 0x34, 0x1b, 0x2, 0x2c6, 0x2c8, 0x5, 0xfa, 0x7e, 0x2, 
       0x2c7, 0x2c6, 0x3, 0x2, 0x2, 0x2, 0x2c7, 0x2c8, 0x3, 0x2, 0x2, 0x2, 
       0x2c8, 0x2ca, 0x3, 0x2, 0x2, 0x2, 0x2c9, 0x2cb, 0x5, 0x102, 0x82, 
       0x2, 0x2ca, 0x2c9, 0x3, 0x2, 0x2, 0x2, 0x2ca, 0x2cb, 0x3, 0x2, 0x2, 
       0x2, 0x2cb, 0x2cd, 0x3, 0x2, 0x2, 0x2, 0x2cc, 0x2ce, 0x7, 0x1dd, 
       0x2, 0x2, 0x2cd, 0x2cc, 0x3, 0x2, 0x2, 0x2, 0x2cd, 0x2ce, 0x3, 0x2, 
       0x2, 0x2, 0x2ce, 0x33, 0x3, 0x2, 0x2, 0x2, 0x2cf, 0x2d5, 0x5, 0x13a, 
       0x9e, 0x2, 0x2d0, 0x2d5, 0x5, 0x124, 0x93, 0x2, 0x2d1, 0x2d5, 0x5, 
       0xa0, 0x51, 0x2, 0x2d2, 0x2d3, 0x7, 0x32, 0x2, 0x2, 0x2d3, 0x2d5, 
       0x7, 0xc5, 0x2, 0x2, 0x2d4, 0x2cf, 0x3, 0x2, 0x2, 0x2, 0x2d4, 0x2d0, 
       0x3, 0x2, 0x2, 0x2, 0x2d4, 0x2d1, 0x3, 0x2, 0x2, 0x2, 0x2d4, 0x2d2, 
       0x3, 0x2, 0x2, 0x2, 0x2d5, 0x35, 0x3, 0x2, 0x2, 0x2, 0x2d6, 0x2d8, 
       0x5, 0xda, 0x6e, 0x2, 0x2d7, 0x2d6, 0x3, 0x2, 0x2, 0x2, 0x2d7, 0x2d8, 
       0x3, 0x2, 0x2, 0x2, 0x2d8, 0x2d9, 0x3, 0x2, 0x2, 0x2, 0x2d9, 0x2db, 
       0x5, 0xe6, 0x74, 0x2, 0x2da, 0x2dc, 0x5, 0xf6, 0x7c, 0x2, 0x2db, 
       0x2da, 0x3, 0x2, 0x2, 0x2, 0x2db, 0x2dc, 0x3, 0x2, 0x2, 0x2, 0x2dc, 
       0x2de, 0x3, 0x2, 0x2, 0x2, 0x2dd, 0x2df, 0x5, 0xfa, 0x7e, 0x2, 0x2de, 
       0x2dd, 0x3, 0x2, 0x2, 0x2, 0x2de, 0x2df, 0x3, 0x2, 0x2, 0x2, 0x2df, 
       0x2e1, 0x3, 0x2, 0x2, 0x2, 0x2e0, 0x2e2, 0x5, 0x102, 0x82, 0x2, 0x2e1, 
       0x2e0, 0x3, 0x2, 0x2, 0x2, 0x2e1, 0x2e2, 0x3, 0x2, 0x2, 0x2, 0x2e2, 
       0x2e4, 0x3, 0x2, 0x2, 0x2, 0x2e3, 0x2e5, 0x7, 0x1dd, 0x2, 0x2, 0x2e4, 
       0x2e3, 0x3, 0x2, 0x2, 0x2, 0x2e4, 0x2e5, 0x3, 0x2, 0x2, 0x2, 0x2e5, 
       0x37, 0x3, 0x2, 0x2, 0x2, 0x2e6, 0x2e8, 0x5, 0xda, 0x6e, 0x2, 0x2e7, 
       0x2e6, 0x3, 0x2, 0x2, 0x2, 0x2e7, 0x2e8, 0x3, 0x2, 0x2, 0x2, 0x2e8, 
       0x2e9, 0x3, 0x2, 0x2, 0x2, 0x2e9, 0x2eb, 0x7, 0xc1, 0x2, 0x2, 0x2ea, 
       0x2ec, 0x5, 0xf4, 0x7b, 0x2, 0x2eb, 0x2ea, 0x3, 0x2, 0x2, 0x2, 0x2eb, 
       0x2ec, 0x3, 0x2, 0x2, 0x2, 0x2ec, 0x2ef, 0x3, 0x2, 0x2, 0x2, 0x2ed, 
       0x2f0, 0x5, 0x168, 0xb5, 0x2, 0x2ee, 0x2f0, 0x5, 0x96, 0x4c, 0x2, 
       0x2ef, 0x2ed, 0x3, 0x2, 0x2, 0x2, 0x2ef, 0x2ee, 0x3, 0x2, 0x2, 0x2, 
       0x2f0, 0x2f2, 0x3, 0x2, 0x2, 0x2, 0x2f1, 0x2f3, 0x5, 0x12c, 0x97, 
       0x2, 0x2f2, 0x2f1, 0x3, 0x2, 0x2, 0x2, 0x2f2, 0x2f3, 0x3, 0x2, 0x2, 
       0x2, 0x2f3, 0x2f4, 0x3, 0x2, 0x2, 0x2, 0x2f4, 0x2f5, 0x7, 0xa7, 0x2, 
       0x2, 0x2f5, 0x2fa, 0x5, 0xde, 0x70, 0x2, 0x2f6, 0x2f7, 0x7, 0x1dc, 
       0x2, 0x2, 0x2f7, 0x2f9, 0x5, 0xde, 0x70, 0x2, 0x2f8, 0x2f6, 0x3, 
       0x2, 0x2, 0x2, 0x2f9, 0x2fc, 0x3, 0x2, 0x2, 0x2, 0x2fa, 0x2f8, 0x3, 
       0x2, 0x2, 0x2, 0x2fa, 0x2fb, 0x3, 0x2, 0x2, 0x2, 0x2fb, 0x2fe, 0x3, 
       0x2, 0x2, 0x2, 0x2fc, 0x2fa, 0x3, 0x2, 0x2, 0x2, 0x2fd, 0x2ff, 0x5, 
       0x3c, 0x1f, 0x2, 0x2fe, 0x2fd, 0x3, 0x2, 0x2, 0x2, 0x2fe, 0x2ff, 
       0x3, 0x2, 0x2, 0x2, 0x2ff, 0x302, 0x3, 0x2, 0x2, 0x2, 0x300, 0x301, 
       0x7, 0x4f, 0x2, 0x2, 0x301, 0x303, 0x5, 0x10c, 0x87, 0x2, 0x302, 
       0x300, 0x3, 0x2, 0x2, 0x2, 0x302, 0x303, 0x3, 0x2, 0x2, 0x2, 0x303, 
       0x305, 0x3, 0x2, 0x2, 0x2, 0x304, 0x306, 0x5, 0x3a, 0x1e, 0x2, 0x305, 
       0x304, 0x3, 0x2, 0x2, 0x2, 0x305, 0x306, 0x3, 0x2, 0x2, 0x2, 0x306, 
       0x308, 0x3, 0x2, 0x2, 0x2, 0x307, 0x309, 0x5, 0xfa, 0x7e, 0x2, 0x308, 
       0x307, 0x3, 0x2, 0x2, 0x2, 0x308, 0x309, 0x3, 0x2, 0x2, 0x2, 0x309, 
       0x30b, 0x3, 0x2, 0x2, 0x2, 0x30a, 0x30c, 0x5, 0x102, 0x82, 0x2, 0x30b, 
       0x30a, 0x3, 0x2, 0x2, 0x2, 0x30b, 0x30c, 0x3, 0x2, 0x2, 0x2, 0x30c, 
       0x30e, 0x3, 0x2, 0x2, 0x2, 0x30d, 0x30f, 0x7, 0x1dd, 0x2, 0x2, 0x30e, 
       0x30d, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x30f, 0x3, 0x2, 0x2, 0x2, 0x30f, 
       0x39, 0x3, 0x2, 0x2, 0x2, 0x310, 0x31b, 0x7, 0xcb, 0x2, 0x2, 0x311, 
       0x31c, 0x5, 0xe0, 0x71, 0x2, 0x312, 0x313, 0x7, 0x28, 0x2, 0x2, 0x313, 
       0x319, 0x7, 0x76, 0x2, 0x2, 0x314, 0x316, 0x7, 0x124, 0x2, 0x2, 0x315, 
       0x314, 0x3, 0x2, 0x2, 0x2, 0x315, 0x316, 0x3, 0x2, 0x2, 0x2, 0x316, 
       0x317, 0x3, 0x2, 0x2, 0x2, 0x317, 0x31a, 0x5, 0x16e, 0xb8, 0x2, 0x318, 
       0x31a, 0x7, 0x1c2, 0x2, 0x2, 0x319, 0x315, 0x3, 0x2, 0x2, 0x2, 0x319, 
       0x318, 0x3, 0x2, 0x2, 0x2, 0x31a, 0x31c, 0x3, 0x2, 0x2, 0x2, 0x31b, 
       0x311, 0x3, 0x2, 0x2, 0x2, 0x31b, 0x312, 0x3, 0x2, 0x2, 0x2, 0x31c, 
       0x3b, 0x3, 0x2, 0x2, 0x2, 0x31d, 0x31e, 0x7, 0x163, 0x2, 0x2, 0x31e, 
       0x323, 0x5, 0x3e, 0x20, 0x2, 0x31f, 0x320, 0x7, 0x1dc, 0x2, 0x2, 
       0x320, 0x322, 0x5, 0x3e, 0x20, 0x2, 0x321, 0x31f, 0x3, 0x2, 0x2, 
       0x2, 0x322, 0x325, 0x3, 0x2, 0x2, 0x2, 0x323, 0x321, 0x3, 0x2, 0x2, 
       0x2, 0x323, 0x324, 0x3, 0x2, 0x2, 0x2, 0x324, 0x331, 0x3, 0x2, 0x2, 
       0x2, 0x325, 0x323, 0x3, 0x2, 0x2, 0x2, 0x326, 0x329, 0x7, 0x61, 0x2, 
       0x2, 0x327, 0x32a, 0x7, 0x1c2, 0x2, 0x2, 0x328, 0x32a, 0x5, 0x162, 
       0xb2, 0x2, 0x329, 0x327, 0x3, 0x2, 0x2, 0x2, 0x329, 0x328, 0x3, 0x2, 
       0x2, 0x2, 0x32a, 0x32f, 0x3, 0x2, 0x2, 0x2, 0x32b, 0x32c, 0x7, 0x1da, 
       0x2, 0x2, 0x32c, 0x32d, 0x5, 0x16c, 0xb7, 0x2, 0x32d, 0x32e, 0x7, 
       0x1db, 0x2, 0x2, 0x32e, 0x330, 0x3, 0x2, 0x2, 0x2, 0x32f, 0x32b, 
       0x3, 0x2, 0x2, 0x2, 0x32f, 0x330, 0x3, 0x2, 0x2, 0x2, 0x330, 0x332, 
       0x3, 0x2, 0x2, 0x2, 0x331, 0x326, 0x3, 0x2, 0x2, 0x2, 0x331, 0x332, 
       0x3, 0x2, 0x2, 0x2, 0x332, 0x3d, 0x3, 0x2, 0x2, 0x2, 0x333, 0x336, 
       0x5, 0x40, 0x21, 0x2, 0x334, 0x336, 0x5, 0xd0, 0x69, 0x2, 0x335, 
       0x333, 0x3, 0x2, 0x2, 0x2, 0x335, 0x334, 0x3, 0x2, 0x2, 0x2, 0x336, 
       0x33b, 0x3, 0x2, 0x2, 0x2, 0x337, 0x339, 0x7, 0x8, 0x2, 0x2, 0x338, 
       0x337, 0x3, 0x2, 0x2, 0x2, 0x338, 0x339, 0x3, 0x2, 0x2, 0x2, 0x339, 
       0x33a, 0x3, 0x2, 0x2, 0x2, 0x33a, 0x33c, 0x5, 0x136, 0x9c, 0x2, 0x33b, 
       0x338, 0x3, 0x2, 0x2, 0x2, 0x33b, 0x33c, 0x3, 0x2, 0x2, 0x2, 0x33c, 
       0x3f, 0x3, 0x2, 0x2, 0x2, 0x33d, 0x341, 0x7, 0x109, 0x2, 0x2, 0x33e, 
       0x341, 0x7, 0x133, 0x2, 0x2, 0x33f, 0x341, 0x5, 0x162, 0xb2, 0x2, 
       0x340, 0x33d, 0x3, 0x2, 0x2, 0x2, 0x340, 0x33e, 0x3, 0x2, 0x2, 0x2, 
       0x340, 0x33f, 0x3, 0x2, 0x2, 0x2, 0x341, 0x342, 0x3, 0x2, 0x2, 0x2, 
       0x342, 0x345, 0x7, 0x1d5, 0x2, 0x2, 0x343, 0x346, 0x7, 0x1df, 0x2, 
       0x2, 0x344, 0x346, 0x5, 0x17e, 0xc0, 0x2, 0x345, 0x343, 0x3, 0x2, 
       0x2, 0x2, 0x345, 0x344, 0x3, 0x2, 0x2, 0x2, 0x346, 0x349, 0x3, 0x2, 
       0x2, 0x2, 0x347, 0x349, 0x7, 0x1bc, 0x2, 0x2, 0x348, 0x340, 0x3, 
       0x2, 0x2, 0x2, 0x348, 0x347, 0x3, 0x2, 0x2, 0x2, 0x349, 0x41, 0x3, 
       0x2, 0x2, 0x2, 0x34a, 0x34b, 0x7, 0x26, 0x2, 0x2, 0x34b, 0x34c, 0x7, 
       0x2e, 0x2, 0x2, 0x34c, 0x350, 0x5, 0x17e, 0xc0, 0x2, 0x34d, 0x34e, 
       0x7, 0x21, 0x2, 0x2, 0x34e, 0x34f, 0x7, 0x1c9, 0x2, 0x2, 0x34f, 0x351, 
       0x9, 0x6, 0x2, 0x2, 0x350, 0x34d, 0x3, 0x2, 0x2, 0x2, 0x350, 0x351, 
       0x3, 0x2, 0x2, 0x2, 0x351, 0x35e, 0x3, 0x2, 0x2, 0x2, 0x352, 0x354, 
       0x7, 0x79, 0x2, 0x2, 0x353, 0x355, 0x7, 0x89, 0x2, 0x2, 0x354, 0x353, 
       0x3, 0x2, 0x2, 0x2, 0x354, 0x355, 0x3, 0x2, 0x2, 0x2, 0x355, 0x356, 
       0x3, 0x2, 0x2, 0x2, 0x356, 0x35b, 0x5, 0x15a, 0xae, 0x2, 0x357, 0x358, 
       0x7, 0x1dc, 0x2, 0x2, 0x358, 0x35a, 0x5, 0x15a, 0xae, 0x2, 0x359, 
       0x357, 0x3, 0x2, 0x2, 0x2, 0x35a, 0x35d, 0x3, 0x2, 0x2, 0x2, 0x35b, 
       0x359, 0x3, 0x2, 0x2, 0x2, 0x35b, 0x35c, 0x3, 0x2, 0x2, 0x2, 0x35c, 
       0x35f, 0x3, 0x2, 0x2, 0x2, 0x35d, 0x35b, 0x3, 0x2, 0x2, 0x2, 0x35e, 
       0x352, 0x3, 0x2, 0x2, 0x2, 0x35e, 0x35f, 0x3, 0x2, 0x2, 0x2, 0x35f, 
       0x36a, 0x3, 0x2, 0x2, 0x2, 0x360, 0x361, 0x7, 0x6a, 0x2, 0x2, 0x361, 
       0x362, 0x7, 0x79, 0x2, 0x2, 0x362, 0x367, 0x5, 0x15a, 0xae, 0x2, 
       0x363, 0x364, 0x7, 0x1dc, 0x2, 0x2, 0x364, 0x366, 0x5, 0x15a, 0xae, 
       0x2, 0x365, 0x363, 0x3, 0x2, 0x2, 0x2, 0x366, 0x369, 0x3, 0x2, 0x2, 
       0x2, 0x367, 0x365, 0x3, 0x2, 0x2, 0x2, 0x367, 0x368, 0x3, 0x2, 0x2, 
       0x2, 0x368, 0x36b, 0x3, 0x2, 0x2, 0x2, 0x369, 0x367, 0x3, 0x2, 0x2, 
       0x2, 0x36a, 0x360, 0x3, 0x2, 0x2, 0x2, 0x36a, 0x36b, 0x3, 0x2, 0x2, 
       0x2, 0x36b, 0x36e, 0x3, 0x2, 0x2, 0x2, 0x36c, 0x36d, 0x7, 0x1c, 0x2, 
       0x2, 0x36d, 0x36f, 0x5, 0x17e, 0xc0, 0x2, 0x36e, 0x36c, 0x3, 0x2, 
       0x2, 0x2, 0x36e, 0x36f, 0x3, 0x2, 0x2, 0x2, 0x36f, 0x379, 0x3, 0x2, 
       0x2, 0x2, 0x370, 0x371, 0x7, 0xcd, 0x2, 0x2, 0x371, 0x376, 0x5, 0x156, 
       0xac, 0x2, 0x372, 0x373, 0x7, 0x1dc, 0x2, 0x2, 0x373, 0x375, 0x5, 
       0x156, 0xac, 0x2, 0x374, 0x372, 0x3, 0x2, 0x2, 0x2, 0x375, 0x378, 
       0x3, 0x2, 0x2, 0x2, 0x376, 0x374, 0x3, 0x2, 0x2, 0x2, 0x376, 0x377, 
       0x3, 0x2, 0x2, 0x2, 0x377, 0x37a, 0x3, 0x2, 0x2, 0x2, 0x378, 0x376, 
       0x3, 0x2, 0x2, 0x2, 0x379, 0x370, 0x3, 0x2, 0x2, 0x2, 0x379, 0x37a, 
       0x3, 0x2, 0x2, 0x2, 0x37a, 0x43, 0x3, 0x2, 0x2, 0x2, 0x37b, 0x37d, 
       0x7, 0x26, 0x2, 0x2, 0x37c, 0x37e, 0x7, 0xbf, 0x2, 0x2, 0x37d, 0x37c, 
       0x3, 0x2, 0x2, 0x2, 0x37d, 0x37e, 0x3, 0x2, 0x2, 0x2, 0x37e, 0x380, 
       0x3, 0x2, 0x2, 0x2, 0x37f, 0x381, 0x5, 0x172, 0xba, 0x2, 0x380, 0x37f, 
       0x3, 0x2, 0x2, 0x2, 0x380, 0x381, 0x3, 0x2, 0x2, 0x2, 0x381, 0x382, 
       0x3, 0x2, 0x2, 0x2, 0x382, 0x383, 0x7, 0x5c, 0x2, 0x2, 0x383, 0x384, 
       0x5, 0x17e, 0xc0, 0x2, 0x384, 0x385, 0x7, 0x79, 0x2, 0x2, 0x385, 
       0x386, 0x5, 0x11e, 0x90, 0x2, 0x386, 0x387, 0x7, 0x1da, 0x2, 0x2, 
       0x387, 0x389, 0x5, 0x16c, 0xb7, 0x2, 0x388, 0x38a, 0x9, 0x7, 0x2, 
       0x2, 0x389, 0x388, 0x3, 0x2, 0x2, 0x2, 0x389, 0x38a, 0x3, 0x2, 0x2, 
       0x2, 0x38a, 0x38b, 0x3, 0x2, 0x2, 0x2, 0x38b, 0x394, 0x7, 0x1db, 
       0x2, 0x2, 0x38c, 0x38d, 0x7, 0x5d, 0x2, 0x2, 0x38d, 0x38e, 0x7, 0x1da, 
       0x2, 0x2, 0x38e, 0x390, 0x5, 0x16c, 0xb7, 0x2, 0x38f, 0x391, 0x9, 
       0x7, 0x2, 0x2, 0x390, 0x38f, 0x3, 0x2, 0x2, 0x2, 0x390, 0x391, 0x3, 
       0x2, 0x2, 0x2, 0x391, 0x392, 0x3, 0x2, 0x2, 0x2, 0x392, 0x393, 0x7, 
       0x1db, 0x2, 0x2, 0x393, 0x395, 0x3, 0x2, 0x2, 0x2, 0x394, 0x38c, 
       0x3, 0x2, 0x2, 0x2, 0x394, 0x395, 0x3, 0x2, 0x2, 0x2, 0x395, 0x398, 
       0x3, 0x2, 0x2, 0x2, 0x396, 0x397, 0x7, 0xcb, 0x2, 0x2, 0x397, 0x399, 
       0x5, 0xe2, 0x72, 0x2, 0x398, 0x396, 0x3, 0x2, 0x2, 0x2, 0x398, 0x399, 
       0x3, 0x2, 0x2, 0x2, 0x399, 0x39b, 0x3, 0x2, 0x2, 0x2, 0x39a, 0x39c, 
       0x5, 0xc2, 0x62, 0x2, 0x39b, 0x39a, 0x3, 0x2, 0x2, 0x2, 0x39b, 0x39c, 
       0x3, 0x2, 0x2, 0x2, 0x39c, 0x39f, 0x3, 0x2, 0x2, 0x2, 0x39d, 0x39e, 
       0x7, 0x79, 0x2, 0x2, 0x39e, 0x3a0, 0x5, 0x17e, 0xc0, 0x2, 0x39f, 
       0x39d, 0x3, 0x2, 0x2, 0x2, 0x39f, 0x3a0, 0x3, 0x2, 0x2, 0x2, 0x3a0, 
       0x3a2, 0x3, 0x2, 0x2, 0x2, 0x3a1, 0x3a3, 0x7, 0x1dd, 0x2, 0x2, 0x3a2, 
       0x3a1, 0x3, 0x2, 0x2, 0x2, 0x3a2, 0x3a3, 0x3, 0x2, 0x2, 0x2, 0x3a3, 
       0x45, 0x3, 0x2, 0x2, 0x2, 0x3a4, 0x3a5, 0x7, 0x26, 0x2, 0x2, 0x3a5, 
       0x3a6, 0x7, 0xac, 0x2, 0x2, 0x3a6, 0x3a7, 0x5, 0x17e, 0xc0, 0x2, 
       0x3a7, 0x3a8, 0x7, 0x79, 0x2, 0x2, 0x3a8, 0x3a9, 0x5, 0x11e, 0x90, 
       0x2, 0x3a9, 0x3aa, 0x7, 0x1da, 0x2, 0x2, 0x3aa, 0x3ab, 0x5, 0x16c, 
       0xb7, 0x2, 0x3ab, 0x3be, 0x7, 0x1db, 0x2, 0x2, 0x3ac, 0x3b2, 0x7, 
       0xcd, 0x2, 0x2, 0x3ad, 0x3b3, 0x7, 0x122, 0x2, 0x2, 0x3ae, 0x3af, 
       0x7, 0x186, 0x2, 0x2, 0x3af, 0x3b0, 0x7, 0x1c3, 0x2, 0x2, 0x3b0, 
       0x3b3, 0x9, 0x8, 0x2, 0x2, 0x3b1, 0x3b3, 0x7, 0x197, 0x2, 0x2, 0x3b2, 
       0x3ad, 0x3, 0x2, 0x2, 0x2, 0x3b2, 0x3ae, 0x3, 0x2, 0x2, 0x2, 0x3b2, 
       0x3b1, 0x3, 0x2, 0x2, 0x2, 0x3b3, 0x3b6, 0x3, 0x2, 0x2, 0x2, 0x3b4, 
       0x3b5, 0x7, 0x1dc, 0x2, 0x2, 0x3b5, 0x3b7, 0x7, 0x157, 0x2, 0x2, 
       0x3b6, 0x3b4, 0x3, 0x2, 0x2, 0x2, 0x3b6, 0x3b7, 0x3, 0x2, 0x2, 0x2, 
       0x3b7, 0x3bc, 0x3, 0x2, 0x2, 0x2, 0x3b8, 0x3b9, 0x7, 0x1dc, 0x2, 
       0x2, 0x3b9, 0x3ba, 0x7, 0x12f, 0x2, 0x2, 0x3ba, 0x3bb, 0x7, 0x1c9, 
       0x2, 0x2, 0x3bb, 0x3bd, 0x5, 0x170, 0xb9, 0x2, 0x3bc, 0x3b8, 0x3, 
       0x2, 0x2, 0x2, 0x3bc, 0x3bd, 0x3, 0x2, 0x2, 0x2, 0x3bd, 0x3bf, 0x3, 
       0x2, 0x2, 0x2, 0x3be, 0x3ac, 0x3, 0x2, 0x2, 0x2, 0x3be, 0x3bf, 0x3, 
       0x2, 0x2, 0x2, 0x3bf, 0x3c1, 0x3, 0x2, 0x2, 0x2, 0x3c0, 0x3c2, 0x7, 
       0x1dd, 0x2, 0x2, 0x3c1, 0x3c0, 0x3, 0x2, 0x2, 0x2, 0x3c1, 0x3c2, 
       0x3, 0x2, 0x2, 0x2, 0x3c2, 0x47, 0x3, 0x2, 0x2, 0x2, 0x3c3, 0x3c4, 
       0x7, 0x26, 0x2, 0x2, 0x3c4, 0x3c5, 0x7, 0xb0, 0x2, 0x2, 0x3c5, 0x3c6, 
       0x5, 0x162, 0xb2, 0x2, 0x3c6, 0x3c7, 0x7, 0x1da, 0x2, 0x2, 0x3c7, 
       0x3c9, 0x5, 0xb8, 0x5d, 0x2, 0x3c8, 0x3ca, 0x7, 0x1dc, 0x2, 0x2, 
       0x3c9, 0x3c8, 0x3, 0x2, 0x2, 0x2, 0x3c9, 0x3ca, 0x3, 0x2, 0x2, 0x2, 
       0x3ca, 0x3cb, 0x3, 0x2, 0x2, 0x2, 0x3cb, 0x3cf, 0x7, 0x1db, 0x2, 
       0x2, 0x3cc, 0x3cd, 0x7, 0x79, 0x2, 0x2, 0x3cd, 0x3d0, 0x5, 0x17e, 
       0xc0, 0x2, 0x3ce, 0x3d0, 0x7, 0x32, 0x2, 0x2, 0x3cf, 0x3cc, 0x3, 
       0x2, 0x2, 0x2, 0x3cf, 0x3ce, 0x3, 0x2, 0x2, 0x2, 0x3cf, 0x3d0, 0x3, 
       0x2, 0x2, 0x2, 0x3d0, 0x3d4, 0x3, 0x2, 0x2, 0x2, 0x3d1, 0x3d2, 0x7, 
       0x1a3, 0x2, 0x2, 0x3d2, 0x3d5, 0x5, 0x17e, 0xc0, 0x2, 0x3d3, 0x3d5, 
       0x7, 0x32, 0x2, 0x2, 0x3d4, 0x3d1, 0x3, 0x2, 0x2, 0x2, 0x3d4, 0x3d3, 
       0x3, 0x2, 0x2, 0x2, 0x3d4, 0x3d5, 0x3, 0x2, 0x2, 0x2, 0x3d5, 0x3d7, 
       0x3, 0x2, 0x2, 0x2, 0x3d6, 0x3d8, 0x7, 0x1dd, 0x2, 0x2, 0x3d7, 0x3d6, 
       0x3, 0x2, 0x2, 0x2, 0x3d7, 0x3d8, 0x3, 0x2, 0x2, 0x2, 0x3d8, 0x49, 
       0x3, 0x2, 0x2, 0x2, 0x3d9, 0x3da, 0x7, 0x26, 0x2, 0x2, 0x3da, 0x3db, 
       0x7, 0xa0, 0x2, 0x2, 0x3db, 0x3dd, 0x5, 0x164, 0xb3, 0x2, 0x3dc, 
       0x3de, 0x7, 0x1dd, 0x2, 0x2, 0x3dd, 0x3dc, 0x3, 0x2, 0x2, 0x2, 0x3dd, 
       0x3de, 0x3, 0x2, 0x2, 0x2, 0x3de, 0x4b, 0x3, 0x2, 0x2, 0x2, 0x3df, 
       0x3e0, 0x7, 0x26, 0x2, 0x2, 0x3e0, 0x3e1, 0x7, 0xad, 0x2, 0x2, 0x3e1, 
       0x3e2, 0x5, 0x164, 0xb3, 0x2, 0x3e2, 0x3e3, 0x7, 0x4a, 0x2, 0x2, 
       0x3e3, 0x3e5, 0x5, 0x162, 0xb2, 0x2, 0x3e4, 0x3e6, 0x7, 0x1dd, 0x2, 
       0x2, 0x3e5, 0x3e4, 0x3, 0x2, 0x2, 0x2, 0x3e5, 0x3e6, 0x3, 0x2, 0x2, 
       0x2, 0x3e6, 0x4d, 0x3, 0x2, 0x2, 0x2, 0x3e7, 0x3e8, 0x7, 0x26, 0x2, 
       0x2, 0x3e8, 0x3e9, 0x7, 0xc8, 0x2, 0x2, 0x3e9, 0x3ee, 0x5, 0x164, 
       0xb3, 0x2, 0x3ea, 0x3eb, 0x7, 0x1da, 0x2, 0x2, 0x3eb, 0x3ec, 0x5, 
       0x16c, 0xb7, 0x2, 0x3ec, 0x3ed, 0x7, 0x1db, 0x2, 0x2, 0x3ed, 0x3ef, 
       0x3, 0x2, 0x2, 0x2, 0x3ee, 0x3ea, 0x3, 0x2, 0x2, 0x2, 0x3ee, 0x3ef, 
       0x3, 0x2, 0x2, 0x2, 0x3ef, 0x3f9, 0x3, 0x2, 0x2, 0x2, 0x3f0, 0x3f1, 
       0x7, 0xcd, 0x2, 0x2, 0x3f1, 0x3f6, 0x5, 0x50, 0x29, 0x2, 0x3f2, 0x3f3, 
       0x7, 0x1dc, 0x2, 0x2, 0x3f3, 0x3f5, 0x5, 0x50, 0x29, 0x2, 0x3f4, 
       0x3f2, 0x3, 0x2, 0x2, 0x2, 0x3f5, 0x3f8, 0x3, 0x2, 0x2, 0x2, 0x3f6, 
       0x3f4, 0x3, 0x2, 0x2, 0x2, 0x3f6, 0x3f7, 0x3, 0x2, 0x2, 0x2, 0x3f7, 
       0x3fa, 0x3, 0x2, 0x2, 0x2, 0x3f8, 0x3f6, 0x3, 0x2, 0x2, 0x2, 0x3f9, 
       0x3f0, 0x3, 0x2, 0x2, 0x2, 0x3f9, 0x3fa, 0x3, 0x2, 0x2, 0x2, 0x3fa, 
       0x3fb, 0x3, 0x2, 0x2, 0x2, 0x3fb, 0x3fc, 0x7, 0x8, 0x2, 0x2, 0x3fc, 
       0x400, 0x5, 0x36, 0x1c, 0x2, 0x3fd, 0x3fe, 0x7, 0xcd, 0x2, 0x2, 0x3fe, 
       0x3ff, 0x7, 0x17, 0x2, 0x2, 0x3ff, 0x401, 0x7, 0x7f, 0x2, 0x2, 0x400, 
       0x3fd, 0x3, 0x2, 0x2, 0x2, 0x400, 0x401, 0x3, 0x2, 0x2, 0x2, 0x401, 
       0x403, 0x3, 0x2, 0x2, 0x2, 0x402, 0x404, 0x7, 0x1dd, 0x2, 0x2, 0x403, 
       0x402, 0x3, 0x2, 0x2, 0x2, 0x403, 0x404, 0x3, 0x2, 0x2, 0x2, 0x404, 
       0x4f, 0x3, 0x2, 0x2, 0x2, 0x405, 0x406, 0x9, 0x9, 0x2, 0x2, 0x406, 
       0x51, 0x3, 0x2, 0x2, 0x2, 0x407, 0x408, 0x7, 0x5, 0x2, 0x2, 0x408, 
       0x409, 0x7, 0xb0, 0x2, 0x2, 0x409, 0x42b, 0x5, 0x162, 0xb2, 0x2, 
       0x40a, 0x40b, 0x7, 0xa7, 0x2, 0x2, 0x40b, 0x40c, 0x7, 0x1da, 0x2, 
       0x2, 0x40c, 0x40d, 0x7, 0x140, 0x2, 0x2, 0x40d, 0x40e, 0x7, 0x1c9, 
       0x2, 0x2, 0x40e, 0x40f, 0x9, 0xa, 0x2, 0x2, 0x40f, 0x42c, 0x7, 0x1db, 
       0x2, 0x2, 0x410, 0x411, 0x7, 0x3, 0x2, 0x2, 0x411, 0x42c, 0x5, 0xba, 
       0x5e, 0x2, 0x412, 0x413, 0x7, 0x3a, 0x2, 0x2, 0x413, 0x414, 0x7, 
       0x20, 0x2, 0x2, 0x414, 0x42c, 0x5, 0x17e, 0xc0, 0x2, 0x415, 0x416, 
       0x7, 0xcd, 0x2, 0x2, 0x416, 0x417, 0x7, 0x17, 0x2, 0x2, 0x417, 0x418, 
       0x7, 0x3, 0x2, 0x2, 0x418, 0x419, 0x7, 0x20, 0x2, 0x2, 0x419, 0x41a, 
       0x5, 0x17e, 0xc0, 0x2, 0x41a, 0x41b, 0x7, 0x4c, 0x2, 0x2, 0x41b, 
       0x41c, 0x7, 0x64, 0x2, 0x2, 0x41c, 0x41d, 0x7, 0x1da, 0x2, 0x2, 0x41d, 
       0x41e, 0x5, 0x16c, 0xb7, 0x2, 0x41e, 0x41f, 0x7, 0x1db, 0x2, 0x2, 
       0x41f, 0x420, 0x7, 0x92, 0x2, 0x2, 0x420, 0x421, 0x5, 0x162, 0xb2, 
       0x2, 0x421, 0x422, 0x7, 0x1da, 0x2, 0x2, 0x422, 0x423, 0x5, 0x16c, 
       0xb7, 0x2, 0x423, 0x424, 0x7, 0x1db, 0x2, 0x2, 0x424, 0x42c, 0x3, 
       0x2, 0x2, 0x2, 0x425, 0x426, 0x7, 0x17, 0x2, 0x2, 0x426, 0x427, 0x7, 
       0x20, 0x2, 0x2, 0x427, 0x42c, 0x5, 0x17e, 0xc0, 0x2, 0x428, 0x429, 
       0x7, 0x5, 0x2, 0x2, 0x429, 0x42a, 0x7, 0x1d, 0x2, 0x2, 0x42a, 0x42c, 
       0x5, 0xb8, 0x5d, 0x2, 0x42b, 0x40a, 0x3, 0x2, 0x2, 0x2, 0x42b, 0x410, 
       0x3, 0x2, 0x2, 0x2, 0x42b, 0x412, 0x3, 0x2, 0x2, 0x2, 0x42b, 0x415, 
       0x3, 0x2, 0x2, 0x2, 0x42b, 0x425, 0x3, 0x2, 0x2, 0x2, 0x42b, 0x428, 
       0x3, 0x2, 0x2, 0x2, 0x42c, 0x42e, 0x3, 0x2, 0x2, 0x2, 0x42d, 0x42f, 
       0x7, 0x1dd, 0x2, 0x2, 0x42e, 0x42d, 0x3, 0x2, 0x2, 0x2, 0x42e, 0x42f, 
       0x3, 0x2, 0x2, 0x2, 0x42f, 0x53, 0x3, 0x2, 0x2, 0x2, 0x430, 0x431, 
       0x7, 0x5, 0x2, 0x2, 0x431, 0x434, 0x7, 0x2e, 0x2, 0x2, 0x432, 0x435, 
       0x5, 0x17e, 0xc0, 0x2, 0x433, 0x435, 0x7, 0x28, 0x2, 0x2, 0x434, 
       0x432, 0x3, 0x2, 0x2, 0x2, 0x434, 0x433, 0x3, 0x2, 0x2, 0x2, 0x435, 
       0x442, 0x3, 0x2, 0x2, 0x2, 0x436, 0x437, 0x7, 0x14e, 0x2, 0x2, 0x437, 
       0x438, 0x7, 0x150, 0x2, 0x2, 0x438, 0x439, 0x7, 0x1c9, 0x2, 0x2, 
       0x439, 0x443, 0x5, 0x17e, 0xc0, 0x2, 0x43a, 0x43b, 0x7, 0x1c, 0x2, 
       0x2, 0x43b, 0x443, 0x5, 0x17e, 0xc0, 0x2, 0x43c, 0x43d, 0x7, 0xa7, 
       0x2, 0x2, 0x43d, 0x440, 0x5, 0x56, 0x2c, 0x2, 0x43e, 0x43f, 0x7, 
       0xcd, 0x2, 0x2, 0x43f, 0x441, 0x5, 0x80, 0x41, 0x2, 0x440, 0x43e, 
       0x3, 0x2, 0x2, 0x2, 0x440, 0x441, 0x3, 0x2, 0x2, 0x2, 0x441, 0x443, 
       0x3, 0x2, 0x2, 0x2, 0x442, 0x436, 0x3, 0x2, 0x2, 0x2, 0x442, 0x43a, 
       0x3, 0x2, 0x2, 0x2, 0x442, 0x43c, 0x3, 0x2, 0x2, 0x2, 0x443, 0x445, 
       0x3, 0x2, 0x2, 0x2, 0x444, 0x446, 0x7, 0x1dd, 0x2, 0x2, 0x445, 0x444, 
       0x3, 0x2, 0x2, 0x2, 0x445, 0x446, 0x3, 0x2, 0x2, 0x2, 0x446, 0x55, 
       0x3, 0x2, 0x2, 0x2, 0x447, 0x45e, 0x5, 0x58, 0x2d, 0x2, 0x448, 0x45e, 
       0x5, 0x5a, 0x2e, 0x2, 0x449, 0x45e, 0x5, 0x5e, 0x30, 0x2, 0x44a, 
       0x45e, 0x5, 0x60, 0x31, 0x2, 0x44b, 0x45e, 0x5, 0x62, 0x32, 0x2, 
       0x44c, 0x45e, 0x5, 0x64, 0x33, 0x2, 0x44d, 0x45e, 0x5, 0x66, 0x34, 
       0x2, 0x44e, 0x45e, 0x5, 0x68, 0x35, 0x2, 0x44f, 0x45e, 0x5, 0x6a, 
       0x36, 0x2, 0x450, 0x45e, 0x5, 0x6c, 0x37, 0x2, 0x451, 0x45e, 0x5, 
       0x6e, 0x38, 0x2, 0x452, 0x453, 0x7, 0x11a, 0x2, 0x2, 0x453, 0x45e, 
       0x5, 0x158, 0xad, 0x2, 0x454, 0x45e, 0x5, 0x70, 0x39, 0x2, 0x455, 
       0x45e, 0x5, 0x72, 0x3a, 0x2, 0x456, 0x45e, 0x5, 0x74, 0x3b, 0x2, 
       0x457, 0x45e, 0x5, 0x76, 0x3c, 0x2, 0x458, 0x45e, 0x5, 0x78, 0x3d, 
       0x2, 0x459, 0x45e, 0x5, 0x7a, 0x3e, 0x2, 0x45a, 0x45e, 0x5, 0x7c, 
       0x3f, 0x2, 0x45b, 0x45e, 0x5, 0x7e, 0x40, 0x2, 0x45c, 0x45e, 0x5, 
       0x80, 0x41, 0x2, 0x45d, 0x447, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x448, 
       0x3, 0x2, 0x2, 0x2, 0x45d, 0x449, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x44a, 
       0x3, 0x2, 0x2, 0x2, 0x45d, 0x44b, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x44c, 
       0x3, 0x2, 0x2, 0x2, 0x45d, 0x44d, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x44e, 
       0x3, 0x2, 0x2, 0x2, 0x45d, 0x44f, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x450, 
       0x3, 0x2, 0x2, 0x2, 0x45d, 0x451, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x452, 
       0x3, 0x2, 0x2, 0x2, 0x45d, 0x454, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x455, 
       0x3, 0x2, 0x2, 0x2, 0x45d, 0x456, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x457, 
       0x3, 0x2, 0x2, 0x2, 0x45d, 0x458, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x459, 
       0x3, 0x2, 0x2, 0x2, 0x45d, 0x45a, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x45b, 
       0x3, 0x2, 0x2, 0x2, 0x45d, 0x45c, 0x3, 0x2, 0x2, 0x2, 0x45e, 0x57, 
       0x3, 0x2, 0x2, 0x2, 0x45f, 0x460, 0x7, 0xdd, 0x2, 0x2, 0x460, 0x471, 
       0x5, 0x170, 0xb9, 0x2, 0x461, 0x462, 0x7, 0xde, 0x2, 0x2, 0x462, 
       0x471, 0x7, 0x77, 0x2, 0x2, 0x463, 0x468, 0x7, 0x79, 0x2, 0x2, 0x464, 
       0x465, 0x7, 0x12f, 0x2, 0x2, 0x465, 0x466, 0x7, 0x1c9, 0x2, 0x2, 
       0x466, 0x469, 0x7, 0x79, 0x2, 0x2, 0x467, 0x469, 0x7, 0x77, 0x2, 
       0x2, 0x468, 0x464, 0x3, 0x2, 0x2, 0x2, 0x468, 0x467, 0x3, 0x2, 0x2, 
       0x2, 0x469, 0x471, 0x3, 0x2, 0x2, 0x2, 0x46a, 0x46b, 0x7, 0xdf, 0x2, 
       0x2, 0x46b, 0x471, 0x5, 0x170, 0xb9, 0x2, 0x46c, 0x46d, 0x7, 0xe0, 
       0x2, 0x2, 0x46d, 0x471, 0x5, 0x170, 0xb9, 0x2, 0x46e, 0x46f, 0x7, 
       0xe1, 0x2, 0x2, 0x46f, 0x471, 0x9, 0xb, 0x2, 0x2, 0x470, 0x45f, 0x3, 
       0x2, 0x2, 0x2, 0x470, 0x461, 0x3, 0x2, 0x2, 0x2, 0x470, 0x463, 0x3, 
       0x2, 0x2, 0x2, 0x470, 0x46a, 0x3, 0x2, 0x2, 0x2, 0x470, 0x46c, 0x3, 
       0x2, 0x2, 0x2, 0x470, 0x46e, 0x3, 0x2, 0x2, 0x2, 0x471, 0x59, 0x3, 
       0x2, 0x2, 0x2, 0x472, 0x473, 0x7, 0xec, 0x2, 0x2, 0x473, 0x483, 0x7, 
       0x1c9, 0x2, 0x2, 0x474, 0x484, 0x7, 0x77, 0x2, 0x2, 0x475, 0x480, 
       0x7, 0x79, 0x2, 0x2, 0x476, 0x47b, 0x5, 0x5c, 0x2f, 0x2, 0x477, 0x478, 
       0x7, 0x1dc, 0x2, 0x2, 0x478, 0x47a, 0x5, 0x5c, 0x2f, 0x2, 0x479, 
       0x477, 0x3, 0x2, 0x2, 0x2, 0x47a, 0x47d, 0x3, 0x2, 0x2, 0x2, 0x47b, 
       0x479, 0x3, 0x2, 0x2, 0x2, 0x47b, 0x47c, 0x3, 0x2, 0x2, 0x2, 0x47c, 
       0x47f, 0x3, 0x2, 0x2, 0x2, 0x47d, 0x47b, 0x3, 0x2, 0x2, 0x2, 0x47e, 
       0x476, 0x3, 0x2, 0x2, 0x2, 0x47f, 0x482, 0x3, 0x2, 0x2, 0x2, 0x480, 
       0x47e, 0x3, 0x2, 0x2, 0x2, 0x480, 0x481, 0x3, 0x2, 0x2, 0x2, 0x481, 
       0x484, 0x3, 0x2, 0x2, 0x2, 0x482, 0x480, 0x3, 0x2, 0x2, 0x2, 0x483, 
       0x474, 0x3, 0x2, 0x2, 0x2, 0x483, 0x475, 0x3, 0x2, 0x2, 0x2, 0x484, 
       0x5b, 0x3, 0x2, 0x2, 0x2, 0x485, 0x486, 0x7, 0xdc, 0x2, 0x2, 0x486, 
       0x487, 0x7, 0x1c9, 0x2, 0x2, 0x487, 0x48c, 0x5, 0x170, 0xb9, 0x2, 
       0x488, 0x489, 0x7, 0xeb, 0x2, 0x2, 0x489, 0x48a, 0x7, 0x1c9, 0x2, 
       0x2, 0x48a, 0x48c, 0x9, 0xc, 0x2, 0x2, 0x48b, 0x485, 0x3, 0x2, 0x2, 
       0x2, 0x48b, 0x488, 0x3, 0x2, 0x2, 0x2, 0x48c, 0x5d, 0x3, 0x2, 0x2, 
       0x2, 0x48d, 0x48e, 0x7, 0x21, 0x2, 0x2, 0x48e, 0x48f, 0x7, 0x1c9, 
       0x2, 0x2, 0x48f, 0x490, 0x9, 0x6, 0x2, 0x2, 0x490, 0x5f, 0x3, 0x2, 
       0x2, 0x2, 0x491, 0x492, 0x7, 0xf9, 0x2, 0x2, 0x492, 0x496, 0x5, 0x170, 
       0xb9, 0x2, 0x493, 0x494, 0x7, 0xfa, 0x2, 0x2, 0x494, 0x496, 0x9, 
       0xd, 0x2, 0x2, 0x495, 0x491, 0x3, 0x2, 0x2, 0x2, 0x495, 0x493, 0x3, 
       0x2, 0x2, 0x2, 0x496, 0x61, 0x3, 0x2, 0x2, 0x2, 0x497, 0x498, 0x7, 
       0x102, 0x2, 0x2, 0x498, 0x499, 0x5, 0x170, 0xb9, 0x2, 0x499, 0x63, 
       0x3, 0x2, 0x2, 0x2, 0x49a, 0x49b, 0x7, 0x112, 0x2, 0x2, 0x49b, 0x49c, 
       0x5, 0x170, 0xb9, 0x2, 0x49c, 0x65, 0x3, 0x2, 0x2, 0x2, 0x49d, 0x49e, 
       0x9, 0xe, 0x2, 0x2, 0x49e, 0x67, 0x3, 0x2, 0x2, 0x2, 0x49f, 0x4a0, 
       0x9, 0xf, 0x2, 0x2, 0x4a0, 0x69, 0x3, 0x2, 0x2, 0x2, 0x4a1, 0x4a2, 
       0x9, 0x10, 0x2, 0x2, 0x4a2, 0x6b, 0x3, 0x2, 0x2, 0x2, 0x4a3, 0x4a4, 
       0x7, 0x108, 0x2, 0x2, 0x4a4, 0x4a5, 0x7, 0x1c9, 0x2, 0x2, 0x4a5, 
       0x4a6, 0x9, 0x11, 0x2, 0x2, 0x4a6, 0x6d, 0x3, 0x2, 0x2, 0x2, 0x4a7, 
       0x4a8, 0x7, 0x104, 0x2, 0x2, 0x4a8, 0x4c1, 0x5, 0x170, 0xb9, 0x2, 
       0x4a9, 0x4aa, 0x7, 0x1aa, 0x2, 0x2, 0x4aa, 0x4c1, 0x5, 0x170, 0xb9, 
       0x2, 0x4ab, 0x4ac, 0x7, 0x106, 0x2, 0x2, 0x4ac, 0x4af, 0x7, 0x1c9, 
       0x2, 0x2, 0x4ad, 0x4b0, 0x5, 0x17e, 0xc0, 0x2, 0x4ae, 0x4b0, 0x7, 
       0x1c5, 0x2, 0x2, 0x4af, 0x4ad, 0x3, 0x2, 0x2, 0x2, 0x4af, 0x4ae, 
       0x3, 0x2, 0x2, 0x2, 0x4b0, 0x4c1, 0x3, 0x2, 0x2, 0x2, 0x4b1, 0x4b2, 
       0x7, 0x105, 0x2, 0x2, 0x4b2, 0x4b5, 0x7, 0x1c9, 0x2, 0x2, 0x4b3, 
       0x4b6, 0x5, 0x17e, 0xc0, 0x2, 0x4b4, 0x4b6, 0x7, 0x1c5, 0x2, 0x2, 
       0x4b5, 0x4b3, 0x3, 0x2, 0x2, 0x2, 0x4b5, 0x4b4, 0x3, 0x2, 0x2, 0x2, 
       0x4b6, 0x4c1, 0x3, 0x2, 0x2, 0x2, 0x4b7, 0x4b8, 0x7, 0x151, 0x2, 
       0x2, 0x4b8, 0x4b9, 0x7, 0x1c9, 0x2, 0x2, 0x4b9, 0x4c1, 0x9, 0xb, 
       0x2, 0x2, 0x4ba, 0x4bb, 0x7, 0x1a9, 0x2, 0x2, 0x4bb, 0x4bc, 0x7, 
       0x1c9, 0x2, 0x2, 0x4bc, 0x4c1, 0x9, 0xb, 0x2, 0x2, 0x4bd, 0x4be, 
       0x7, 0x1ac, 0x2, 0x2, 0x4be, 0x4bf, 0x7, 0x1c9, 0x2, 0x2, 0x4bf, 
       0x4c1, 0x7, 0x1c3, 0x2, 0x2, 0x4c0, 0x4a7, 0x3, 0x2, 0x2, 0x2, 0x4c0, 
       0x4a9, 0x3, 0x2, 0x2, 0x2, 0x4c0, 0x4ab, 0x3, 0x2, 0x2, 0x2, 0x4c0, 
       0x4b1, 0x3, 0x2, 0x2, 0x2, 0x4c0, 0x4b7, 0x3, 0x2, 0x2, 0x2, 0x4c0, 
       0x4ba, 0x3, 0x2, 0x2, 0x2, 0x4c0, 0x4bd, 0x3, 0x2, 0x2, 0x2, 0x4c1, 
       0x6f, 0x3, 0x2, 0x2, 0x2, 0x4c2, 0x4c3, 0x7, 0x5, 0x2, 0x2, 0x4c3, 
       0x4c4, 0x7, 0x2e, 0x2, 0x2, 0x4c4, 0x4c5, 0x7, 0xa7, 0x2, 0x2, 0x4c5, 
       0x4c6, 0x7, 0x128, 0x2, 0x2, 0x4c6, 0x71, 0x3, 0x2, 0x2, 0x2, 0x4c7, 
       0x4c8, 0x7, 0x14d, 0x2, 0x2, 0x4c8, 0x4c9, 0x9, 0xb, 0x2, 0x2, 0x4c9, 
       0x73, 0x3, 0x2, 0x2, 0x2, 0x4ca, 0x4cb, 0x7, 0x166, 0x2, 0x2, 0x4cb, 
       0x4cc, 0x9, 0x12, 0x2, 0x2, 0x4cc, 0x75, 0x3, 0x2, 0x2, 0x2, 0x4cd, 
       0x4ce, 0x7, 0x178, 0x2, 0x2, 0x4ce, 0x4d4, 0x9, 0x13, 0x2, 0x2, 0x4cf, 
       0x4d0, 0x7, 0x1a8, 0x2, 0x2, 0x4d0, 0x4d4, 0x5, 0x170, 0xb9, 0x2, 
       0x4d1, 0x4d2, 0x7, 0x165, 0x2, 0x2, 0x4d2, 0x4d4, 0x9, 0x14, 0x2, 
       0x2, 0x4d3, 0x4cd, 0x3, 0x2, 0x2, 0x2, 0x4d3, 0x4cf, 0x3, 0x2, 0x2, 
       0x2, 0x4d3, 0x4d1, 0x3, 0x2, 0x2, 0x2, 0x4d4, 0x77, 0x3, 0x2, 0x2, 
       0x2, 0x4d5, 0x4dc, 0x7, 0x111, 0x2, 0x2, 0x4d6, 0x4dc, 0x7, 0x10e, 
       0x2, 0x2, 0x4d7, 0x4dc, 0x7, 0x152, 0x2, 0x2, 0x4d8, 0x4dc, 0x7, 
       0x113, 0x2, 0x2, 0x4d9, 0x4da, 0x7, 0x12a, 0x2, 0x2, 0x4da, 0x4dc, 
       0x5, 0x170, 0xb9, 0x2, 0x4db, 0x4d5, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4d6, 
       0x3, 0x2, 0x2, 0x2, 0x4db, 0x4d7, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4d8, 
       0x3, 0x2, 0x2, 0x2, 0x4db, 0x4d9, 0x3, 0x2, 0x2, 0x2, 0x4dc, 0x79, 
       0x3, 0x2, 0x2, 0x2, 0x4dd, 0x4de, 0x7, 0xd3, 0x2, 0x2, 0x4de, 0x4e3, 
       0x5, 0x170, 0xb9, 0x2, 0x4df, 0x4e0, 0x7, 0x174, 0x2, 0x2, 0x4e0, 
       0x4e3, 0x9, 0xb, 0x2, 0x2, 0x4e1, 0x4e3, 0x9, 0xb, 0x2, 0x2, 0x4e2, 
       0x4dd, 0x3, 0x2, 0x2, 0x2, 0x4e2, 0x4df, 0x3, 0x2, 0x2, 0x2, 0x4e2, 
       0x4e1, 0x3, 0x2, 0x2, 0x2, 0x4e3, 0x7b, 0x3, 0x2, 0x2, 0x2, 0x4e4, 
       0x4e5, 0x7, 0xd5, 0x2, 0x2, 0x4e5, 0x4fa, 0x5, 0x170, 0xb9, 0x2, 
       0x4e6, 0x4e7, 0x7, 0xd4, 0x2, 0x2, 0x4e7, 0x4fa, 0x5, 0x170, 0xb9, 
       0x2, 0x4e8, 0x4e9, 0x7, 0xd6, 0x2, 0x2, 0x4e9, 0x4fa, 0x5, 0x170, 
       0xb9, 0x2, 0x4ea, 0x4eb, 0x7, 0xd7, 0x2, 0x2, 0x4eb, 0x4fa, 0x5, 
       0x170, 0xb9, 0x2, 0x4ec, 0x4ed, 0x7, 0xd9, 0x2, 0x2, 0x4ed, 0x4fa, 
       0x5, 0x170, 0xb9, 0x2, 0x4ee, 0x4ef, 0x7, 0xf0, 0x2, 0x2, 0x4ef, 
       0x4f0, 0x7, 0x1c9, 0x2, 0x2, 0x4f0, 0x4fa, 0x7, 0x1c3, 0x2, 0x2, 
       0x4f1, 0x4f2, 0x7, 0xf2, 0x2, 0x2, 0x4f2, 0x4fa, 0x5, 0x170, 0xb9, 
       0x2, 0x4f3, 0x4f4, 0x7, 0x15b, 0x2, 0x2, 0x4f4, 0x4fa, 0x5, 0x170, 
       0xb9, 0x2, 0x4f5, 0x4f6, 0x7, 0x170, 0x2, 0x2, 0x4f6, 0x4fa, 0x5, 
       0x170, 0xb9, 0x2, 0x4f7, 0x4f8, 0x7, 0x179, 0x2, 0x2, 0x4f8, 0x4fa, 
       0x5, 0x170, 0xb9, 0x2, 0x4f9, 0x4e4, 0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4e6, 
       0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4e8, 0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4ea, 
       0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4ec, 0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4ee, 
       0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4f1, 0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4f3, 
       0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4f5, 0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4f7, 
       0x3, 0x2, 0x2, 0x2, 0x4fa, 0x7d, 0x3, 0x2, 0x2, 0x2, 0x4fb, 0x4fc, 
       0x7, 0x1a1, 0x2, 0x2, 0x4fc, 0x4fd, 0x7, 0x1c9, 0x2, 0x2, 0x4fd, 
       0x4fe, 0x7, 0x1c3, 0x2, 0x2, 0x4fe, 0x4ff, 0x9, 0x15, 0x2, 0x2, 0x4ff, 
       0x7f, 0x3, 0x2, 0x2, 0x2, 0x500, 0x501, 0x7, 0x9b, 0x2, 0x2, 0x501, 
       0x502, 0x7, 0xd1, 0x2, 0x2, 0x502, 0x507, 0x7, 0x1c3, 0x2, 0x2, 0x503, 
       0x504, 0x7, 0x9b, 0x2, 0x2, 0x504, 0x507, 0x7, 0x12d, 0x2, 0x2, 0x505, 
       0x507, 0x7, 0x158, 0x2, 0x2, 0x506, 0x500, 0x3, 0x2, 0x2, 0x2, 0x506, 
       0x503, 0x3, 0x2, 0x2, 0x2, 0x506, 0x505, 0x3, 0x2, 0x2, 0x2, 0x507, 
       0x81, 0x3, 0x2, 0x2, 0x2, 0x508, 0x509, 0x7, 0x3a, 0x2, 0x2, 0x509, 
       0x50c, 0x7, 0x5c, 0x2, 0x2, 0x50a, 0x50b, 0x7, 0x5a, 0x2, 0x2, 0x50b, 
       0x50d, 0x7, 0x42, 0x2, 0x2, 0x50c, 0x50a, 0x3, 0x2, 0x2, 0x2, 0x50c, 
       0x50d, 0x3, 0x2, 0x2, 0x2, 0x50d, 0x50e, 0x3, 0x2, 0x2, 0x2, 0x50e, 
       0x511, 0x5, 0x17e, 0xc0, 0x2, 0x50f, 0x510, 0x7, 0x79, 0x2, 0x2, 
       0x510, 0x512, 0x5, 0x162, 0xb2, 0x2, 0x511, 0x50f, 0x3, 0x2, 0x2, 
       0x2, 0x511, 0x512, 0x3, 0x2, 0x2, 0x2, 0x512, 0x514, 0x3, 0x2, 0x2, 
       0x2, 0x513, 0x515, 0x7, 0x1dd, 0x2, 0x2, 0x514, 0x513, 0x3, 0x2, 
       0x2, 0x2, 0x514, 0x515, 0x3, 0x2, 0x2, 0x2, 0x515, 0x83, 0x3, 0x2, 
       0x2, 0x2, 0x516, 0x517, 0x7, 0x3a, 0x2, 0x2, 0x517, 0x51a, 0x7, 0x8c, 
       0x2, 0x2, 0x518, 0x519, 0x7, 0x5a, 0x2, 0x2, 0x519, 0x51b, 0x7, 0x42, 
       0x2, 0x2, 0x51a, 0x518, 0x3, 0x2, 0x2, 0x2, 0x51a, 0x51b, 0x3, 0x2, 
       0x2, 0x2, 0x51b, 0x51c, 0x3, 0x2, 0x2, 0x2, 0x51c, 0x51e, 0x5, 0x166, 
       0xb4, 0x2, 0x51d, 0x51f, 0x7, 0x1dd, 0x2, 0x2, 0x51e, 0x51d, 0x3, 
       0x2, 0x2, 0x2, 0x51e, 0x51f, 0x3, 0x2, 0x2, 0x2, 0x51f, 0x85, 0x3, 
       0x2, 0x2, 0x2, 0x520, 0x521, 0x7, 0x3a, 0x2, 0x2, 0x521, 0x525, 0x7, 
       0xac, 0x2, 0x2, 0x522, 0x523, 0x5, 0x162, 0xb2, 0x2, 0x523, 0x524, 
       0x7, 0x1d5, 0x2, 0x2, 0x524, 0x526, 0x3, 0x2, 0x2, 0x2, 0x525, 0x522, 
       0x3, 0x2, 0x2, 0x2, 0x525, 0x526, 0x3, 0x2, 0x2, 0x2, 0x526, 0x527, 
       0x3, 0x2, 0x2, 0x2, 0x527, 0x528, 0x5, 0x17e, 0xc0, 0x2, 0x528, 0x529, 
       0x7, 0x1dd, 0x2, 0x2, 0x529, 0x87, 0x3, 0x2, 0x2, 0x2, 0x52a, 0x52b, 
       0x7, 0x3a, 0x2, 0x2, 0x52b, 0x52e, 0x7, 0xb0, 0x2, 0x2, 0x52c, 0x52d, 
       0x7, 0x5a, 0x2, 0x2, 0x52d, 0x52f, 0x7, 0x42, 0x2, 0x2, 0x52e, 0x52c, 
       0x3, 0x2, 0x2, 0x2, 0x52e, 0x52f, 0x3, 0x2, 0x2, 0x2, 0x52f, 0x530, 
       0x3, 0x2, 0x2, 0x2, 0x530, 0x532, 0x5, 0x162, 0xb2, 0x2, 0x531, 0x533, 
       0x7, 0x1dd, 0x2, 0x2, 0x532, 0x531, 0x3, 0x2, 0x2, 0x2, 0x532, 0x533, 
       0x3, 0x2, 0x2, 0x2, 0x533, 0x89, 0x3, 0x2, 0x2, 0x2, 0x534, 0x535, 
       0x7, 0x3a, 0x2, 0x2, 0x535, 0x538, 0x7, 0x2e, 0x2, 0x2, 0x536, 0x537, 
       0x7, 0x5a, 0x2, 0x2, 0x537, 0x539, 0x7, 0x42, 0x2, 0x2, 0x538, 0x536, 
       0x3, 0x2, 0x2, 0x2, 0x538, 0x539, 0x3, 0x2, 0x2, 0x2, 0x539, 0x53c, 
       0x3, 0x2, 0x2, 0x2, 0x53a, 0x53d, 0x5, 0x17e, 0xc0, 0x2, 0x53b, 0x53d, 
       0x7, 0x28, 0x2, 0x2, 0x53c, 0x53a, 0x3, 0x2, 0x2, 0x2, 0x53c, 0x53b, 
       0x3, 0x2, 0x2, 0x2, 0x53d, 0x53f, 0x3, 0x2, 0x2, 0x2, 0x53e, 0x540, 
       0x7, 0x1dd, 0x2, 0x2, 0x53f, 0x53e, 0x3, 0x2, 0x2, 0x2, 0x53f, 0x540, 
       0x3, 0x2, 0x2, 0x2, 0x540, 0x8b, 0x3, 0x2, 0x2, 0x2, 0x541, 0x542, 
       0x7, 0x3a, 0x2, 0x2, 0x542, 0x545, 0x7, 0xad, 0x2, 0x2, 0x543, 0x544, 
       0x7, 0x5a, 0x2, 0x2, 0x544, 0x546, 0x7, 0x42, 0x2, 0x2, 0x545, 0x543, 
       0x3, 0x2, 0x2, 0x2, 0x545, 0x546, 0x3, 0x2, 0x2, 0x2, 0x546, 0x547, 
       0x3, 0x2, 0x2, 0x2, 0x547, 0x549, 0x5, 0x164, 0xb3, 0x2, 0x548, 0x54a, 
       0x7, 0x1dd, 0x2, 0x2, 0x549, 0x548, 0x3, 0x2, 0x2, 0x2, 0x549, 0x54a, 
       0x3, 0x2, 0x2, 0x2, 0x54a, 0x8d, 0x3, 0x2, 0x2, 0x2, 0x54b, 0x54c, 
       0x7, 0x3a, 0x2, 0x2, 0x54c, 0x54f, 0x7, 0xc8, 0x2, 0x2, 0x54d, 0x54e, 
       0x7, 0x5a, 0x2, 0x2, 0x54e, 0x550, 0x7, 0x42, 0x2, 0x2, 0x54f, 0x54d, 
       0x3, 0x2, 0x2, 0x2, 0x54f, 0x550, 0x3, 0x2, 0x2, 0x2, 0x550, 0x551, 
       0x3, 0x2, 0x2, 0x2, 0x551, 0x556, 0x5, 0x164, 0xb3, 0x2, 0x552, 0x553, 
       0x7, 0x1dc, 0x2, 0x2, 0x553, 0x555, 0x5, 0x164, 0xb3, 0x2, 0x554, 
       0x552, 0x3, 0x2, 0x2, 0x2, 0x555, 0x558, 0x3, 0x2, 0x2, 0x2, 0x556, 
       0x554, 0x3, 0x2, 0x2, 0x2, 0x556, 0x557, 0x3, 0x2, 0x2, 0x2, 0x557, 
       0x55a, 0x3, 0x2, 0x2, 0x2, 0x558, 0x556, 0x3, 0x2, 0x2, 0x2, 0x559, 
       0x55b, 0x7, 0x1dd, 0x2, 0x2, 0x55a, 0x559, 0x3, 0x2, 0x2, 0x2, 0x55a, 
       0x55b, 0x3, 0x2, 0x2, 0x2, 0x55b, 0x8f, 0x3, 0x2, 0x2, 0x2, 0x55c, 
       0x55d, 0x7, 0x3a, 0x2, 0x2, 0x55d, 0x560, 0x7, 0xa0, 0x2, 0x2, 0x55e, 
       0x55f, 0x7, 0x5a, 0x2, 0x2, 0x55f, 0x561, 0x7, 0x42, 0x2, 0x2, 0x560, 
       0x55e, 0x3, 0x2, 0x2, 0x2, 0x560, 0x561, 0x3, 0x2, 0x2, 0x2, 0x561, 
       0x562, 0x3, 0x2, 0x2, 0x2, 0x562, 0x564, 0x5, 0x164, 0xb3, 0x2, 0x563, 
       0x565, 0x7, 0x1dd, 0x2, 0x2, 0x564, 0x563, 0x3, 0x2, 0x2, 0x2, 0x564, 
       0x565, 0x3, 0x2, 0x2, 0x2, 0x565, 0x91, 0x3, 0x2, 0x2, 0x2, 0x566, 
       0x567, 0x7, 0x26, 0x2, 0x2, 0x567, 0x568, 0x7, 0x1ad, 0x2, 0x2, 0x568, 
       0x569, 0x5, 0x164, 0xb3, 0x2, 0x569, 0x56a, 0x7, 0x4f, 0x2, 0x2, 
       0x56a, 0x56b, 0x5, 0x19c, 0xcf, 0x2, 0x56b, 0x56c, 0x5, 0x178, 0xbd, 
       0x2, 0x56c, 0x93, 0x3, 0x2, 0x2, 0x2, 0x56d, 0x56e, 0x7, 0x3a, 0x2, 
       0x2, 0x56e, 0x571, 0x7, 0x1ad, 0x2, 0x2, 0x56f, 0x570, 0x7, 0x5a, 
       0x2, 0x2, 0x570, 0x572, 0x7, 0x42, 0x2, 0x2, 0x571, 0x56f, 0x3, 0x2, 
       0x2, 0x2, 0x571, 0x572, 0x3, 0x2, 0x2, 0x2, 0x572, 0x573, 0x3, 0x2, 
       0x2, 0x2, 0x573, 0x574, 0x5, 0x164, 0xb3, 0x2, 0x574, 0x95, 0x3, 
       0x2, 0x2, 0x2, 0x575, 0x578, 0x5, 0x98, 0x4d, 0x2, 0x576, 0x578, 
       0x5, 0x9a, 0x4e, 0x2, 0x577, 0x575, 0x3, 0x2, 0x2, 0x2, 0x577, 0x576, 
       0x3, 0x2, 0x2, 0x2, 0x578, 0x97, 0x3, 0x2, 0x2, 0x2, 0x579, 0x57a, 
       0x7, 0x7c, 0x2, 0x2, 0x57a, 0x57b, 0x7, 0x1da, 0x2, 0x2, 0x57b, 0x57c, 
       0x5, 0x17e, 0xc0, 0x2, 0x57c, 0x57d, 0x7, 0x1dc, 0x2, 0x2, 0x57d, 
       0x57e, 0x7, 0x1c5, 0x2, 0x2, 0x57e, 0x57f, 0x7, 0x1db, 0x2, 0x2, 
       0x57f, 0x99, 0x3, 0x2, 0x2, 0x2, 0x580, 0x581, 0x7, 0x7b, 0x2, 0x2, 
       0x581, 0x582, 0x7, 0x1da, 0x2, 0x2, 0x582, 0x583, 0x7, 0x1c5, 0x2, 
       0x2, 0x583, 0x584, 0x7, 0x1dc, 0x2, 0x2, 0x584, 0x585, 0x7, 0x1c5, 
       0x2, 0x2, 0x585, 0x586, 0x7, 0x1db, 0x2, 0x2, 0x586, 0x588, 0x7, 
       0x1d5, 0x2, 0x2, 0x587, 0x589, 0x5, 0x17e, 0xc0, 0x2, 0x588, 0x587, 
       0x3, 0x2, 0x2, 0x2, 0x588, 0x589, 0x3, 0x2, 0x2, 0x2, 0x589, 0x58a, 
       0x3, 0x2, 0x2, 0x2, 0x58a, 0x58c, 0x7, 0x1d5, 0x2, 0x2, 0x58b, 0x58d, 
       0x5, 0x17e, 0xc0, 0x2, 0x58c, 0x58b, 0x3, 0x2, 0x2, 0x2, 0x58c, 0x58d, 
       0x3, 0x2, 0x2, 0x2, 0x58d, 0x58e, 0x3, 0x2, 0x2, 0x2, 0x58e, 0x58f, 
       0x7, 0x1d5, 0x2, 0x2, 0x58f, 0x590, 0x5, 0x17e, 0xc0, 0x2, 0x590, 
       0x9b, 0x3, 0x2, 0x2, 0x2, 0x591, 0x592, 0x7, 0x31, 0x2, 0x2, 0x592, 
       0x594, 0x7, 0x1c2, 0x2, 0x2, 0x593, 0x595, 0x7, 0x8, 0x2, 0x2, 0x594, 
       0x593, 0x3, 0x2, 0x2, 0x2, 0x594, 0x595, 0x3, 0x2, 0x2, 0x2, 0x595, 
       0x596, 0x3, 0x2, 0x2, 0x2, 0x596, 0x598, 0x5, 0xb6, 0x5c, 0x2, 0x597, 
       0x599, 0x7, 0x1dd, 0x2, 0x2, 0x598, 0x597, 0x3, 0x2, 0x2, 0x2, 0x598, 
       0x599, 0x3, 0x2, 0x2, 0x2, 0x599, 0x5a7, 0x3, 0x2, 0x2, 0x2, 0x59a, 
       0x59b, 0x7, 0x31, 0x2, 0x2, 0x59b, 0x5a0, 0x5, 0xb4, 0x5b, 0x2, 0x59c, 
       0x59d, 0x7, 0x1dc, 0x2, 0x2, 0x59d, 0x59f, 0x5, 0xb4, 0x5b, 0x2, 
       0x59e, 0x59c, 0x3, 0x2, 0x2, 0x2, 0x59f, 0x5a2, 0x3, 0x2, 0x2, 0x2, 
       0x5a0, 0x59e, 0x3, 0x2, 0x2, 0x2, 0x5a0, 0x5a1, 0x3, 0x2, 0x2, 0x2, 
       0x5a1, 0x5a4, 0x3, 0x2, 0x2, 0x2, 0x5a2, 0x5a0, 0x3, 0x2, 0x2, 0x2, 
       0x5a3, 0x5a5, 0x7, 0x1dd, 0x2, 0x2, 0x5a4, 0x5a3, 0x3, 0x2, 0x2, 
       0x2, 0x5a4, 0x5a5, 0x3, 0x2, 0x2, 0x2, 0x5a5, 0x5a7, 0x3, 0x2, 0x2, 
       0x2, 0x5a6, 0x591, 0x3, 0x2, 0x2, 0x2, 0x5a6, 0x59a, 0x3, 0x2, 0x2, 
       0x2, 0x5a7, 0x9d, 0x3, 0x2, 0x2, 0x2, 0x5a8, 0x5aa, 0x7, 0x19, 0x2, 
       0x2, 0x5a9, 0x5ab, 0x7, 0x124, 0x2, 0x2, 0x5aa, 0x5a9, 0x3, 0x2, 
       0x2, 0x2, 0x5aa, 0x5ab, 0x3, 0x2, 0x2, 0x2, 0x5ab, 0x5ac, 0x3, 0x2, 
       0x2, 0x2, 0x5ac, 0x5ae, 0x5, 0x16e, 0xb8, 0x2, 0x5ad, 0x5af, 0x7, 
       0x1dd, 0x2, 0x2, 0x5ae, 0x5ad, 0x3, 0x2, 0x2, 0x2, 0x5ae, 0x5af, 
       0x3, 0x2, 0x2, 0x2, 0x5af, 0x5c3, 0x3, 0x2, 0x2, 0x2, 0x5b0, 0x5b2, 
       0x7, 0x30, 0x2, 0x2, 0x5b1, 0x5b3, 0x7, 0x124, 0x2, 0x2, 0x5b2, 0x5b1, 
       0x3, 0x2, 0x2, 0x2, 0x5b2, 0x5b3, 0x3, 0x2, 0x2, 0x2, 0x5b3, 0x5b4, 
       0x3, 0x2, 0x2, 0x2, 0x5b4, 0x5b6, 0x5, 0x16e, 0xb8, 0x2, 0x5b5, 0x5b7, 
       0x7, 0x1dd, 0x2, 0x2, 0x5b6, 0x5b5, 0x3, 0x2, 0x2, 0x2, 0x5b6, 0x5b7, 
       0x3, 0x2, 0x2, 0x2, 0x5b7, 0x5c3, 0x3, 0x2, 0x2, 0x2, 0x5b8, 0x5c3, 
       0x5, 0xc6, 0x64, 0x2, 0x5b9, 0x5c3, 0x5, 0xca, 0x66, 0x2, 0x5ba, 
       0x5bc, 0x7, 0x7a, 0x2, 0x2, 0x5bb, 0x5bd, 0x7, 0x124, 0x2, 0x2, 0x5bc, 
       0x5bb, 0x3, 0x2, 0x2, 0x2, 0x5bc, 0x5bd, 0x3, 0x2, 0x2, 0x2, 0x5bd, 
       0x5be, 0x3, 0x2, 0x2, 0x2, 0x5be, 0x5c0, 0x5, 0x16e, 0xb8, 0x2, 0x5bf, 
       0x5c1, 0x7, 0x1dd, 0x2, 0x2, 0x5c0, 0x5bf, 0x3, 0x2, 0x2, 0x2, 0x5c0, 
       0x5c1, 0x3, 0x2, 0x2, 0x2, 0x5c1, 0x5c3, 0x3, 0x2, 0x2, 0x2, 0x5c2, 
       0x5a8, 0x3, 0x2, 0x2, 0x2, 0x5c2, 0x5b0, 0x3, 0x2, 0x2, 0x2, 0x5c2, 
       0x5b8, 0x3, 0x2, 0x2, 0x2, 0x5c2, 0x5b9, 0x3, 0x2, 0x2, 0x2, 0x5c2, 
       0x5ba, 0x3, 0x2, 0x2, 0x2, 0x5c3, 0x9f, 0x3, 0x2, 0x2, 0x2, 0x5c4, 
       0x5c7, 0x7, 0x41, 0x2, 0x2, 0x5c5, 0x5c6, 0x7, 0x1c2, 0x2, 0x2, 0x5c6, 
       0x5c8, 0x7, 0x1c9, 0x2, 0x2, 0x5c7, 0x5c5, 0x3, 0x2, 0x2, 0x2, 0x5c7, 
       0x5c8, 0x3, 0x2, 0x2, 0x2, 0x5c8, 0x5c9, 0x3, 0x2, 0x2, 0x2, 0x5c9, 
       0x5d2, 0x5, 0x166, 0xb4, 0x2, 0x5ca, 0x5cf, 0x5, 0xa2, 0x52, 0x2, 
       0x5cb, 0x5cc, 0x7, 0x1dc, 0x2, 0x2, 0x5cc, 0x5ce, 0x5, 0xa2, 0x52, 
       0x2, 0x5cd, 0x5cb, 0x3, 0x2, 0x2, 0x2, 0x5ce, 0x5d1, 0x3, 0x2, 0x2, 
       0x2, 0x5cf, 0x5cd, 0x3, 0x2, 0x2, 0x2, 0x5cf, 0x5d0, 0x3, 0x2, 0x2, 
       0x2, 0x5d0, 0x5d3, 0x3, 0x2, 0x2, 0x2, 0x5d1, 0x5cf, 0x3, 0x2, 0x2, 
       0x2, 0x5d2, 0x5ca, 0x3, 0x2, 0x2, 0x2, 0x5d2, 0x5d3, 0x3, 0x2, 0x2, 
       0x2, 0x5d3, 0x5d5, 0x3, 0x2, 0x2, 0x2, 0x5d4, 0x5d6, 0x7, 0x1dd, 
       0x2, 0x2, 0x5d5, 0x5d4, 0x3, 0x2, 0x2, 0x2, 0x5d5, 0x5d6, 0x3, 0x2, 
       0x2, 0x2, 0x5d6, 0x5ee, 0x3, 0x2, 0x2, 0x2, 0x5d7, 0x5d8, 0x7, 0x41, 
       0x2, 0x2, 0x5d8, 0x5d9, 0x7, 0x1da, 0x2, 0x2, 0x5d9, 0x5de, 0x5, 
       0xa4, 0x53, 0x2, 0x5da, 0x5db, 0x7, 0x1e2, 0x2, 0x2, 0x5db, 0x5dd, 
       0x5, 0xa4, 0x53, 0x2, 0x5dc, 0x5da, 0x3, 0x2, 0x2, 0x2, 0x5dd, 0x5e0, 
       0x3, 0x2, 0x2, 0x2, 0x5de, 0x5dc, 0x3, 0x2, 0x2, 0x2, 0x5de, 0x5df, 
       0x3, 0x2, 0x2, 0x2, 0x5df, 0x5e1, 0x3, 0x2, 0x2, 0x2, 0x5e0, 0x5de, 
       0x3, 0x2, 0x2, 0x2, 0x5e1, 0x5e8, 0x7, 0x1db, 0x2, 0x2, 0x5e2, 0x5e4, 
       0x7, 0x8, 0x2, 0x2, 0x5e3, 0x5e2, 0x3, 0x2, 0x2, 0x2, 0x5e3, 0x5e4, 
       0x3, 0x2, 0x2, 0x2, 0x5e4, 0x5e5, 0x3, 0x2, 0x2, 0x2, 0x5e5, 0x5e6, 
       0x9, 0x16, 0x2, 0x2, 0x5e6, 0x5e7, 0x7, 0x1c9, 0x2, 0x2, 0x5e7, 0x5e9, 
       0x7, 0x1c5, 0x2, 0x2, 0x5e8, 0x5e3, 0x3, 0x2, 0x2, 0x2, 0x5e8, 0x5e9, 
       0x3, 0x2, 0x2, 0x2, 0x5e9, 0x5eb, 0x3, 0x2, 0x2, 0x2, 0x5ea, 0x5ec, 
       0x7, 0x1dd, 0x2, 0x2, 0x5eb, 0x5ea, 0x3, 0x2, 0x2, 0x2, 0x5eb, 0x5ec, 
       0x3, 0x2, 0x2, 0x2, 0x5ec, 0x5ee, 0x3, 0x2, 0x2, 0x2, 0x5ed, 0x5c4, 
       0x3, 0x2, 0x2, 0x2, 0x5ed, 0x5d7, 0x3, 0x2, 0x2, 0x2, 0x5ee, 0xa1, 
       0x3, 0x2, 0x2, 0x2, 0x5ef, 0x5f0, 0x7, 0x1c2, 0x2, 0x2, 0x5f0, 0x5f2, 
       0x7, 0x1c9, 0x2, 0x2, 0x5f1, 0x5ef, 0x3, 0x2, 0x2, 0x2, 0x5f1, 0x5f2, 
       0x3, 0x2, 0x2, 0x2, 0x5f2, 0x5fc, 0x3, 0x2, 0x2, 0x2, 0x5f3, 0x5f6, 
       0x5, 0xce, 0x68, 0x2, 0x5f4, 0x5f6, 0x5, 0x17e, 0xc0, 0x2, 0x5f5, 
       0x5f3, 0x3, 0x2, 0x2, 0x2, 0x5f5, 0x5f4, 0x3, 0x2, 0x2, 0x2, 0x5f6, 
       0x5f8, 0x3, 0x2, 0x2, 0x2, 0x5f7, 0x5f9, 0x9, 0x17, 0x2, 0x2, 0x5f8, 
       0x5f7, 0x3, 0x2, 0x2, 0x2, 0x5f8, 0x5f9, 0x3, 0x2, 0x2, 0x2, 0x5f9, 
       0x5fd, 0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5fd, 0x7, 0x32, 0x2, 0x2, 0x5fb, 
       0x5fd, 0x7, 0x73, 0x2, 0x2, 0x5fc, 0x5f5, 0x3, 0x2, 0x2, 0x2, 0x5fc, 
       0x5fa, 0x3, 0x2, 0x2, 0x2, 0x5fc, 0x5fb, 0x3, 0x2, 0x2, 0x2, 0x5fd, 
       0xa3, 0x3, 0x2, 0x2, 0x2, 0x5fe, 0x5ff, 0x9, 0x3, 0x2, 0x2, 0x5ff, 
       0xa5, 0x3, 0x2, 0x2, 0x2, 0x600, 0x602, 0x5, 0xb2, 0x5a, 0x2, 0x601, 
       0x603, 0x7, 0x1dd, 0x2, 0x2, 0x602, 0x601, 0x3, 0x2, 0x2, 0x2, 0x602, 
       0x603, 0x3, 0x2, 0x2, 0x2, 0x603, 0x631, 0x3, 0x2, 0x2, 0x2, 0x604, 
       0x610, 0x7, 0x53, 0x2, 0x2, 0x605, 0x607, 0x7, 0x4, 0x2, 0x2, 0x606, 
       0x608, 0x7, 0x16e, 0x2, 0x2, 0x607, 0x606, 0x3, 0x2, 0x2, 0x2, 0x607, 
       0x608, 0x3, 0x2, 0x2, 0x2, 0x608, 0x611, 0x3, 0x2, 0x2, 0x2, 0x609, 
       0x60e, 0x5, 0xa8, 0x55, 0x2, 0x60a, 0x60b, 0x7, 0x1da, 0x2, 0x2, 
       0x60b, 0x60c, 0x5, 0x16c, 0xb7, 0x2, 0x60c, 0x60d, 0x7, 0x1db, 0x2, 
       0x2, 0x60d, 0x60f, 0x3, 0x2, 0x2, 0x2, 0x60e, 0x60a, 0x3, 0x2, 0x2, 
       0x2, 0x60e, 0x60f, 0x3, 0x2, 0x2, 0x2, 0x60f, 0x611, 0x3, 0x2, 0x2, 
       0x2, 0x610, 0x605, 0x3, 0x2, 0x2, 0x2, 0x610, 0x609, 0x3, 0x2, 0x2, 
       0x2, 0x611, 0x614, 0x3, 0x2, 0x2, 0x2, 0x612, 0x613, 0x7, 0x79, 0x2, 
       0x2, 0x613, 0x615, 0x5, 0x162, 0xb2, 0x2, 0x614, 0x612, 0x3, 0x2, 
       0x2, 0x2, 0x614, 0x615, 0x3, 0x2, 0x2, 0x2, 0x615, 0x616, 0x3, 0x2, 
       0x2, 0x2, 0x616, 0x617, 0x7, 0xb4, 0x2, 0x2, 0x617, 0x61b, 0x5, 0x17e, 
       0xc0, 0x2, 0x618, 0x619, 0x7, 0xcd, 0x2, 0x2, 0x619, 0x61a, 0x7, 
       0x53, 0x2, 0x2, 0x61a, 0x61c, 0x7, 0x7f, 0x2, 0x2, 0x61b, 0x618, 
       0x3, 0x2, 0x2, 0x2, 0x61b, 0x61c, 0x3, 0x2, 0x2, 0x2, 0x61c, 0x61f, 
       0x3, 0x2, 0x2, 0x2, 0x61d, 0x61e, 0x7, 0x8, 0x2, 0x2, 0x61e, 0x620, 
       0x5, 0x17e, 0xc0, 0x2, 0x61f, 0x61d, 0x3, 0x2, 0x2, 0x2, 0x61f, 0x620, 
       0x3, 0x2, 0x2, 0x2, 0x620, 0x622, 0x3, 0x2, 0x2, 0x2, 0x621, 0x623, 
       0x7, 0x1dd, 0x2, 0x2, 0x622, 0x621, 0x3, 0x2, 0x2, 0x2, 0x622, 0x623, 
       0x3, 0x2, 0x2, 0x2, 0x623, 0x631, 0x3, 0x2, 0x2, 0x2, 0x624, 0x62b, 
       0x7, 0x98, 0x2, 0x2, 0x625, 0x626, 0x7, 0x1da, 0x2, 0x2, 0x626, 0x627, 
       0x7, 0xcd, 0x2, 0x2, 0x627, 0x628, 0x7, 0xf4, 0x2, 0x2, 0x628, 0x629, 
       0x7, 0x1c9, 0x2, 0x2, 0x629, 0x62a, 0x7, 0x1c2, 0x2, 0x2, 0x62a, 
       0x62c, 0x7, 0x1db, 0x2, 0x2, 0x62b, 0x625, 0x3, 0x2, 0x2, 0x2, 0x62b, 
       0x62c, 0x3, 0x2, 0x2, 0x2, 0x62c, 0x62e, 0x3, 0x2, 0x2, 0x2, 0x62d, 
       0x62f, 0x7, 0x1dd, 0x2, 0x2, 0x62e, 0x62d, 0x3, 0x2, 0x2, 0x2, 0x62e, 
       0x62f, 0x3, 0x2, 0x2, 0x2, 0x62f, 0x631, 0x3, 0x2, 0x2, 0x2, 0x630, 
       0x600, 0x3, 0x2, 0x2, 0x2, 0x630, 0x604, 0x3, 0x2, 0x2, 0x2, 0x630, 
       0x624, 0x3, 0x2, 0x2, 0x2, 0x631, 0xa7, 0x3, 0x2, 0x2, 0x2, 0x632, 
       0x64d, 0x7, 0x41, 0x2, 0x2, 0x633, 0x634, 0x7, 0xc8, 0x2, 0x2, 0x634, 
       0x64d, 0x5, 0x17e, 0xc0, 0x2, 0x635, 0x636, 0x7, 0x19f, 0x2, 0x2, 
       0x636, 0x64d, 0x5, 0x17e, 0xc0, 0x2, 0x637, 0x639, 0x7, 0xf3, 0x2, 
       0x2, 0x638, 0x63a, 0x5, 0x17e, 0xc0, 0x2, 0x639, 0x638, 0x3, 0x2, 
       0x2, 0x2, 0x639, 0x63a, 0x3, 0x2, 0x2, 0x2, 0x63a, 0x64d, 0x3, 0x2, 
       0x2, 0x2, 0x63b, 0x63c, 0x7, 0x26, 0x2, 0x2, 0x63c, 0x64d, 0x9, 0x18, 
       0x2, 0x2, 0x63d, 0x64d, 0x7, 0x18e, 0x2, 0x2, 0x63e, 0x64d, 0x7, 
       0x12e, 0x2, 0x2, 0x63f, 0x64d, 0x7, 0xa2, 0x2, 0x2, 0x640, 0x64d, 
       0x7, 0x92, 0x2, 0x2, 0x641, 0x64d, 0x7, 0x5f, 0x2, 0x2, 0x642, 0x64a, 
       0x7, 0x5, 0x2, 0x2, 0x643, 0x645, 0x7, 0x7, 0x2, 0x2, 0x644, 0x643, 
       0x3, 0x2, 0x2, 0x2, 0x644, 0x645, 0x3, 0x2, 0x2, 0x2, 0x645, 0x648, 
       0x3, 0x2, 0x2, 0x2, 0x646, 0x649, 0x5, 0x17e, 0xc0, 0x2, 0x647, 0x649, 
       0x7, 0x2e, 0x2, 0x2, 0x648, 0x646, 0x3, 0x2, 0x2, 0x2, 0x648, 0x647, 
       0x3, 0x2, 0x2, 0x2, 0x649, 0x64b, 0x3, 0x2, 0x2, 0x2, 0x64a, 0x644, 
       0x3, 0x2, 0x2, 0x2, 0x64a, 0x64b, 0x3, 0x2, 0x2, 0x2, 0x64b, 0x64d, 
       0x3, 0x2, 0x2, 0x2, 0x64c, 0x632, 0x3, 0x2, 0x2, 0x2, 0x64c, 0x633, 
       0x3, 0x2, 0x2, 0x2, 0x64c, 0x635, 0x3, 0x2, 0x2, 0x2, 0x64c, 0x637, 
       0x3, 0x2, 0x2, 0x2, 0x64c, 0x63b, 0x3, 0x2, 0x2, 0x2, 0x64c, 0x63d, 
       0x3, 0x2, 0x2, 0x2, 0x64c, 0x63e, 0x3, 0x2, 0x2, 0x2, 0x64c, 0x63f, 
       0x3, 0x2, 0x2, 0x2, 0x64c, 0x640, 0x3, 0x2, 0x2, 0x2, 0x64c, 0x641, 
       0x3, 0x2, 0x2, 0x2, 0x64c, 0x642, 0x3, 0x2, 0x2, 0x2, 0x64d, 0xa9, 
       0x3, 0x2, 0x2, 0x2, 0x64e, 0x64f, 0x7, 0xa7, 0x2, 0x2, 0x64f, 0x652, 
       0x7, 0x1c2, 0x2, 0x2, 0x650, 0x651, 0x7, 0x1d5, 0x2, 0x2, 0x651, 
       0x653, 0x5, 0x17e, 0xc0, 0x2, 0x652, 0x650, 0x3, 0x2, 0x2, 0x2, 0x652, 
       0x653, 0x3, 0x2, 0x2, 0x2, 0x653, 0x654, 0x3, 0x2, 0x2, 0x2, 0x654, 
       0x655, 0x7, 0x1c9, 0x2, 0x2, 0x655, 0x657, 0x5, 0xd0, 0x69, 0x2, 
       0x656, 0x658, 0x7, 0x1dd, 0x2, 0x2, 0x657, 0x656, 0x3, 0x2, 0x2, 
       0x2, 0x657, 0x658, 0x3, 0x2, 0x2, 0x2, 0x658, 0x676, 0x3, 0x2, 0x2, 
       0x2, 0x659, 0x65a, 0x7, 0xa7, 0x2, 0x2, 0x65a, 0x65b, 0x7, 0x1c2, 
       0x2, 0x2, 0x65b, 0x65c, 0x5, 0x184, 0xc3, 0x2, 0x65c, 0x65e, 0x5, 
       0xd0, 0x69, 0x2, 0x65d, 0x65f, 0x7, 0x1dd, 0x2, 0x2, 0x65e, 0x65d, 
       0x3, 0x2, 0x2, 0x2, 0x65e, 0x65f, 0x3, 0x2, 0x2, 0x2, 0x65f, 0x676, 
       0x3, 0x2, 0x2, 0x2, 0x660, 0x661, 0x7, 0xa7, 0x2, 0x2, 0x661, 0x662, 
       0x7, 0x1c2, 0x2, 0x2, 0x662, 0x663, 0x7, 0x1c9, 0x2, 0x2, 0x663, 
       0x664, 0x7, 0x2d, 0x2, 0x2, 0x664, 0x66f, 0x5, 0xc8, 0x65, 0x2, 0x665, 
       0x66d, 0x7, 0x4a, 0x2, 0x2, 0x666, 0x667, 0x7, 0x8f, 0x2, 0x2, 0x667, 
       0x66e, 0x7, 0x15f, 0x2, 0x2, 0x668, 0x66b, 0x7, 0xc1, 0x2, 0x2, 0x669, 
       0x66a, 0x7, 0x76, 0x2, 0x2, 0x66a, 0x66c, 0x5, 0x16c, 0xb7, 0x2, 
       0x66b, 0x669, 0x3, 0x2, 0x2, 0x2, 0x66b, 0x66c, 0x3, 0x2, 0x2, 0x2, 
       0x66c, 0x66e, 0x3, 0x2, 0x2, 0x2, 0x66d, 0x666, 0x3, 0x2, 0x2, 0x2, 
       0x66d, 0x668, 0x3, 0x2, 0x2, 0x2, 0x66e, 0x670, 0x3, 0x2, 0x2, 0x2, 
       0x66f, 0x665, 0x3, 0x2, 0x2, 0x2, 0x66f, 0x670, 0x3, 0x2, 0x2, 0x2, 
       0x670, 0x672, 0x3, 0x2, 0x2, 0x2, 0x671, 0x673, 0x7, 0x1dd, 0x2, 
       0x2, 0x672, 0x671, 0x3, 0x2, 0x2, 0x2, 0x672, 0x673, 0x3, 0x2, 0x2, 
       0x2, 0x673, 0x676, 0x3, 0x2, 0x2, 0x2, 0x674, 0x676, 0x5, 0xcc, 0x67, 
       0x2, 0x675, 0x64e, 0x3, 0x2, 0x2, 0x2, 0x675, 0x659, 0x3, 0x2, 0x2, 
       0x2, 0x675, 0x660, 0x3, 0x2, 0x2, 0x2, 0x675, 0x674, 0x3, 0x2, 0x2, 
       0x2, 0x676, 0xab, 0x3, 0x2, 0x2, 0x2, 0x677, 0x678, 0x7, 0xc, 0x2, 
       0x2, 0x678, 0x679, 0x7, 0x38, 0x2, 0x2, 0x679, 0x67c, 0x9, 0x19, 
       0x2, 0x2, 0x67a, 0x67d, 0x5, 0x17e, 0xc0, 0x2, 0x67b, 0x67d, 0x7, 
       0x1c2, 0x2, 0x2, 0x67c, 0x67a, 0x3, 0x2, 0x2, 0x2, 0x67c, 0x67b, 
       0x3, 0x2, 0x2, 0x2, 0x67c, 0x67d, 0x3, 0x2, 0x2, 0x2, 0x67d, 0x67f, 
       0x3, 0x2, 0x2, 0x2, 0x67e, 0x680, 0x7, 0x1dd, 0x2, 0x2, 0x67f, 0x67e, 
       0x3, 0x2, 0x2, 0x2, 0x67f, 0x680, 0x3, 0x2, 0x2, 0x2, 0x680, 0x6c5, 
       0x3, 0x2, 0x2, 0x2, 0x681, 0x682, 0x7, 0xc, 0x2, 0x2, 0x682, 0x68c, 
       0x9, 0x19, 0x2, 0x2, 0x683, 0x686, 0x5, 0x17e, 0xc0, 0x2, 0x684, 
       0x686, 0x7, 0x1c2, 0x2, 0x2, 0x685, 0x683, 0x3, 0x2, 0x2, 0x2, 0x685, 
       0x684, 0x3, 0x2, 0x2, 0x2, 0x686, 0x68a, 0x3, 0x2, 0x2, 0x2, 0x687, 
       0x688, 0x7, 0xcd, 0x2, 0x2, 0x688, 0x689, 0x7, 0x143, 0x2, 0x2, 0x689, 
       0x68b, 0x7, 0x1c5, 0x2, 0x2, 0x68a, 0x687, 0x3, 0x2, 0x2, 0x2, 0x68a, 
       0x68b, 0x3, 0x2, 0x2, 0x2, 0x68b, 0x68d, 0x3, 0x2, 0x2, 0x2, 0x68c, 
       0x685, 0x3, 0x2, 0x2, 0x2, 0x68c, 0x68d, 0x3, 0x2, 0x2, 0x2, 0x68d, 
       0x68f, 0x3, 0x2, 0x2, 0x2, 0x68e, 0x690, 0x7, 0x1dd, 0x2, 0x2, 0x68f, 
       0x68e, 0x3, 0x2, 0x2, 0x2, 0x68f, 0x690, 0x3, 0x2, 0x2, 0x2, 0x690, 
       0x6c5, 0x3, 0x2, 0x2, 0x2, 0x691, 0x692, 0x7, 0x1e, 0x2, 0x2, 0x692, 
       0x69f, 0x9, 0x19, 0x2, 0x2, 0x693, 0x696, 0x5, 0x17e, 0xc0, 0x2, 
       0x694, 0x696, 0x7, 0x1c2, 0x2, 0x2, 0x695, 0x693, 0x3, 0x2, 0x2, 
       0x2, 0x695, 0x694, 0x3, 0x2, 0x2, 0x2, 0x696, 0x69d, 0x3, 0x2, 0x2, 
       0x2, 0x697, 0x698, 0x7, 0xcd, 0x2, 0x2, 0x698, 0x699, 0x7, 0x1da, 
       0x2, 0x2, 0x699, 0x69a, 0x7, 0x108, 0x2, 0x2, 0x69a, 0x69b, 0x7, 
       0x1c9, 0x2, 0x2, 0x69b, 0x69c, 0x9, 0xb, 0x2, 0x2, 0x69c, 0x69e, 
       0x7, 0x1db, 0x2, 0x2, 0x69d, 0x697, 0x3, 0x2, 0x2, 0x2, 0x69d, 0x69e, 
       0x3, 0x2, 0x2, 0x2, 0x69e, 0x6a0, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x695, 
       0x3, 0x2, 0x2, 0x2, 0x69f, 0x6a0, 0x3, 0x2, 0x2, 0x2, 0x6a0, 0x6a2, 
       0x3, 0x2, 0x2, 0x2, 0x6a1, 0x6a3, 0x7, 0x1dd, 0x2, 0x2, 0x6a2, 0x6a1, 
       0x3, 0x2, 0x2, 0x2, 0x6a2, 0x6a3, 0x3, 0x2, 0x2, 0x2, 0x6a3, 0x6c5, 
       0x3, 0x2, 0x2, 0x2, 0x6a4, 0x6a6, 0x7, 0x1e, 0x2, 0x2, 0x6a5, 0x6a7, 
       0x7, 0x1b8, 0x2, 0x2, 0x6a6, 0x6a5, 0x3, 0x2, 0x2, 0x2, 0x6a6, 0x6a7, 
       0x3, 0x2, 0x2, 0x2, 0x6a7, 0x6a9, 0x3, 0x2, 0x2, 0x2, 0x6a8, 0x6aa, 
       0x7, 0x1dd, 0x2, 0x2, 0x6a9, 0x6a8, 0x3, 0x2, 0x2, 0x2, 0x6a9, 0x6aa, 
       0x3, 0x2, 0x2, 0x2, 0x6aa, 0x6c5, 0x3, 0x2, 0x2, 0x2, 0x6ab, 0x6ac, 
       0x7, 0x9b, 0x2, 0x2, 0x6ac, 0x6af, 0x9, 0x19, 0x2, 0x2, 0x6ad, 0x6b0, 
       0x5, 0x17e, 0xc0, 0x2, 0x6ae, 0x6b0, 0x7, 0x1c2, 0x2, 0x2, 0x6af, 
       0x6ad, 0x3, 0x2, 0x2, 0x2, 0x6af, 0x6ae, 0x3, 0x2, 0x2, 0x2, 0x6af, 
       0x6b0, 0x3, 0x2, 0x2, 0x2, 0x6b0, 0x6b2, 0x3, 0x2, 0x2, 0x2, 0x6b1, 
       0x6b3, 0x7, 0x1dd, 0x2, 0x2, 0x6b2, 0x6b1, 0x3, 0x2, 0x2, 0x2, 0x6b2, 
       0x6b3, 0x3, 0x2, 0x2, 0x2, 0x6b3, 0x6c5, 0x3, 0x2, 0x2, 0x2, 0x6b4, 
       0x6b6, 0x7, 0x9b, 0x2, 0x2, 0x6b5, 0x6b7, 0x7, 0x1b8, 0x2, 0x2, 0x6b6, 
       0x6b5, 0x3, 0x2, 0x2, 0x2, 0x6b6, 0x6b7, 0x3, 0x2, 0x2, 0x2, 0x6b7, 
       0x6b9, 0x3, 0x2, 0x2, 0x2, 0x6b8, 0x6ba, 0x7, 0x1dd, 0x2, 0x2, 0x6b9, 
       0x6b8, 0x3, 0x2, 0x2, 0x2, 0x6b9, 0x6ba, 0x3, 0x2, 0x2, 0x2, 0x6ba, 
       0x6c5, 0x3, 0x2, 0x2, 0x2, 0x6bb, 0x6bc, 0x7, 0x9f, 0x2, 0x2, 0x6bc, 
       0x6bf, 0x9, 0x19, 0x2, 0x2, 0x6bd, 0x6c0, 0x5, 0x17e, 0xc0, 0x2, 
       0x6be, 0x6c0, 0x7, 0x1c2, 0x2, 0x2, 0x6bf, 0x6bd, 0x3, 0x2, 0x2, 
       0x2, 0x6bf, 0x6be, 0x3, 0x2, 0x2, 0x2, 0x6bf, 0x6c0, 0x3, 0x2, 0x2, 
       0x2, 0x6c0, 0x6c2, 0x3, 0x2, 0x2, 0x2, 0x6c1, 0x6c3, 0x7, 0x1dd, 
       0x2, 0x2, 0x6c2, 0x6c1, 0x3, 0x2, 0x2, 0x2, 0x6c2, 0x6c3, 0x3, 0x2, 
       0x2, 0x2, 0x6c3, 0x6c5, 0x3, 0x2, 0x2, 0x2, 0x6c4, 0x677, 0x3, 0x2, 
       0x2, 0x2, 0x6c4, 0x681, 0x3, 0x2, 0x2, 0x2, 0x6c4, 0x691, 0x3, 0x2, 
       0x2, 0x2, 0x6c4, 0x6a4, 0x3, 0x2, 0x2, 0x2, 0x6c4, 0x6ab, 0x3, 0x2, 
       0x2, 0x2, 0x6c4, 0x6b4, 0x3, 0x2, 0x2, 0x2, 0x6c4, 0x6bb, 0x3, 0x2, 
       0x2, 0x2, 0x6c5, 0xad, 0x3, 0x2, 0x2, 0x2, 0x6c6, 0x6c8, 0x7, 0x125, 
       0x2, 0x2, 0x6c7, 0x6c9, 0x7, 0x1c3, 0x2, 0x2, 0x6c8, 0x6c7, 0x3, 
       0x2, 0x2, 0x2, 0x6c8, 0x6c9, 0x3, 0x2, 0x2, 0x2, 0x6c9, 0xaf, 0x3, 
       0x2, 0x2, 0x2, 0x6ca, 0x6cb, 0x7, 0xc3, 0x2, 0x2, 0x6cb, 0x6cd, 0x5, 
       0x17e, 0xc0, 0x2, 0x6cc, 0x6ce, 0x7, 0x1dd, 0x2, 0x2, 0x6cd, 0x6cc, 
       0x3, 0x2, 0x2, 0x2, 0x6cd, 0x6ce, 0x3, 0x2, 0x2, 0x2, 0x6ce, 0xb1, 
       0x3, 0x2, 0x2, 0x2, 0x6cf, 0x6d0, 0x7, 0x41, 0x2, 0x2, 0x6d0, 0x6d1, 
       0x7, 0x8, 0x2, 0x2, 0x6d1, 0x6d2, 0x9, 0x1a, 0x2, 0x2, 0x6d2, 0xb3, 
       0x3, 0x2, 0x2, 0x2, 0x6d3, 0x6d5, 0x7, 0x1c2, 0x2, 0x2, 0x6d4, 0x6d6, 
       0x7, 0x8, 0x2, 0x2, 0x6d5, 0x6d4, 0x3, 0x2, 0x2, 0x2, 0x6d5, 0x6d6, 
       0x3, 0x2, 0x2, 0x2, 0x6d6, 0x6d7, 0x3, 0x2, 0x2, 0x2, 0x6d7, 0x6da, 
       0x5, 0x19c, 0xcf, 0x2, 0x6d8, 0x6d9, 0x7, 0x1c9, 0x2, 0x2, 0x6d9, 
       0x6db, 0x5, 0xd0, 0x69, 0x2, 0x6da, 0x6d8, 0x3, 0x2, 0x2, 0x2, 0x6da, 
       0x6db, 0x3, 0x2, 0x2, 0x2, 0x6db, 0xb5, 0x3, 0x2, 0x2, 0x2, 0x6dc, 
       0x6dd, 0x7, 0xb0, 0x2, 0x2, 0x6dd, 0x6de, 0x7, 0x1da, 0x2, 0x2, 0x6de, 
       0x6df, 0x5, 0xb8, 0x5d, 0x2, 0x6df, 0x6e0, 0x7, 0x1db, 0x2, 0x2, 
       0x6e0, 0xb7, 0x3, 0x2, 0x2, 0x2, 0x6e1, 0x6e8, 0x5, 0xba, 0x5e, 0x2, 
       0x6e2, 0x6e4, 0x7, 0x1dc, 0x2, 0x2, 0x6e3, 0x6e2, 0x3, 0x2, 0x2, 
       0x2, 0x6e3, 0x6e4, 0x3, 0x2, 0x2, 0x2, 0x6e4, 0x6e5, 0x3, 0x2, 0x2, 
       0x2, 0x6e5, 0x6e7, 0x5, 0xba, 0x5e, 0x2, 0x6e6, 0x6e3, 0x3, 0x2, 
       0x2, 0x2, 0x6e7, 0x6ea, 0x3, 0x2, 0x2, 0x2, 0x6e8, 0x6e6, 0x3, 0x2, 
       0x2, 0x2, 0x6e8, 0x6e9, 0x3, 0x2, 0x2, 0x2, 0x6e9, 0xb9, 0x3, 0x2, 
       0x2, 0x2, 0x6ea, 0x6e8, 0x3, 0x2, 0x2, 0x2, 0x6eb, 0x6ee, 0x5, 0xbc, 
       0x5f, 0x2, 0x6ec, 0x6ee, 0x5, 0xc0, 0x61, 0x2, 0x6ed, 0x6eb, 0x3, 
       0x2, 0x2, 0x2, 0x6ed, 0x6ec, 0x3, 0x2, 0x2, 0x2, 0x6ee, 0xbb, 0x3, 
       0x2, 0x2, 0x2, 0x6ef, 0x6f3, 0x5, 0x17e, 0xc0, 0x2, 0x6f0, 0x6f4, 
       0x5, 0x19c, 0xcf, 0x2, 0x6f1, 0x6f2, 0x7, 0x8, 0x2, 0x2, 0x6f2, 0x6f4, 
       0x5, 0xd0, 0x69, 0x2, 0x6f3, 0x6f0, 0x3, 0x2, 0x2, 0x2, 0x6f3, 0x6f1, 
       0x3, 0x2, 0x2, 0x2, 0x6f4, 0x6f7, 0x3, 0x2, 0x2, 0x2, 0x6f5, 0x6f6, 
       0x7, 0x1c, 0x2, 0x2, 0x6f6, 0x6f8, 0x5, 0x17e, 0xc0, 0x2, 0x6f7, 
       0x6f5, 0x3, 0x2, 0x2, 0x2, 0x6f7, 0x6f8, 0x3, 0x2, 0x2, 0x2, 0x6f8, 
       0x6fa, 0x3, 0x2, 0x2, 0x2, 0x6f9, 0x6fb, 0x5, 0x174, 0xbb, 0x2, 0x6fa, 
       0x6f9, 0x3, 0x2, 0x2, 0x2, 0x6fa, 0x6fb, 0x3, 0x2, 0x2, 0x2, 0x6fb, 
       0x713, 0x3, 0x2, 0x2, 0x2, 0x6fc, 0x6fd, 0x7, 0x20, 0x2, 0x2, 0x6fd, 
       0x6ff, 0x5, 0x17e, 0xc0, 0x2, 0x6fe, 0x6fc, 0x3, 0x2, 0x2, 0x2, 0x6fe, 
       0x6ff, 0x3, 0x2, 0x2, 0x2, 0x6ff, 0x700, 0x3, 0x2, 0x2, 0x2, 0x700, 
       0x701, 0x7, 0x32, 0x2, 0x2, 0x701, 0x704, 0x5, 0xd6, 0x6c, 0x2, 0x702, 
       0x703, 0x7, 0xcd, 0x2, 0x2, 0x703, 0x705, 0x7, 0xc5, 0x2, 0x2, 0x704, 
       0x702, 0x3, 0x2, 0x2, 0x2, 0x704, 0x705, 0x3, 0x2, 0x2, 0x2, 0x705, 
       0x714, 0x3, 0x2, 0x2, 0x2, 0x706, 0x70c, 0x7, 0x56, 0x2, 0x2, 0x707, 
       0x708, 0x7, 0x1da, 0x2, 0x2, 0x708, 0x709, 0x7, 0x1c3, 0x2, 0x2, 
       0x709, 0x70a, 0x7, 0x1dc, 0x2, 0x2, 0x70a, 0x70b, 0x7, 0x1c3, 0x2, 
       0x2, 0x70b, 0x70d, 0x7, 0x1db, 0x2, 0x2, 0x70c, 0x707, 0x3, 0x2, 
       0x2, 0x2, 0x70c, 0x70d, 0x3, 0x2, 0x2, 0x2, 0x70d, 0x711, 0x3, 0x2, 
       0x2, 0x2, 0x70e, 0x70f, 0x7, 0x72, 0x2, 0x2, 0x70f, 0x710, 0x7, 0x4a, 
       0x2, 0x2, 0x710, 0x712, 0x7, 0x93, 0x2, 0x2, 0x711, 0x70e, 0x3, 0x2, 
       0x2, 0x2, 0x711, 0x712, 0x3, 0x2, 0x2, 0x2, 0x712, 0x714, 0x3, 0x2, 
       0x2, 0x2, 0x713, 0x6fe, 0x3, 0x2, 0x2, 0x2, 0x713, 0x706, 0x3, 0x2, 
       0x2, 0x2, 0x713, 0x714, 0x3, 0x2, 0x2, 0x2, 0x714, 0x716, 0x3, 0x2, 
       0x2, 0x2, 0x715, 0x717, 0x7, 0x9d, 0x2, 0x2, 0x716, 0x715, 0x3, 0x2, 
       0x2, 0x2, 0x716, 0x717, 0x3, 0x2, 0x2, 0x2, 0x717, 0x71b, 0x3, 0x2, 
       0x2, 0x2, 0x718, 0x71a, 0x5, 0xbe, 0x60, 0x2, 0x719, 0x718, 0x3, 
       0x2, 0x2, 0x2, 0x71a, 0x71d, 0x3, 0x2, 0x2, 0x2, 0x71b, 0x719, 0x3, 
       0x2, 0x2, 0x2, 0x71b, 0x71c, 0x3, 0x2, 0x2, 0x2, 0x71c, 0xbd, 0x3, 
       0x2, 0x2, 0x2, 0x71d, 0x71b, 0x3, 0x2, 0x2, 0x2, 0x71e, 0x71f, 0x7, 
       0x20, 0x2, 0x2, 0x71f, 0x721, 0x5, 0x17e, 0xc0, 0x2, 0x720, 0x71e, 
       0x3, 0x2, 0x2, 0x2, 0x720, 0x721, 0x3, 0x2, 0x2, 0x2, 0x721, 0x723, 
       0x3, 0x2, 0x2, 0x2, 0x722, 0x724, 0x5, 0x174, 0xbb, 0x2, 0x723, 0x722, 
       0x3, 0x2, 0x2, 0x2, 0x723, 0x724, 0x3, 0x2, 0x2, 0x2, 0x724, 0x73a, 
       0x3, 0x2, 0x2, 0x2, 0x725, 0x726, 0x7, 0x89, 0x2, 0x2, 0x726, 0x729, 
       0x7, 0x64, 0x2, 0x2, 0x727, 0x729, 0x7, 0xbf, 0x2, 0x2, 0x728, 0x725, 
       0x3, 0x2, 0x2, 0x2, 0x728, 0x727, 0x3, 0x2, 0x2, 0x2, 0x729, 0x72b, 
       0x3, 0x2, 0x2, 0x2, 0x72a, 0x72c, 0x5, 0x172, 0xba, 0x2, 0x72b, 0x72a, 
       0x3, 0x2, 0x2, 0x2, 0x72b, 0x72c, 0x3, 0x2, 0x2, 0x2, 0x72c, 0x72e, 
       0x3, 0x2, 0x2, 0x2, 0x72d, 0x72f, 0x5, 0xc2, 0x62, 0x2, 0x72e, 0x72d, 
       0x3, 0x2, 0x2, 0x2, 0x72e, 0x72f, 0x3, 0x2, 0x2, 0x2, 0x72f, 0x73b, 
       0x3, 0x2, 0x2, 0x2, 0x730, 0x734, 0x7, 0x17, 0x2, 0x2, 0x731, 0x732, 
       0x7, 0x72, 0x2, 0x2, 0x732, 0x733, 0x7, 0x4a, 0x2, 0x2, 0x733, 0x735, 
       0x7, 0x93, 0x2, 0x2, 0x734, 0x731, 0x3, 0x2, 0x2, 0x2, 0x734, 0x735, 
       0x3, 0x2, 0x2, 0x2, 0x735, 0x736, 0x3, 0x2, 0x2, 0x2, 0x736, 0x737, 
       0x7, 0x1da, 0x2, 0x2, 0x737, 0x738, 0x5, 0xe2, 0x72, 0x2, 0x738, 
       0x739, 0x7, 0x1db, 0x2, 0x2, 0x739, 0x73b, 0x3, 0x2, 0x2, 0x2, 0x73a, 
       0x728, 0x3, 0x2, 0x2, 0x2, 0x73a, 0x730, 0x3, 0x2, 0x2, 0x2, 0x73b, 
       0xbf, 0x3, 0x2, 0x2, 0x2, 0x73c, 0x73d, 0x7, 0x20, 0x2, 0x2, 0x73d, 
       0x73f, 0x5, 0x17e, 0xc0, 0x2, 0x73e, 0x73c, 0x3, 0x2, 0x2, 0x2, 0x73e, 
       0x73f, 0x3, 0x2, 0x2, 0x2, 0x73f, 0x774, 0x3, 0x2, 0x2, 0x2, 0x740, 
       0x741, 0x7, 0x89, 0x2, 0x2, 0x741, 0x744, 0x7, 0x64, 0x2, 0x2, 0x742, 
       0x744, 0x7, 0xbf, 0x2, 0x2, 0x743, 0x740, 0x3, 0x2, 0x2, 0x2, 0x743, 
       0x742, 0x3, 0x2, 0x2, 0x2, 0x744, 0x746, 0x3, 0x2, 0x2, 0x2, 0x745, 
       0x747, 0x5, 0x172, 0xba, 0x2, 0x746, 0x745, 0x3, 0x2, 0x2, 0x2, 0x746, 
       0x747, 0x3, 0x2, 0x2, 0x2, 0x747, 0x748, 0x3, 0x2, 0x2, 0x2, 0x748, 
       0x749, 0x7, 0x1da, 0x2, 0x2, 0x749, 0x74b, 0x5, 0x17e, 0xc0, 0x2, 
       0x74a, 0x74c, 0x9, 0x7, 0x2, 0x2, 0x74b, 0x74a, 0x3, 0x2, 0x2, 0x2, 
       0x74b, 0x74c, 0x3, 0x2, 0x2, 0x2, 0x74c, 0x754, 0x3, 0x2, 0x2, 0x2, 
       0x74d, 0x74e, 0x7, 0x1dc, 0x2, 0x2, 0x74e, 0x750, 0x5, 0x17e, 0xc0, 
       0x2, 0x74f, 0x751, 0x9, 0x7, 0x2, 0x2, 0x750, 0x74f, 0x3, 0x2, 0x2, 
       0x2, 0x750, 0x751, 0x3, 0x2, 0x2, 0x2, 0x751, 0x753, 0x3, 0x2, 0x2, 
       0x2, 0x752, 0x74d, 0x3, 0x2, 0x2, 0x2, 0x753, 0x756, 0x3, 0x2, 0x2, 
       0x2, 0x754, 0x752, 0x3, 0x2, 0x2, 0x2, 0x754, 0x755, 0x3, 0x2, 0x2, 
       0x2, 0x755, 0x757, 0x3, 0x2, 0x2, 0x2, 0x756, 0x754, 0x3, 0x2, 0x2, 
       0x2, 0x757, 0x759, 0x7, 0x1db, 0x2, 0x2, 0x758, 0x75a, 0x5, 0xc2, 
       0x62, 0x2, 0x759, 0x758, 0x3, 0x2, 0x2, 0x2, 0x759, 0x75a, 0x3, 0x2, 
       0x2, 0x2, 0x75a, 0x75d, 0x3, 0x2, 0x2, 0x2, 0x75b, 0x75c, 0x7, 0x79, 
       0x2, 0x2, 0x75c, 0x75e, 0x5, 0x17e, 0xc0, 0x2, 0x75d, 0x75b, 0x3, 
       0x2, 0x2, 0x2, 0x75d, 0x75e, 0x3, 0x2, 0x2, 0x2, 0x75e, 0x775, 0x3, 
       0x2, 0x2, 0x2, 0x75f, 0x760, 0x7, 0x4c, 0x2, 0x2, 0x760, 0x761, 0x7, 
       0x64, 0x2, 0x2, 0x761, 0x762, 0x7, 0x1da, 0x2, 0x2, 0x762, 0x763, 
       0x5, 0x16c, 0xb7, 0x2, 0x763, 0x764, 0x7, 0x1db, 0x2, 0x2, 0x764, 
       0x765, 0x7, 0x92, 0x2, 0x2, 0x765, 0x766, 0x5, 0x162, 0xb2, 0x2, 
       0x766, 0x767, 0x7, 0x1da, 0x2, 0x2, 0x767, 0x768, 0x5, 0x16c, 0xb7, 
       0x2, 0x768, 0x769, 0x7, 0x1db, 0x2, 0x2, 0x769, 0x775, 0x3, 0x2, 
       0x2, 0x2, 0x76a, 0x76e, 0x7, 0x17, 0x2, 0x2, 0x76b, 0x76c, 0x7, 0x72, 
       0x2, 0x2, 0x76c, 0x76d, 0x7, 0x4a, 0x2, 0x2, 0x76d, 0x76f, 0x7, 0x93, 
       0x2, 0x2, 0x76e, 0x76b, 0x3, 0x2, 0x2, 0x2, 0x76e, 0x76f, 0x3, 0x2, 
       0x2, 0x2, 0x76f, 0x770, 0x3, 0x2, 0x2, 0x2, 0x770, 0x771, 0x7, 0x1da, 
       0x2, 0x2, 0x771, 0x772, 0x5, 0xe2, 0x72, 0x2, 0x772, 0x773, 0x7, 
       0x1db, 0x2, 0x2, 0x773, 0x775, 0x3, 0x2, 0x2, 0x2, 0x774, 0x743, 
       0x3, 0x2, 0x2, 0x2, 0x774, 0x75f, 0x3, 0x2, 0x2, 0x2, 0x774, 0x76a, 
       0x3, 0x2, 0x2, 0x2, 0x775, 0xc1, 0x3, 0x2, 0x2, 0x2, 0x776, 0x777, 
       0x7, 0xcd, 0x2, 0x2, 0x777, 0x778, 0x7, 0x1da, 0x2, 0x2, 0x778, 0x77d, 
       0x5, 0xc4, 0x63, 0x2, 0x779, 0x77a, 0x7, 0x1dc, 0x2, 0x2, 0x77a, 
       0x77c, 0x5, 0xc4, 0x63, 0x2, 0x77b, 0x779, 0x3, 0x2, 0x2, 0x2, 0x77c, 
       0x77f, 0x3, 0x2, 0x2, 0x2, 0x77d, 0x77b, 0x3, 0x2, 0x2, 0x2, 0x77d, 
       0x77e, 0x3, 0x2, 0x2, 0x2, 0x77e, 0x780, 0x3, 0x2, 0x2, 0x2, 0x77f, 
       0x77d, 0x3, 0x2, 0x2, 0x2, 0x780, 0x781, 0x7, 0x1db, 0x2, 0x2, 0x781, 
       0xc3, 0x3, 0x2, 0x2, 0x2, 0x782, 0x783, 0x5, 0x180, 0xc1, 0x2, 0x783, 
       0x787, 0x7, 0x1c9, 0x2, 0x2, 0x784, 0x788, 0x5, 0x180, 0xc1, 0x2, 
       0x785, 0x788, 0x5, 0x170, 0xb9, 0x2, 0x786, 0x788, 0x7, 0x1c3, 0x2, 
       0x2, 0x787, 0x784, 0x3, 0x2, 0x2, 0x2, 0x787, 0x785, 0x3, 0x2, 0x2, 
       0x2, 0x787, 0x786, 0x3, 0x2, 0x2, 0x2, 0x788, 0xc5, 0x3, 0x2, 0x2, 
       0x2, 0x789, 0x78a, 0x7, 0x31, 0x2, 0x2, 0x78a, 0x7aa, 0x5, 0x16e, 
       0xb8, 0x2, 0x78b, 0x795, 0x7, 0x2d, 0x2, 0x2, 0x78c, 0x793, 0x5, 
       0xc8, 0x65, 0x2, 0x78d, 0x78e, 0x7, 0x4a, 0x2, 0x2, 0x78e, 0x791, 
       0x7, 0xc1, 0x2, 0x2, 0x78f, 0x790, 0x7, 0x76, 0x2, 0x2, 0x790, 0x792, 
       0x5, 0x16c, 0xb7, 0x2, 0x791, 0x78f, 0x3, 0x2, 0x2, 0x2, 0x791, 0x792, 
       0x3, 0x2, 0x2, 0x2, 0x792, 0x794, 0x3, 0x2, 0x2, 0x2, 0x793, 0x78d, 
       0x3, 0x2, 0x2, 0x2, 0x793, 0x794, 0x3, 0x2, 0x2, 0x2, 0x794, 0x796, 
       0x3, 0x2, 0x2, 0x2, 0x795, 0x78c, 0x3, 0x2, 0x2, 0x2, 0x795, 0x796, 
       0x3, 0x2, 0x2, 0x2, 0x796, 0x7ab, 0x3, 0x2, 0x2, 0x2, 0x797, 0x799, 
       0x7, 0x132, 0x2, 0x2, 0x798, 0x797, 0x3, 0x2, 0x2, 0x2, 0x798, 0x799, 
       0x3, 0x2, 0x2, 0x2, 0x799, 0x79b, 0x3, 0x2, 0x2, 0x2, 0x79a, 0x79c, 
       0x7, 0x188, 0x2, 0x2, 0x79b, 0x79a, 0x3, 0x2, 0x2, 0x2, 0x79b, 0x79c, 
       0x3, 0x2, 0x2, 0x2, 0x79c, 0x79d, 0x3, 0x2, 0x2, 0x2, 0x79d, 0x79e, 
       0x7, 0x2d, 0x2, 0x2, 0x79e, 0x79f, 0x7, 0x4a, 0x2, 0x2, 0x79f, 0x7a8, 
       0x5, 0x36, 0x1c, 0x2, 0x7a0, 0x7a6, 0x7, 0x4a, 0x2, 0x2, 0x7a1, 0x7a2, 
       0x7, 0x8f, 0x2, 0x2, 0x7a2, 0x7a7, 0x7, 0x15f, 0x2, 0x2, 0x7a3, 0x7a7, 
       0x7, 0xc1, 0x2, 0x2, 0x7a4, 0x7a5, 0x7, 0x76, 0x2, 0x2, 0x7a5, 0x7a7, 
       0x5, 0x16c, 0xb7, 0x2, 0x7a6, 0x7a1, 0x3, 0x2, 0x2, 0x2, 0x7a6, 0x7a3, 
       0x3, 0x2, 0x2, 0x2, 0x7a6, 0x7a4, 0x3, 0x2, 0x2, 0x2, 0x7a7, 0x7a9, 
       0x3, 0x2, 0x2, 0x2, 0x7a8, 0x7a0, 0x3, 0x2, 0x2, 0x2, 0x7a8, 0x7a9, 
       0x3, 0x2, 0x2, 0x2, 0x7a9, 0x7ab, 0x3, 0x2, 0x2, 0x2, 0x7aa, 0x78b, 
       0x3, 0x2, 0x2, 0x2, 0x7aa, 0x798, 0x3, 0x2, 0x2, 0x2, 0x7ab, 0x7ad, 
       0x3, 0x2, 0x2, 0x2, 0x7ac, 0x7ae, 0x7, 0x1dd, 0x2, 0x2, 0x7ad, 0x7ac, 
       0x3, 0x2, 0x2, 0x2, 0x7ad, 0x7ae, 0x3, 0x2, 0x2, 0x2, 0x7ae, 0xc7, 
       0x3, 0x2, 0x2, 0x2, 0x7af, 0x7b1, 0x9, 0xd, 0x2, 0x2, 0x7b0, 0x7af, 
       0x3, 0x2, 0x2, 0x2, 0x7b0, 0x7b1, 0x3, 0x2, 0x2, 0x2, 0x7b1, 0x7b3, 
       0x3, 0x2, 0x2, 0x2, 0x7b2, 0x7b4, 0x9, 0x1b, 0x2, 0x2, 0x7b3, 0x7b2, 
       0x3, 0x2, 0x2, 0x2, 0x7b3, 0x7b4, 0x3, 0x2, 0x2, 0x2, 0x7b4, 0x7b6, 
       0x3, 0x2, 0x2, 0x2, 0x7b5, 0x7b7, 0x9, 0x1c, 0x2, 0x2, 0x7b6, 0x7b5, 
       0x3, 0x2, 0x2, 0x2, 0x7b6, 0x7b7, 0x3, 0x2, 0x2, 0x2, 0x7b7, 0x7b9, 
       0x3, 0x2, 0x2, 0x2, 0x7b8, 0x7ba, 0x9, 0x1d, 0x2, 0x2, 0x7b9, 0x7b8, 
       0x3, 0x2, 0x2, 0x2, 0x7b9, 0x7ba, 0x3, 0x2, 0x2, 0x2, 0x7ba, 0x7bc, 
       0x3, 0x2, 0x2, 
  };
  static const uint16_t serializedATNSegment1[] = {
    0x2, 0x7bb, 0x7bd, 0x7, 0x1ae, 0x2, 0x2, 0x7bc, 0x7bb, 0x3, 0x2, 0x2, 
       0x2, 0x7bc, 0x7bd, 0x3, 0x2, 0x2, 0x2, 0x7bd, 0x7be, 0x3, 0x2, 0x2, 
       0x2, 0x7be, 0x7bf, 0x7, 0x4a, 0x2, 0x2, 0x7bf, 0x7c0, 0x5, 0x36, 
       0x1c, 0x2, 0x7c0, 0xc9, 0x3, 0x2, 0x2, 0x2, 0x7c1, 0x7cb, 0x7, 0x46, 
       0x2, 0x2, 0x7c2, 0x7c9, 0x7, 0x6e, 0x2, 0x2, 0x7c3, 0x7c9, 0x7, 0x16d, 
       0x2, 0x2, 0x7c4, 0x7c9, 0x7, 0x11b, 0x2, 0x2, 0x7c5, 0x7c9, 0x7, 
       0x13b, 0x2, 0x2, 0x7c6, 0x7c7, 0x9, 0x1e, 0x2, 0x2, 0x7c7, 0x7c9, 
       0x5, 0xd0, 0x69, 0x2, 0x7c8, 0x7c2, 0x3, 0x2, 0x2, 0x2, 0x7c8, 0x7c3, 
       0x3, 0x2, 0x2, 0x2, 0x7c8, 0x7c4, 0x3, 0x2, 0x2, 0x2, 0x7c8, 0x7c5, 
       0x3, 0x2, 0x2, 0x2, 0x7c8, 0x7c6, 0x3, 0x2, 0x2, 0x2, 0x7c8, 0x7c9, 
       0x3, 0x2, 0x2, 0x2, 0x7c9, 0x7ca, 0x3, 0x2, 0x2, 0x2, 0x7ca, 0x7cc, 
       0x7, 0x4f, 0x2, 0x2, 0x7cb, 0x7c8, 0x3, 0x2, 0x2, 0x2, 0x7cb, 0x7cc, 
       0x3, 0x2, 0x2, 0x2, 0x7cc, 0x7ce, 0x3, 0x2, 0x2, 0x2, 0x7cd, 0x7cf, 
       0x7, 0x124, 0x2, 0x2, 0x7ce, 0x7cd, 0x3, 0x2, 0x2, 0x2, 0x7ce, 0x7cf, 
       0x3, 0x2, 0x2, 0x2, 0x7cf, 0x7d0, 0x3, 0x2, 0x2, 0x2, 0x7d0, 0x7da, 
       0x5, 0x16e, 0xb8, 0x2, 0x7d1, 0x7d2, 0x7, 0x61, 0x2, 0x2, 0x7d2, 
       0x7d7, 0x7, 0x1c2, 0x2, 0x2, 0x7d3, 0x7d4, 0x7, 0x1dc, 0x2, 0x2, 
       0x7d4, 0x7d6, 0x7, 0x1c2, 0x2, 0x2, 0x7d5, 0x7d3, 0x3, 0x2, 0x2, 
       0x2, 0x7d6, 0x7d9, 0x3, 0x2, 0x2, 0x2, 0x7d7, 0x7d5, 0x3, 0x2, 0x2, 
       0x2, 0x7d7, 0x7d8, 0x3, 0x2, 0x2, 0x2, 0x7d8, 0x7db, 0x3, 0x2, 0x2, 
       0x2, 0x7d9, 0x7d7, 0x3, 0x2, 0x2, 0x2, 0x7da, 0x7d1, 0x3, 0x2, 0x2, 
       0x2, 0x7da, 0x7db, 0x3, 0x2, 0x2, 0x2, 0x7db, 0x7dd, 0x3, 0x2, 0x2, 
       0x2, 0x7dc, 0x7de, 0x7, 0x1dd, 0x2, 0x2, 0x7dd, 0x7dc, 0x3, 0x2, 
       0x2, 0x2, 0x7dd, 0x7de, 0x3, 0x2, 0x2, 0x2, 0x7de, 0xcb, 0x3, 0x2, 
       0x2, 0x2, 0x7df, 0x7e0, 0x7, 0xa7, 0x2, 0x2, 0x7e0, 0x7e4, 0x5, 0x17e, 
       0xc0, 0x2, 0x7e1, 0x7e5, 0x5, 0x17e, 0xc0, 0x2, 0x7e2, 0x7e5, 0x5, 
       0xce, 0x68, 0x2, 0x7e3, 0x7e5, 0x5, 0x170, 0xb9, 0x2, 0x7e4, 0x7e1, 
       0x3, 0x2, 0x2, 0x2, 0x7e4, 0x7e2, 0x3, 0x2, 0x2, 0x2, 0x7e4, 0x7e3, 
       0x3, 0x2, 0x2, 0x2, 0x7e5, 0x7e7, 0x3, 0x2, 0x2, 0x2, 0x7e6, 0x7e8, 
       0x7, 0x1dd, 0x2, 0x2, 0x7e7, 0x7e6, 0x3, 0x2, 0x2, 0x2, 0x7e7, 0x7e8, 
       0x3, 0x2, 0x2, 0x2, 0x7e8, 0x80f, 0x3, 0x2, 0x2, 0x2, 0x7e9, 0x7ea, 
       0x7, 0xa7, 0x2, 0x2, 0x7ea, 0x7eb, 0x7, 0xb7, 0x2, 0x2, 0x7eb, 0x7ec, 
       0x7, 0x134, 0x2, 0x2, 0x7ec, 0x7f5, 0x7, 0x13e, 0x2, 0x2, 0x7ed, 
       0x7ee, 0x7, 0x8f, 0x2, 0x2, 0x7ee, 0x7f6, 0x7, 0x1b0, 0x2, 0x2, 0x7ef, 
       0x7f0, 0x7, 0x8f, 0x2, 0x2, 0x7f0, 0x7f6, 0x7, 0xef, 0x2, 0x2, 0x7f1, 
       0x7f2, 0x7, 0x17c, 0x2, 0x2, 0x7f2, 0x7f6, 0x7, 0x8f, 0x2, 0x2, 0x7f3, 
       0x7f6, 0x7, 0x194, 0x2, 0x2, 0x7f4, 0x7f6, 0x7, 0x18c, 0x2, 0x2, 
       0x7f5, 0x7ed, 0x3, 0x2, 0x2, 0x2, 0x7f5, 0x7ef, 0x3, 0x2, 0x2, 0x2, 
       0x7f5, 0x7f1, 0x3, 0x2, 0x2, 0x2, 0x7f5, 0x7f3, 0x3, 0x2, 0x2, 0x2, 
       0x7f5, 0x7f4, 0x3, 0x2, 0x2, 0x2, 0x7f6, 0x7f8, 0x3, 0x2, 0x2, 0x2, 
       0x7f7, 0x7f9, 0x7, 0x1dd, 0x2, 0x2, 0x7f8, 0x7f7, 0x3, 0x2, 0x2, 
       0x2, 0x7f8, 0x7f9, 0x3, 0x2, 0x2, 0x2, 0x7f9, 0x80f, 0x3, 0x2, 0x2, 
       0x2, 0x7fa, 0x7fb, 0x7, 0xa7, 0x2, 0x2, 0x7fb, 0x7fc, 0x7, 0x58, 
       0x2, 0x2, 0x7fc, 0x7fd, 0x5, 0x162, 0xb2, 0x2, 0x7fd, 0x7ff, 0x5, 
       0x170, 0xb9, 0x2, 0x7fe, 0x800, 0x7, 0x1dd, 0x2, 0x2, 0x7ff, 0x7fe, 
       0x3, 0x2, 0x2, 0x2, 0x7ff, 0x800, 0x3, 0x2, 0x2, 0x2, 0x800, 0x80f, 
       0x3, 0x2, 0x2, 0x2, 0x801, 0x802, 0x7, 0xa7, 0x2, 0x2, 0x802, 0x803, 
       0x7, 0xd4, 0x2, 0x2, 0x803, 0x80f, 0x5, 0x170, 0xb9, 0x2, 0x804, 
       0x805, 0x7, 0xa7, 0x2, 0x2, 0x805, 0x806, 0x7, 0x170, 0x2, 0x2, 0x806, 
       0x80f, 0x5, 0x170, 0xb9, 0x2, 0x807, 0x808, 0x7, 0xa7, 0x2, 0x2, 
       0x808, 0x809, 0x7, 0xd6, 0x2, 0x2, 0x809, 0x80f, 0x5, 0x170, 0xb9, 
       0x2, 0x80a, 0x80b, 0x7, 0xa7, 0x2, 0x2, 0x80b, 0x80c, 0x7, 0xac, 
       0x2, 0x2, 0x80c, 0x80d, 0x9, 0x1f, 0x2, 0x2, 0x80d, 0x80f, 0x5, 0x170, 
       0xb9, 0x2, 0x80e, 0x7df, 0x3, 0x2, 0x2, 0x2, 0x80e, 0x7e9, 0x3, 0x2, 
       0x2, 0x2, 0x80e, 0x7fa, 0x3, 0x2, 0x2, 0x2, 0x80e, 0x801, 0x3, 0x2, 
       0x2, 0x2, 0x80e, 0x804, 0x3, 0x2, 0x2, 0x2, 0x80e, 0x807, 0x3, 0x2, 
       0x2, 0x2, 0x80e, 0x80a, 0x3, 0x2, 0x2, 0x2, 0x80f, 0xcd, 0x3, 0x2, 
       0x2, 0x2, 0x810, 0x813, 0x5, 0x17a, 0xbe, 0x2, 0x811, 0x813, 0x7, 
       0x1c2, 0x2, 0x2, 0x812, 0x810, 0x3, 0x2, 0x2, 0x2, 0x812, 0x811, 
       0x3, 0x2, 0x2, 0x2, 0x813, 0xcf, 0x3, 0x2, 0x2, 0x2, 0x814, 0x815, 
       0x8, 0x69, 0x1, 0x2, 0x815, 0x844, 0x7, 0x32, 0x2, 0x2, 0x816, 0x844, 
       0x7, 0x73, 0x2, 0x2, 0x817, 0x844, 0x7, 0x1c2, 0x2, 0x2, 0x818, 0x844, 
       0x5, 0x17a, 0xbe, 0x2, 0x819, 0x844, 0x5, 0x126, 0x94, 0x2, 0x81a, 
       0x81b, 0x7, 0x14, 0x2, 0x2, 0x81b, 0x81d, 0x5, 0xd0, 0x69, 0x2, 0x81c, 
       0x81e, 0x5, 0x128, 0x95, 0x2, 0x81d, 0x81c, 0x3, 0x2, 0x2, 0x2, 0x81e, 
       0x81f, 0x3, 0x2, 0x2, 0x2, 0x81f, 0x81d, 0x3, 0x2, 0x2, 0x2, 0x81f, 
       0x820, 0x3, 0x2, 0x2, 0x2, 0x820, 0x823, 0x3, 0x2, 0x2, 0x2, 0x821, 
       0x822, 0x7, 0x3c, 0x2, 0x2, 0x822, 0x824, 0x5, 0xd0, 0x69, 0x2, 0x823, 
       0x821, 0x3, 0x2, 0x2, 0x2, 0x823, 0x824, 0x3, 0x2, 0x2, 0x2, 0x824, 
       0x825, 0x3, 0x2, 0x2, 0x2, 0x825, 0x826, 0x7, 0x3d, 0x2, 0x2, 0x826, 
       0x844, 0x3, 0x2, 0x2, 0x2, 0x827, 0x829, 0x7, 0x14, 0x2, 0x2, 0x828, 
       0x82a, 0x5, 0x12a, 0x96, 0x2, 0x829, 0x828, 0x3, 0x2, 0x2, 0x2, 0x82a, 
       0x82b, 0x3, 0x2, 0x2, 0x2, 0x82b, 0x829, 0x3, 0x2, 0x2, 0x2, 0x82b, 
       0x82c, 0x3, 0x2, 0x2, 0x2, 0x82c, 0x82f, 0x3, 0x2, 0x2, 0x2, 0x82d, 
       0x82e, 0x7, 0x3c, 0x2, 0x2, 0x82e, 0x830, 0x5, 0xd0, 0x69, 0x2, 0x82f, 
       0x82d, 0x3, 0x2, 0x2, 0x2, 0x82f, 0x830, 0x3, 0x2, 0x2, 0x2, 0x830, 
       0x831, 0x3, 0x2, 0x2, 0x2, 0x831, 0x832, 0x7, 0x3d, 0x2, 0x2, 0x832, 
       0x844, 0x3, 0x2, 0x2, 0x2, 0x833, 0x844, 0x5, 0x16a, 0xb6, 0x2, 0x834, 
       0x835, 0x7, 0x1da, 0x2, 0x2, 0x835, 0x836, 0x5, 0xd0, 0x69, 0x2, 
       0x836, 0x837, 0x7, 0x1db, 0x2, 0x2, 0x837, 0x844, 0x3, 0x2, 0x2, 
       0x2, 0x838, 0x839, 0x7, 0x1da, 0x2, 0x2, 0x839, 0x83a, 0x5, 0xd8, 
       0x6d, 0x2, 0x83a, 0x83b, 0x7, 0x1db, 0x2, 0x2, 0x83b, 0x844, 0x3, 
       0x2, 0x2, 0x2, 0x83c, 0x83d, 0x7, 0x1e4, 0x2, 0x2, 0x83d, 0x844, 
       0x5, 0xd0, 0x69, 0xb, 0x83e, 0x83f, 0x9, 0x20, 0x2, 0x2, 0x83f, 0x844, 
       0x5, 0xd0, 0x69, 0x9, 0x840, 0x844, 0x5, 0x14a, 0xa6, 0x2, 0x841, 
       0x844, 0x5, 0x198, 0xcd, 0x2, 0x842, 0x844, 0x5, 0x19a, 0xce, 0x2, 
       0x843, 0x814, 0x3, 0x2, 0x2, 0x2, 0x843, 0x816, 0x3, 0x2, 0x2, 0x2, 
       0x843, 0x817, 0x3, 0x2, 0x2, 0x2, 0x843, 0x818, 0x3, 0x2, 0x2, 0x2, 
       0x843, 0x819, 0x3, 0x2, 0x2, 0x2, 0x843, 0x81a, 0x3, 0x2, 0x2, 0x2, 
       0x843, 0x827, 0x3, 0x2, 0x2, 0x2, 0x843, 0x833, 0x3, 0x2, 0x2, 0x2, 
       0x843, 0x834, 0x3, 0x2, 0x2, 0x2, 0x843, 0x838, 0x3, 0x2, 0x2, 0x2, 
       0x843, 0x83c, 0x3, 0x2, 0x2, 0x2, 0x843, 0x83e, 0x3, 0x2, 0x2, 0x2, 
       0x843, 0x840, 0x3, 0x2, 0x2, 0x2, 0x843, 0x841, 0x3, 0x2, 0x2, 0x2, 
       0x843, 0x842, 0x3, 0x2, 0x2, 0x2, 0x844, 0x85c, 0x3, 0x2, 0x2, 0x2, 
       0x845, 0x846, 0xc, 0x11, 0x2, 0x2, 0x846, 0x847, 0x7, 0xda, 0x2, 
       0x2, 0x847, 0x848, 0x7, 0x1a6, 0x2, 0x2, 0x848, 0x849, 0x7, 0x1bb, 
       0x2, 0x2, 0x849, 0x85b, 0x5, 0xd0, 0x69, 0x12, 0x84a, 0x84b, 0xc, 
       0xa, 0x2, 0x2, 0x84b, 0x84c, 0x9, 0x21, 0x2, 0x2, 0x84c, 0x85b, 0x5, 
       0xd0, 0x69, 0xb, 0x84d, 0x84e, 0xc, 0x8, 0x2, 0x2, 0x84e, 0x84f, 
       0x9, 0x22, 0x2, 0x2, 0x84f, 0x85b, 0x5, 0xd0, 0x69, 0x9, 0x850, 0x851, 
       0xc, 0x7, 0x2, 0x2, 0x851, 0x852, 0x5, 0x182, 0xc2, 0x2, 0x852, 0x853, 
       0x5, 0xd0, 0x69, 0x8, 0x853, 0x85b, 0x3, 0x2, 0x2, 0x2, 0x854, 0x855, 
       0xc, 0x12, 0x2, 0x2, 0x855, 0x856, 0x7, 0x1c, 0x2, 0x2, 0x856, 0x85b, 
       0x5, 0x17e, 0xc0, 0x2, 0x857, 0x858, 0xc, 0x3, 0x2, 0x2, 0x858, 0x859, 
       0x7, 0x1d5, 0x2, 0x2, 0x859, 0x85b, 0x5, 0xd2, 0x6a, 0x2, 0x85a, 
       0x845, 0x3, 0x2, 0x2, 0x2, 0x85a, 0x84a, 0x3, 0x2, 0x2, 0x2, 0x85a, 
       0x84d, 0x3, 0x2, 0x2, 0x2, 0x85a, 0x850, 0x3, 0x2, 0x2, 0x2, 0x85a, 
       0x854, 0x3, 0x2, 0x2, 0x2, 0x85a, 0x857, 0x3, 0x2, 0x2, 0x2, 0x85b, 
       0x85e, 0x3, 0x2, 0x2, 0x2, 0x85c, 0x85a, 0x3, 0x2, 0x2, 0x2, 0x85c, 
       0x85d, 0x3, 0x2, 0x2, 0x2, 0x85d, 0xd1, 0x3, 0x2, 0x2, 0x2, 0x85e, 
       0x85c, 0x3, 0x2, 0x2, 0x2, 0x85f, 0x860, 0x5, 0xd4, 0x6b, 0x2, 0x860, 
       0x862, 0x7, 0x1da, 0x2, 0x2, 0x861, 0x863, 0x5, 0x13c, 0x9f, 0x2, 
       0x862, 0x861, 0x3, 0x2, 0x2, 0x2, 0x862, 0x863, 0x3, 0x2, 0x2, 0x2, 
       0x863, 0x864, 0x3, 0x2, 0x2, 0x2, 0x864, 0x865, 0x7, 0x1db, 0x2, 
       0x2, 0x865, 0x873, 0x3, 0x2, 0x2, 0x2, 0x866, 0x867, 0x7, 0x154, 
       0x2, 0x2, 0x867, 0x869, 0x7, 0x1da, 0x2, 0x2, 0x868, 0x86a, 0x5, 
       0x13c, 0x9f, 0x2, 0x869, 0x868, 0x3, 0x2, 0x2, 0x2, 0x869, 0x86a, 
       0x3, 0x2, 0x2, 0x2, 0x86a, 0x86b, 0x3, 0x2, 0x2, 0x2, 0x86b, 0x86c, 
       0x7, 0x1db, 0x2, 0x2, 0x86c, 0x86d, 0x7, 0x8, 0x2, 0x2, 0x86d, 0x86e, 
       0x5, 0x17e, 0xc0, 0x2, 0x86e, 0x86f, 0x7, 0x1da, 0x2, 0x2, 0x86f, 
       0x870, 0x5, 0x17e, 0xc0, 0x2, 0x870, 0x871, 0x7, 0x1db, 0x2, 0x2, 
       0x871, 0x873, 0x3, 0x2, 0x2, 0x2, 0x872, 0x85f, 0x3, 0x2, 0x2, 0x2, 
       0x872, 0x866, 0x3, 0x2, 0x2, 0x2, 0x873, 0xd3, 0x3, 0x2, 0x2, 0x2, 
       0x874, 0x875, 0x9, 0x23, 0x2, 0x2, 0x875, 0xd5, 0x3, 0x2, 0x2, 0x2, 
       0x876, 0x87f, 0x7, 0x73, 0x2, 0x2, 0x877, 0x87f, 0x5, 0x17a, 0xbe, 
       0x2, 0x878, 0x87f, 0x5, 0x126, 0x94, 0x2, 0x879, 0x87f, 0x7, 0x1c2, 
       0x2, 0x2, 0x87a, 0x87b, 0x7, 0x1da, 0x2, 0x2, 0x87b, 0x87c, 0x5, 
       0xd6, 0x6c, 0x2, 0x87c, 0x87d, 0x7, 0x1db, 0x2, 0x2, 0x87d, 0x87f, 
       0x3, 0x2, 0x2, 0x2, 0x87e, 0x876, 0x3, 0x2, 0x2, 0x2, 0x87e, 0x877, 
       0x3, 0x2, 0x2, 0x2, 0x87e, 0x878, 0x3, 0x2, 0x2, 0x2, 0x87e, 0x879, 
       0x3, 0x2, 0x2, 0x2, 0x87e, 0x87a, 0x3, 0x2, 0x2, 0x2, 0x87f, 0xd7, 
       0x3, 0x2, 0x2, 0x2, 0x880, 0x881, 0x5, 0x36, 0x1c, 0x2, 0x881, 0xd9, 
       0x3, 0x2, 0x2, 0x2, 0x882, 0x885, 0x7, 0xcd, 0x2, 0x2, 0x883, 0x884, 
       0x7, 0x1ba, 0x2, 0x2, 0x884, 0x886, 0x7, 0x1dc, 0x2, 0x2, 0x885, 
       0x883, 0x3, 0x2, 0x2, 0x2, 0x885, 0x886, 0x3, 0x2, 0x2, 0x2, 0x886, 
       0x887, 0x3, 0x2, 0x2, 0x2, 0x887, 0x88c, 0x5, 0xdc, 0x6f, 0x2, 0x888, 
       0x889, 0x7, 0x1dc, 0x2, 0x2, 0x889, 0x88b, 0x5, 0xdc, 0x6f, 0x2, 
       0x88a, 0x888, 0x3, 0x2, 0x2, 0x2, 0x88b, 0x88e, 0x3, 0x2, 0x2, 0x2, 
       0x88c, 0x88a, 0x3, 0x2, 0x2, 0x2, 0x88c, 0x88d, 0x3, 0x2, 0x2, 0x2, 
       0x88d, 0xdb, 0x3, 0x2, 0x2, 0x2, 0x88e, 0x88c, 0x3, 0x2, 0x2, 0x2, 
       0x88f, 0x894, 0x5, 0x17e, 0xc0, 0x2, 0x890, 0x891, 0x7, 0x1da, 0x2, 
       0x2, 0x891, 0x892, 0x5, 0x16c, 0xb7, 0x2, 0x892, 0x893, 0x7, 0x1db, 
       0x2, 0x2, 0x893, 0x895, 0x3, 0x2, 0x2, 0x2, 0x894, 0x890, 0x3, 0x2, 
       0x2, 0x2, 0x894, 0x895, 0x3, 0x2, 0x2, 0x2, 0x895, 0x896, 0x3, 0x2, 
       0x2, 0x2, 0x896, 0x897, 0x7, 0x8, 0x2, 0x2, 0x897, 0x898, 0x7, 0x1da, 
       0x2, 0x2, 0x898, 0x899, 0x5, 0x36, 0x1c, 0x2, 0x899, 0x89a, 0x7, 
       0x1db, 0x2, 0x2, 0x89a, 0xdd, 0x3, 0x2, 0x2, 0x2, 0x89b, 0x89e, 0x5, 
       0x16a, 0xb6, 0x2, 0x89c, 0x89e, 0x7, 0x1c2, 0x2, 0x2, 0x89d, 0x89b, 
       0x3, 0x2, 0x2, 0x2, 0x89d, 0x89c, 0x3, 0x2, 0x2, 0x2, 0x89e, 0x8a1, 
       0x3, 0x2, 0x2, 0x2, 0x89f, 0x8a2, 0x7, 0x1c9, 0x2, 0x2, 0x8a0, 0x8a2, 
       0x5, 0x184, 0xc3, 0x2, 0x8a1, 0x89f, 0x3, 0x2, 0x2, 0x2, 0x8a1, 0x8a0, 
       0x3, 0x2, 0x2, 0x2, 0x8a2, 0x8a3, 0x3, 0x2, 0x2, 0x2, 0x8a3, 0x8ac, 
       0x5, 0xd0, 0x69, 0x2, 0x8a4, 0x8a5, 0x5, 0x17e, 0xc0, 0x2, 0x8a5, 
       0x8a6, 0x7, 0x1d5, 0x2, 0x2, 0x8a6, 0x8a7, 0x5, 0x17e, 0xc0, 0x2, 
       0x8a7, 0x8a8, 0x7, 0x1da, 0x2, 0x2, 0x8a8, 0x8a9, 0x5, 0x13c, 0x9f, 
       0x2, 0x8a9, 0x8aa, 0x7, 0x1db, 0x2, 0x2, 0x8aa, 0x8ac, 0x3, 0x2, 
       0x2, 0x2, 0x8ab, 0x89d, 0x3, 0x2, 0x2, 0x2, 0x8ab, 0x8a4, 0x3, 0x2, 
       0x2, 0x2, 0x8ac, 0xdf, 0x3, 0x2, 0x2, 0x2, 0x8ad, 0x8b2, 0x5, 0xe2, 
       0x72, 0x2, 0x8ae, 0x8af, 0x7, 0x1dc, 0x2, 0x2, 0x8af, 0x8b1, 0x5, 
       0xe2, 0x72, 0x2, 0x8b0, 0x8ae, 0x3, 0x2, 0x2, 0x2, 0x8b1, 0x8b4, 
       0x3, 0x2, 0x2, 0x2, 0x8b2, 0x8b0, 0x3, 0x2, 0x2, 0x2, 0x8b2, 0x8b3, 
       0x3, 0x2, 0x2, 0x2, 0x8b3, 0xe1, 0x3, 0x2, 0x2, 0x2, 0x8b4, 0x8b2, 
       0x3, 0x2, 0x2, 0x2, 0x8b5, 0x8b6, 0x8, 0x72, 0x1, 0x2, 0x8b6, 0x8b7, 
       0x5, 0xe4, 0x73, 0x2, 0x8b7, 0x8c0, 0x3, 0x2, 0x2, 0x2, 0x8b8, 0x8b9, 
       0xc, 0x5, 0x2, 0x2, 0x8b9, 0x8ba, 0x7, 0x6, 0x2, 0x2, 0x8ba, 0x8bf, 
       0x5, 0xe2, 0x72, 0x6, 0x8bb, 0x8bc, 0xc, 0x4, 0x2, 0x2, 0x8bc, 0x8bd, 
       0x7, 0x80, 0x2, 0x2, 0x8bd, 0x8bf, 0x5, 0xe2, 0x72, 0x5, 0x8be, 0x8b8, 
       0x3, 0x2, 0x2, 0x2, 0x8be, 0x8bb, 0x3, 0x2, 0x2, 0x2, 0x8bf, 0x8c2, 
       0x3, 0x2, 0x2, 0x2, 0x8c0, 0x8be, 0x3, 0x2, 0x2, 0x2, 0x8c0, 0x8c1, 
       0x3, 0x2, 0x2, 0x2, 0x8c1, 0xe3, 0x3, 0x2, 0x2, 0x2, 0x8c2, 0x8c0, 
       0x3, 0x2, 0x2, 0x2, 0x8c3, 0x8c4, 0x7, 0x72, 0x2, 0x2, 0x8c4, 0x8fe, 
       0x5, 0xe4, 0x73, 0x2, 0x8c5, 0x8c6, 0x7, 0x42, 0x2, 0x2, 0x8c6, 0x8c7, 
       0x7, 0x1da, 0x2, 0x2, 0x8c7, 0x8c8, 0x5, 0xd8, 0x6d, 0x2, 0x8c8, 
       0x8c9, 0x7, 0x1db, 0x2, 0x2, 0x8c9, 0x8fe, 0x3, 0x2, 0x2, 0x2, 0x8ca, 
       0x8cb, 0x5, 0xd0, 0x69, 0x2, 0x8cb, 0x8cc, 0x5, 0x182, 0xc2, 0x2, 
       0x8cc, 0x8cd, 0x5, 0xd0, 0x69, 0x2, 0x8cd, 0x8fe, 0x3, 0x2, 0x2, 
       0x2, 0x8ce, 0x8cf, 0x5, 0xd0, 0x69, 0x2, 0x8cf, 0x8d0, 0x5, 0x182, 
       0xc2, 0x2, 0x8d0, 0x8d1, 0x9, 0x24, 0x2, 0x2, 0x8d1, 0x8d2, 0x7, 
       0x1da, 0x2, 0x2, 0x8d2, 0x8d3, 0x5, 0xd8, 0x6d, 0x2, 0x8d3, 0x8d4, 
       0x7, 0x1db, 0x2, 0x2, 0x8d4, 0x8fe, 0x3, 0x2, 0x2, 0x2, 0x8d5, 0x8d7, 
       0x5, 0xd0, 0x69, 0x2, 0x8d6, 0x8d8, 0x7, 0x72, 0x2, 0x2, 0x8d7, 0x8d6, 
       0x3, 0x2, 0x2, 0x2, 0x8d7, 0x8d8, 0x3, 0x2, 0x2, 0x2, 0x8d8, 0x8d9, 
       0x3, 0x2, 0x2, 0x2, 0x8d9, 0x8da, 0x7, 0xd, 0x2, 0x2, 0x8da, 0x8db, 
       0x5, 0xd0, 0x69, 0x2, 0x8db, 0x8dc, 0x7, 0x6, 0x2, 0x2, 0x8dc, 0x8dd, 
       0x5, 0xd0, 0x69, 0x2, 0x8dd, 0x8fe, 0x3, 0x2, 0x2, 0x2, 0x8de, 0x8e0, 
       0x5, 0xd0, 0x69, 0x2, 0x8df, 0x8e1, 0x7, 0x72, 0x2, 0x2, 0x8e0, 0x8df, 
       0x3, 0x2, 0x2, 0x2, 0x8e0, 0x8e1, 0x3, 0x2, 0x2, 0x2, 0x8e1, 0x8e2, 
       0x3, 0x2, 0x2, 0x2, 0x8e2, 0x8e3, 0x7, 0x5b, 0x2, 0x2, 0x8e3, 0x8e6, 
       0x7, 0x1da, 0x2, 0x2, 0x8e4, 0x8e7, 0x5, 0xd8, 0x6d, 0x2, 0x8e5, 
       0x8e7, 0x5, 0x13c, 0x9f, 0x2, 0x8e6, 0x8e4, 0x3, 0x2, 0x2, 0x2, 0x8e6, 
       0x8e5, 0x3, 0x2, 0x2, 0x2, 0x8e7, 0x8e8, 0x3, 0x2, 0x2, 0x2, 0x8e8, 
       0x8e9, 0x7, 0x1db, 0x2, 0x2, 0x8e9, 0x8fe, 0x3, 0x2, 0x2, 0x2, 0x8ea, 
       0x8ec, 0x5, 0xd0, 0x69, 0x2, 0x8eb, 0x8ed, 0x7, 0x72, 0x2, 0x2, 0x8ec, 
       0x8eb, 0x3, 0x2, 0x2, 0x2, 0x8ec, 0x8ed, 0x3, 0x2, 0x2, 0x2, 0x8ed, 
       0x8ee, 0x3, 0x2, 0x2, 0x2, 0x8ee, 0x8ef, 0x7, 0x67, 0x2, 0x2, 0x8ef, 
       0x8f2, 0x5, 0xd0, 0x69, 0x2, 0x8f0, 0x8f1, 0x7, 0x3f, 0x2, 0x2, 0x8f1, 
       0x8f3, 0x5, 0xd0, 0x69, 0x2, 0x8f2, 0x8f0, 0x3, 0x2, 0x2, 0x2, 0x8f2, 
       0x8f3, 0x3, 0x2, 0x2, 0x2, 0x8f3, 0x8fe, 0x3, 0x2, 0x2, 0x2, 0x8f4, 
       0x8f5, 0x5, 0xd0, 0x69, 0x2, 0x8f5, 0x8f6, 0x7, 0x62, 0x2, 0x2, 0x8f6, 
       0x8f7, 0x5, 0x174, 0xbb, 0x2, 0x8f7, 0x8fe, 0x3, 0x2, 0x2, 0x2, 0x8f8, 
       0x8f9, 0x7, 0x1da, 0x2, 0x2, 0x8f9, 0x8fa, 0x5, 0xe2, 0x72, 0x2, 
       0x8fa, 0x8fb, 0x7, 0x1db, 0x2, 0x2, 0x8fb, 0x8fe, 0x3, 0x2, 0x2, 
       0x2, 0x8fc, 0x8fe, 0x7, 0x1c3, 0x2, 0x2, 0x8fd, 0x8c3, 0x3, 0x2, 
       0x2, 0x2, 0x8fd, 0x8c5, 0x3, 0x2, 0x2, 0x2, 0x8fd, 0x8ca, 0x3, 0x2, 
       0x2, 0x2, 0x8fd, 0x8ce, 0x3, 0x2, 0x2, 0x2, 0x8fd, 0x8d5, 0x3, 0x2, 
       0x2, 0x2, 0x8fd, 0x8de, 0x3, 0x2, 0x2, 0x2, 0x8fd, 0x8ea, 0x3, 0x2, 
       0x2, 0x2, 0x8fd, 0x8f4, 0x3, 0x2, 0x2, 0x2, 0x8fd, 0x8f8, 0x3, 0x2, 
       0x2, 0x2, 0x8fd, 0x8fc, 0x3, 0x2, 0x2, 0x2, 0x8fe, 0xe5, 0x3, 0x2, 
       0x2, 0x2, 0x8ff, 0x900, 0x8, 0x74, 0x1, 0x2, 0x900, 0x901, 0x7, 0x1da, 
       0x2, 0x2, 0x901, 0x902, 0x5, 0xe6, 0x74, 0x2, 0x902, 0x903, 0x7, 
       0x1db, 0x2, 0x2, 0x903, 0x906, 0x3, 0x2, 0x2, 0x2, 0x904, 0x906, 
       0x5, 0xec, 0x77, 0x2, 0x905, 0x8ff, 0x3, 0x2, 0x2, 0x2, 0x905, 0x904, 
       0x3, 0x2, 0x2, 0x2, 0x906, 0x90d, 0x3, 0x2, 0x2, 0x2, 0x907, 0x908, 
       0xc, 0x4, 0x2, 0x2, 0x908, 0x909, 0x5, 0xe8, 0x75, 0x2, 0x909, 0x90a, 
       0x5, 0xe6, 0x74, 0x5, 0x90a, 0x90c, 0x3, 0x2, 0x2, 0x2, 0x90b, 0x907, 
       0x3, 0x2, 0x2, 0x2, 0x90c, 0x90f, 0x3, 0x2, 0x2, 0x2, 0x90d, 0x90b, 
       0x3, 0x2, 0x2, 0x2, 0x90d, 0x90e, 0x3, 0x2, 0x2, 0x2, 0x90e, 0xe7, 
       0x3, 0x2, 0x2, 0x2, 0x90f, 0x90d, 0x3, 0x2, 0x2, 0x2, 0x910, 0x912, 
       0x7, 0xbe, 0x2, 0x2, 0x911, 0x913, 0x7, 0x4, 0x2, 0x2, 0x912, 0x911, 
       0x3, 0x2, 0x2, 0x2, 0x912, 0x913, 0x3, 0x2, 0x2, 0x2, 0x913, 0x917, 
       0x3, 0x2, 0x2, 0x2, 0x914, 0x917, 0x7, 0x40, 0x2, 0x2, 0x915, 0x917, 
       0x7, 0x60, 0x2, 0x2, 0x916, 0x910, 0x3, 0x2, 0x2, 0x2, 0x916, 0x914, 
       0x3, 0x2, 0x2, 0x2, 0x916, 0x915, 0x3, 0x2, 0x2, 0x2, 0x917, 0xe9, 
       0x3, 0x2, 0x2, 0x2, 0x918, 0x919, 0x7, 0x1da, 0x2, 0x2, 0x919, 0x91a, 
       0x5, 0xea, 0x76, 0x2, 0x91a, 0x91b, 0x7, 0x1db, 0x2, 0x2, 0x91b, 
       0x920, 0x3, 0x2, 0x2, 0x2, 0x91c, 0x920, 0x5, 0xe6, 0x74, 0x2, 0x91d, 
       0x920, 0x5, 0xd0, 0x69, 0x2, 0x91e, 0x920, 0x5, 0x13a, 0x9e, 0x2, 
       0x91f, 0x918, 0x3, 0x2, 0x2, 0x2, 0x91f, 0x91c, 0x3, 0x2, 0x2, 0x2, 
       0x91f, 0x91d, 0x3, 0x2, 0x2, 0x2, 0x91f, 0x91e, 0x3, 0x2, 0x2, 0x2, 
       0x920, 0xeb, 0x3, 0x2, 0x2, 0x2, 0x921, 0x923, 0x7, 0xa2, 0x2, 0x2, 
       0x922, 0x924, 0x9, 0x25, 0x2, 0x2, 0x923, 0x922, 0x3, 0x2, 0x2, 0x2, 
       0x923, 0x924, 0x3, 0x2, 0x2, 0x2, 0x924, 0x926, 0x3, 0x2, 0x2, 0x2, 
       0x925, 0x927, 0x5, 0xf2, 0x7a, 0x2, 0x926, 0x925, 0x3, 0x2, 0x2, 
       0x2, 0x926, 0x927, 0x3, 0x2, 0x2, 0x2, 0x927, 0x928, 0x3, 0x2, 0x2, 
       0x2, 0x928, 0x92b, 0x5, 0x108, 0x85, 0x2, 0x929, 0x92a, 0x7, 0x61, 
       0x2, 0x2, 0x92a, 0x92c, 0x5, 0x162, 0xb2, 0x2, 0x92b, 0x929, 0x3, 
       0x2, 0x2, 0x2, 0x92b, 0x92c, 0x3, 0x2, 0x2, 0x2, 0x92c, 0x92f, 0x3, 
       0x2, 0x2, 0x2, 0x92d, 0x92e, 0x7, 0x4f, 0x2, 0x2, 0x92e, 0x930, 0x5, 
       0x10c, 0x87, 0x2, 0x92f, 0x92d, 0x3, 0x2, 0x2, 0x2, 0x92f, 0x930, 
       0x3, 0x2, 0x2, 0x2, 0x930, 0x937, 0x3, 0x2, 0x2, 0x2, 0x931, 0x932, 
       0x7, 0x27, 0x2, 0x2, 0x932, 0x933, 0x7, 0xd8, 0x2, 0x2, 0x933, 0x935, 
       0x5, 0xea, 0x76, 0x2, 0x934, 0x936, 0x5, 0x3e, 0x20, 0x2, 0x935, 
       0x934, 0x3, 0x2, 0x2, 0x2, 0x935, 0x936, 0x3, 0x2, 0x2, 0x2, 0x936, 
       0x938, 0x3, 0x2, 0x2, 0x2, 0x937, 0x931, 0x3, 0x2, 0x2, 0x2, 0x937, 
       0x938, 0x3, 0x2, 0x2, 0x2, 0x938, 0x93b, 0x3, 0x2, 0x2, 0x2, 0x939, 
       0x93a, 0x7, 0xcb, 0x2, 0x2, 0x93a, 0x93c, 0x5, 0xe2, 0x72, 0x2, 0x93b, 
       0x939, 0x3, 0x2, 0x2, 0x2, 0x93b, 0x93c, 0x3, 0x2, 0x2, 0x2, 0x93c, 
       0x947, 0x3, 0x2, 0x2, 0x2, 0x93d, 0x93e, 0x7, 0x54, 0x2, 0x2, 0x93e, 
       0x93f, 0x7, 0x11, 0x2, 0x2, 0x93f, 0x944, 0x5, 0x100, 0x81, 0x2, 
       0x940, 0x941, 0x7, 0x1dc, 0x2, 0x2, 0x941, 0x943, 0x5, 0x100, 0x81, 
       0x2, 0x942, 0x940, 0x3, 0x2, 0x2, 0x2, 0x943, 0x946, 0x3, 0x2, 0x2, 
       0x2, 0x944, 0x942, 0x3, 0x2, 0x2, 0x2, 0x944, 0x945, 0x3, 0x2, 0x2, 
       0x2, 0x945, 0x948, 0x3, 0x2, 0x2, 0x2, 0x946, 0x944, 0x3, 0x2, 0x2, 
       0x2, 0x947, 0x93d, 0x3, 0x2, 0x2, 0x2, 0x947, 0x948, 0x3, 0x2, 0x2, 
       0x2, 0x948, 0x94a, 0x3, 0x2, 0x2, 0x2, 0x949, 0x94b, 0x5, 0xee, 0x78, 
       0x2, 0x94a, 0x949, 0x3, 0x2, 0x2, 0x2, 0x94a, 0x94b, 0x3, 0x2, 0x2, 
       0x2, 0x94b, 0x94e, 0x3, 0x2, 0x2, 0x2, 0x94c, 0x94d, 0x7, 0xcd, 0x2, 
       0x2, 0x94d, 0x94f, 0x9, 0x26, 0x2, 0x2, 0x94e, 0x94c, 0x3, 0x2, 0x2, 
       0x2, 0x94e, 0x94f, 0x3, 0x2, 0x2, 0x2, 0x94f, 0x952, 0x3, 0x2, 0x2, 
       0x2, 0x950, 0x951, 0x7, 0x55, 0x2, 0x2, 0x951, 0x953, 0x5, 0xe2, 
       0x72, 0x2, 0x952, 0x950, 0x3, 0x2, 0x2, 0x2, 0x952, 0x953, 0x3, 0x2, 
       0x2, 0x2, 0x953, 0xed, 0x3, 0x2, 0x2, 0x2, 0x954, 0x955, 0x7, 0x54, 
       0x2, 0x2, 0x955, 0x956, 0x7, 0x11, 0x2, 0x2, 0x956, 0x957, 0x7, 0x126, 
       0x2, 0x2, 0x957, 0x958, 0x7, 0x18d, 0x2, 0x2, 0x958, 0x959, 0x7, 
       0x1da, 0x2, 0x2, 0x959, 0x95e, 0x5, 0xf0, 0x79, 0x2, 0x95a, 0x95b, 
       0x7, 0x1dc, 0x2, 0x2, 0x95b, 0x95d, 0x5, 0xf0, 0x79, 0x2, 0x95c, 
       0x95a, 0x3, 0x2, 0x2, 0x2, 0x95d, 0x960, 0x3, 0x2, 0x2, 0x2, 0x95e, 
       0x95c, 0x3, 0x2, 0x2, 0x2, 0x95e, 0x95f, 0x3, 0x2, 0x2, 0x2, 0x95f, 
       0x961, 0x3, 0x2, 0x2, 0x2, 0x960, 0x95e, 0x3, 0x2, 0x2, 0x2, 0x961, 
       0x962, 0x7, 0x1db, 0x2, 0x2, 0x962, 0xef, 0x3, 0x2, 0x2, 0x2, 0x963, 
       0x964, 0x7, 0x1da, 0x2, 0x2, 0x964, 0x972, 0x7, 0x1db, 0x2, 0x2, 
       0x965, 0x972, 0x5, 0x100, 0x81, 0x2, 0x966, 0x967, 0x7, 0x1da, 0x2, 
       0x2, 0x967, 0x96c, 0x5, 0x100, 0x81, 0x2, 0x968, 0x969, 0x7, 0x1dc, 
       0x2, 0x2, 0x969, 0x96b, 0x5, 0x100, 0x81, 0x2, 0x96a, 0x968, 0x3, 
       0x2, 0x2, 0x2, 0x96b, 0x96e, 0x3, 0x2, 0x2, 0x2, 0x96c, 0x96a, 0x3, 
       0x2, 0x2, 0x2, 0x96c, 0x96d, 0x3, 0x2, 0x2, 0x2, 0x96d, 0x96f, 0x3, 
       0x2, 0x2, 0x2, 0x96e, 0x96c, 0x3, 0x2, 0x2, 0x2, 0x96f, 0x970, 0x7, 
       0x1db, 0x2, 0x2, 0x970, 0x972, 0x3, 0x2, 0x2, 0x2, 0x971, 0x963, 
       0x3, 0x2, 0x2, 0x2, 0x971, 0x965, 0x3, 0x2, 0x2, 0x2, 0x971, 0x966, 
       0x3, 0x2, 0x2, 0x2, 0x972, 0xf1, 0x3, 0x2, 0x2, 0x2, 0x973, 0x974, 
       0x7, 0xb5, 0x2, 0x2, 0x974, 0x976, 0x5, 0xd0, 0x69, 0x2, 0x975, 0x977, 
       0x7, 0x85, 0x2, 0x2, 0x976, 0x975, 0x3, 0x2, 0x2, 0x2, 0x976, 0x977, 
       0x3, 0x2, 0x2, 0x2, 0x977, 0x97a, 0x3, 0x2, 0x2, 0x2, 0x978, 0x979, 
       0x7, 0xcd, 0x2, 0x2, 0x979, 0x97b, 0x7, 0x1a5, 0x2, 0x2, 0x97a, 0x978, 
       0x3, 0x2, 0x2, 0x2, 0x97a, 0x97b, 0x3, 0x2, 0x2, 0x2, 0x97b, 0xf3, 
       0x3, 0x2, 0x2, 0x2, 0x97c, 0x97d, 0x7, 0xb5, 0x2, 0x2, 0x97d, 0x97e, 
       0x7, 0x1da, 0x2, 0x2, 0x97e, 0x97f, 0x5, 0xd0, 0x69, 0x2, 0x97f, 
       0x981, 0x7, 0x1db, 0x2, 0x2, 0x980, 0x982, 0x7, 0x85, 0x2, 0x2, 0x981, 
       0x980, 0x3, 0x2, 0x2, 0x2, 0x981, 0x982, 0x3, 0x2, 0x2, 0x2, 0x982, 
       0xf5, 0x3, 0x2, 0x2, 0x2, 0x983, 0x984, 0x7, 0x81, 0x2, 0x2, 0x984, 
       0x985, 0x7, 0x11, 0x2, 0x2, 0x985, 0x98a, 0x5, 0xfe, 0x80, 0x2, 0x986, 
       0x987, 0x7, 0x1dc, 0x2, 0x2, 0x987, 0x989, 0x5, 0xfe, 0x80, 0x2, 
       0x988, 0x986, 0x3, 0x2, 0x2, 0x2, 0x989, 0x98c, 0x3, 0x2, 0x2, 0x2, 
       0x98a, 0x988, 0x3, 0x2, 0x2, 0x2, 0x98a, 0x98b, 0x3, 0x2, 0x2, 0x2, 
       0x98b, 0x993, 0x3, 0x2, 0x2, 0x2, 0x98c, 0x98a, 0x3, 0x2, 0x2, 0x2, 
       0x98d, 0x98e, 0x7, 0x15d, 0x2, 0x2, 0x98e, 0x98f, 0x5, 0xd0, 0x69, 
       0x2, 0x98f, 0x991, 0x9, 0x27, 0x2, 0x2, 0x990, 0x992, 0x5, 0xf8, 
       0x7d, 0x2, 0x991, 0x990, 0x3, 0x2, 0x2, 0x2, 0x991, 0x992, 0x3, 0x2, 
       0x2, 0x2, 0x992, 0x994, 0x3, 0x2, 0x2, 0x2, 0x993, 0x98d, 0x3, 0x2, 
       0x2, 0x2, 0x993, 0x994, 0x3, 0x2, 0x2, 0x2, 0x994, 0xf7, 0x3, 0x2, 
       0x2, 0x2, 0x995, 0x996, 0x7, 0x46, 0x2, 0x2, 0x996, 0x997, 0x9, 0x28, 
       0x2, 0x2, 0x997, 0x998, 0x5, 0xd0, 0x69, 0x2, 0x998, 0x999, 0x9, 
       0x27, 0x2, 0x2, 0x999, 0x99a, 0x7, 0x15f, 0x2, 0x2, 0x99a, 0xf9, 
       0x3, 0x2, 0x2, 0x2, 0x99b, 0x99c, 0x7, 0x4a, 0x2, 0x2, 0x99c, 0x9af, 
       0x7, 0xf, 0x2, 0x2, 0x99d, 0x99e, 0x7, 0x4a, 0x2, 0x2, 0x99e, 0x99f, 
       0x7, 0x1b9, 0x2, 0x2, 0x99f, 0x9a1, 0x7, 0xdb, 0x2, 0x2, 0x9a0, 0x9a2, 
       0x5, 0xfc, 0x7f, 0x2, 0x9a1, 0x9a0, 0x3, 0x2, 0x2, 0x2, 0x9a1, 0x9a2, 
       0x3, 0x2, 0x2, 0x2, 0x9a2, 0x9af, 0x3, 0x2, 0x2, 0x2, 0x9a3, 0x9a4, 
       0x7, 0x4a, 0x2, 0x2, 0x9a4, 0x9a5, 0x7, 0x1b9, 0x2, 0x2, 0x9a5, 0x9a9, 
       0x7, 0x169, 0x2, 0x2, 0x9a6, 0x9a7, 0x7, 0x1da, 0x2, 0x2, 0x9a7, 
       0x9a8, 0x7, 0x1c5, 0x2, 0x2, 0x9a8, 0x9aa, 0x7, 0x1db, 0x2, 0x2, 
       0x9a9, 0x9a6, 0x3, 0x2, 0x2, 0x2, 0x9a9, 0x9aa, 0x3, 0x2, 0x2, 0x2, 
       0x9aa, 0x9ac, 0x3, 0x2, 0x2, 0x2, 0x9ab, 0x9ad, 0x5, 0xfc, 0x7f, 
       0x2, 0x9ac, 0x9ab, 0x3, 0x2, 0x2, 0x2, 0x9ac, 0x9ad, 0x3, 0x2, 0x2, 
       0x2, 0x9ad, 0x9af, 0x3, 0x2, 0x2, 0x2, 0x9ae, 0x99b, 0x3, 0x2, 0x2, 
       0x2, 0x9ae, 0x99d, 0x3, 0x2, 0x2, 0x2, 0x9ae, 0x9a3, 0x3, 0x2, 0x2, 
       0x2, 0x9af, 0xfb, 0x3, 0x2, 0x2, 0x2, 0x9b0, 0x9b5, 0x7, 0x1dc, 0x2, 
       0x2, 0x9b1, 0x9b2, 0x7, 0x1c6, 0x2, 0x2, 0x9b2, 0x9b6, 0x7, 0xe3, 
       0x2, 0x2, 0x9b3, 0x9b6, 0x7, 0x1ad, 0x2, 0x2, 0x9b4, 0x9b6, 0x7, 
       0x180, 0x2, 0x2, 0x9b5, 0x9b1, 0x3, 0x2, 0x2, 0x2, 0x9b5, 0x9b3, 
       0x3, 0x2, 0x2, 0x2, 0x9b5, 0x9b4, 0x3, 0x2, 0x2, 0x2, 0x9b6, 0xfd, 
       0x3, 0x2, 0x2, 0x2, 0x9b7, 0x9b9, 0x5, 0xd0, 0x69, 0x2, 0x9b8, 0x9ba, 
       0x9, 0x7, 0x2, 0x2, 0x9b9, 0x9b8, 0x3, 0x2, 0x2, 0x2, 0x9b9, 0x9ba, 
       0x3, 0x2, 0x2, 0x2, 0x9ba, 0xff, 0x3, 0x2, 0x2, 0x2, 0x9bb, 0x9bc, 
       0x5, 0xd0, 0x69, 0x2, 0x9bc, 0x101, 0x3, 0x2, 0x2, 0x2, 0x9bd, 0x9be, 
       0x7, 0x7f, 0x2, 0x2, 0x9be, 0x9bf, 0x7, 0x1da, 0x2, 0x2, 0x9bf, 0x9c4, 
       0x5, 0x104, 0x83, 0x2, 0x9c0, 0x9c1, 0x7, 0x1dc, 0x2, 0x2, 0x9c1, 
       0x9c3, 0x5, 0x104, 0x83, 0x2, 0x9c2, 0x9c0, 0x3, 0x2, 0x2, 0x2, 0x9c3, 
       0x9c6, 0x3, 0x2, 0x2, 0x2, 0x9c4, 0x9c2, 0x3, 0x2, 0x2, 0x2, 0x9c4, 
       0x9c5, 0x3, 0x2, 0x2, 0x2, 0x9c5, 0x9c7, 0x3, 0x2, 0x2, 0x2, 0x9c6, 
       0x9c4, 0x3, 0x2, 0x2, 0x2, 0x9c7, 0x9c8, 0x7, 0x1db, 0x2, 0x2, 0x9c8, 
       0x103, 0x3, 0x2, 0x2, 0x2, 0x9c9, 0x9ca, 0x7, 0x116, 0x2, 0x2, 0x9ca, 
       0x9f7, 0x7, 0x1c3, 0x2, 0x2, 0x9cb, 0x9cc, 0x9, 0x29, 0x2, 0x2, 0x9cc, 
       0x9f7, 0x7, 0x54, 0x2, 0x2, 0x9cd, 0x9ce, 0x9, 0x2a, 0x2, 0x2, 0x9ce, 
       0x9f7, 0x7, 0xbe, 0x2, 0x2, 0x9cf, 0x9d0, 0x9, 0x2b, 0x2, 0x2, 0x9d0, 
       0x9f7, 0x7, 0x63, 0x2, 0x2, 0x9d1, 0x9d2, 0x7, 0x115, 0x2, 0x2, 0x9d2, 
       0x9f7, 0x7, 0x1b6, 0x2, 0x2, 0x9d3, 0x9d4, 0x7, 0x11f, 0x2, 0x2, 
       0x9d4, 0x9f7, 0x7, 0x81, 0x2, 0x2, 0x9d5, 0x9f7, 0x7, 0x12c, 0x2, 
       0x2, 0x9d6, 0x9d7, 0x7, 0x137, 0x2, 0x2, 0x9d7, 0x9f7, 0x7, 0x87, 
       0x2, 0x2, 0x9d8, 0x9d9, 0x7, 0x138, 0x2, 0x2, 0x9d9, 0x9f7, 0x7, 
       0x87, 0x2, 0x2, 0x9da, 0x9db, 0x7, 0x145, 0x2, 0x2, 0x9db, 0x9f7, 
       0x7, 0x1c3, 0x2, 0x2, 0x9dc, 0x9dd, 0x7, 0x146, 0x2, 0x2, 0x9dd, 
       0x9f7, 0x7, 0x1c3, 0x2, 0x2, 0x9de, 0x9df, 0x7, 0x161, 0x2, 0x2, 
       0x9df, 0x9e0, 0x7, 0x4a, 0x2, 0x2, 0x9e0, 0x9e1, 0x7, 0x1da, 0x2, 
       0x2, 0x9e1, 0x9e6, 0x5, 0x106, 0x84, 0x2, 0x9e2, 0x9e3, 0x7, 0x1dc, 
       0x2, 0x2, 0x9e3, 0x9e5, 0x5, 0x106, 0x84, 0x2, 0x9e4, 0x9e2, 0x3, 
       0x2, 0x2, 0x2, 0x9e5, 0x9e8, 0x3, 0x2, 0x2, 0x2, 0x9e6, 0x9e4, 0x3, 
       0x2, 0x2, 0x2, 0x9e6, 0x9e7, 0x3, 0x2, 0x2, 0x2, 0x9e7, 0x9e9, 0x3, 
       0x2, 0x2, 0x2, 0x9e8, 0x9e6, 0x3, 0x2, 0x2, 0x2, 0x9e9, 0x9ea, 0x7, 
       0x1db, 0x2, 0x2, 0x9ea, 0x9f7, 0x3, 0x2, 0x2, 0x2, 0x9eb, 0x9ec, 
       0x7, 0x161, 0x2, 0x2, 0x9ec, 0x9ed, 0x7, 0x4a, 0x2, 0x2, 0x9ed, 0x9f7, 
       0x7, 0x1b1, 0x2, 0x2, 0x9ee, 0x9ef, 0x7, 0x166, 0x2, 0x2, 0x9ef, 
       0x9f7, 0x9, 0x12, 0x2, 0x2, 0x9f0, 0x9f7, 0x7, 0x177, 0x2, 0x2, 0x9f1, 
       0x9f2, 0x7, 0x17e, 0x2, 0x2, 0x9f2, 0x9f7, 0x7, 0x87, 0x2, 0x2, 0x9f3, 
       0x9f4, 0x7, 0xc3, 0x2, 0x2, 0x9f4, 0x9f5, 0x7, 0x87, 0x2, 0x2, 0x9f5, 
       0x9f7, 0x7, 0x1c5, 0x2, 0x2, 0x9f6, 0x9c9, 0x3, 0x2, 0x2, 0x2, 0x9f6, 
       0x9cb, 0x3, 0x2, 0x2, 0x2, 0x9f6, 0x9cd, 0x3, 0x2, 0x2, 0x2, 0x9f6, 
       0x9cf, 0x3, 0x2, 0x2, 0x2, 0x9f6, 0x9d1, 0x3, 0x2, 0x2, 0x2, 0x9f6, 
       0x9d3, 0x3, 0x2, 0x2, 0x2, 0x9f6, 0x9d5, 0x3, 0x2, 0x2, 0x2, 0x9f6, 
       0x9d6, 0x3, 0x2, 0x2, 0x2, 0x9f6, 0x9d8, 0x3, 0x2, 0x2, 0x2, 0x9f6, 
       0x9da, 0x3, 0x2, 0x2, 0x2, 0x9f6, 0x9dc, 0x3, 0x2, 0x2, 0x2, 0x9f6, 
       0x9de, 0x3, 0x2, 0x2, 0x2, 0x9f6, 0x9eb, 0x3, 0x2, 0x2, 0x2, 0x9f6, 
       0x9ee, 0x3, 0x2, 0x2, 0x2, 0x9f6, 0x9f0, 0x3, 0x2, 0x2, 0x2, 0x9f6, 
       0x9f1, 0x3, 0x2, 0x2, 0x2, 0x9f6, 0x9f3, 0x3, 0x2, 0x2, 0x2, 0x9f7, 
       0x105, 0x3, 0x2, 0x2, 0x2, 0x9f8, 0x9fc, 0x7, 0x1c2, 0x2, 0x2, 0x9f9, 
       0x9fd, 0x7, 0x1b1, 0x2, 0x2, 0x9fa, 0x9fb, 0x7, 0x1c9, 0x2, 0x2, 
       0x9fb, 0x9fd, 0x5, 0x17a, 0xbe, 0x2, 0x9fc, 0x9f9, 0x3, 0x2, 0x2, 
       0x2, 0x9fc, 0x9fa, 0x3, 0x2, 0x2, 0x2, 0x9fd, 0x107, 0x3, 0x2, 0x2, 
       0x2, 0x9fe, 0xa03, 0x5, 0x10a, 0x86, 0x2, 0x9ff, 0xa00, 0x7, 0x1dc, 
       0x2, 0x2, 0xa00, 0xa02, 0x5, 0x10a, 0x86, 0x2, 0xa01, 0x9ff, 0x3, 
       0x2, 0x2, 0x2, 0xa02, 0xa05, 0x3, 0x2, 0x2, 0x2, 0xa03, 0xa01, 0x3, 
       0x2, 0x2, 0x2, 0xa03, 0xa04, 0x3, 0x2, 0x2, 0x2, 0xa04, 0x109, 0x3, 
       0x2, 0x2, 0x2, 0xa05, 0xa03, 0x3, 0x2, 0x2, 0x2, 0xa06, 0xa07, 0x5, 
       0x162, 0xb2, 0x2, 0xa07, 0xa08, 0x7, 0x1d5, 0x2, 0x2, 0xa08, 0xa0a, 
       0x3, 0x2, 0x2, 0x2, 0xa09, 0xa06, 0x3, 0x2, 0x2, 0x2, 0xa09, 0xa0a, 
       0x3, 0x2, 0x2, 0x2, 0xa0a, 0xa0e, 0x3, 0x2, 0x2, 0x2, 0xa0b, 0xa0f, 
       0x5, 0x138, 0x9d, 0x2, 0xa0c, 0xa0d, 0x7, 0x1d9, 0x2, 0x2, 0xa0d, 
       0xa0f, 0x9, 0x2c, 0x2, 0x2, 0xa0e, 0xa0b, 0x3, 0x2, 0x2, 0x2, 0xa0e, 
       0xa0c, 0x3, 0x2, 0x2, 0x2, 0xa0f, 0xa1c, 0x3, 0x2, 0x2, 0x2, 0xa10, 
       0xa11, 0x5, 0x136, 0x9c, 0x2, 0xa11, 0xa12, 0x7, 0x1c9, 0x2, 0x2, 
       0xa12, 0xa13, 0x5, 0xd0, 0x69, 0x2, 0xa13, 0xa1c, 0x3, 0x2, 0x2, 
       0x2, 0xa14, 0xa19, 0x5, 0xd0, 0x69, 0x2, 0xa15, 0xa17, 0x7, 0x8, 
       0x2, 0x2, 0xa16, 0xa15, 0x3, 0x2, 0x2, 0x2, 0xa16, 0xa17, 0x3, 0x2, 
       0x2, 0x2, 0xa17, 0xa18, 0x3, 0x2, 0x2, 0x2, 0xa18, 0xa1a, 0x5, 0x136, 
       0x9c, 0x2, 0xa19, 0xa16, 0x3, 0x2, 0x2, 0x2, 0xa19, 0xa1a, 0x3, 0x2, 
       0x2, 0x2, 0xa1a, 0xa1c, 0x3, 0x2, 0x2, 0x2, 0xa1b, 0xa09, 0x3, 0x2, 
       0x2, 0x2, 0xa1b, 0xa10, 0x3, 0x2, 0x2, 0x2, 0xa1b, 0xa14, 0x3, 0x2, 
       0x2, 0x2, 0xa1c, 0x10b, 0x3, 0x2, 0x2, 0x2, 0xa1d, 0xa22, 0x5, 0x10e, 
       0x88, 0x2, 0xa1e, 0xa1f, 0x7, 0x1dc, 0x2, 0x2, 0xa1f, 0xa21, 0x5, 
       0x10e, 0x88, 0x2, 0xa20, 0xa1e, 0x3, 0x2, 0x2, 0x2, 0xa21, 0xa24, 
       0x3, 0x2, 0x2, 0x2, 0xa22, 0xa20, 0x3, 0x2, 0x2, 0x2, 0xa22, 0xa23, 
       0x3, 0x2, 0x2, 0x2, 0xa23, 0x10d, 0x3, 0x2, 0x2, 0x2, 0xa24, 0xa22, 
       0x3, 0x2, 0x2, 0x2, 0xa25, 0xa26, 0x8, 0x88, 0x1, 0x2, 0xa26, 0xa27, 
       0x7, 0x1da, 0x2, 0x2, 0xa27, 0xa28, 0x5, 0x10e, 0x88, 0x2, 0xa28, 
       0xa29, 0x7, 0x1db, 0x2, 0x2, 0xa29, 0xa2c, 0x3, 0x2, 0x2, 0x2, 0xa2a, 
       0xa2c, 0x5, 0x110, 0x89, 0x2, 0xa2b, 0xa25, 0x3, 0x2, 0x2, 0x2, 0xa2b, 
       0xa2a, 0x3, 0x2, 0x2, 0x2, 0xa2c, 0xa3e, 0x3, 0x2, 0x2, 0x2, 0xa2d, 
       0xa2e, 0xc, 0x5, 0x2, 0x2, 0xa2e, 0xa2f, 0x7, 0x27, 0x2, 0x2, 0xa2f, 
       0xa30, 0x7, 0x63, 0x2, 0x2, 0xa30, 0xa3d, 0x5, 0x10e, 0x88, 0x6, 
       0xa31, 0xa32, 0xc, 0x4, 0x2, 0x2, 0xa32, 0xa33, 0x9, 0x2d, 0x2, 0x2, 
       0xa33, 0xa34, 0x7, 0xd8, 0x2, 0x2, 0xa34, 0xa3d, 0x5, 0x10e, 0x88, 
       0x5, 0xa35, 0xa36, 0xc, 0x6, 0x2, 0x2, 0xa36, 0xa37, 0x5, 0x11c, 
       0x8f, 0x2, 0xa37, 0xa38, 0x7, 0x63, 0x2, 0x2, 0xa38, 0xa39, 0x5, 
       0x10e, 0x88, 0x2, 0xa39, 0xa3a, 0x7, 0x79, 0x2, 0x2, 0xa3a, 0xa3b, 
       0x5, 0xe2, 0x72, 0x2, 0xa3b, 0xa3d, 0x3, 0x2, 0x2, 0x2, 0xa3c, 0xa2d, 
       0x3, 0x2, 0x2, 0x2, 0xa3c, 0xa31, 0x3, 0x2, 0x2, 0x2, 0xa3c, 0xa35, 
       0x3, 0x2, 0x2, 0x2, 0xa3d, 0xa40, 0x3, 0x2, 0x2, 0x2, 0xa3e, 0xa3c, 
       0x3, 0x2, 0x2, 0x2, 0xa3e, 0xa3f, 0x3, 0x2, 0x2, 0x2, 0xa3f, 0x10f, 
       0x3, 0x2, 0x2, 0x2, 0xa40, 0xa3e, 0x3, 0x2, 0x2, 0x2, 0xa41, 0xa43, 
       0x5, 0x162, 0xb2, 0x2, 0xa42, 0xa44, 0x5, 0x112, 0x8a, 0x2, 0xa43, 
       0xa42, 0x3, 0x2, 0x2, 0x2, 0xa43, 0xa44, 0x3, 0x2, 0x2, 0x2, 0xa44, 
       0xa46, 0x3, 0x2, 0x2, 0x2, 0xa45, 0xa47, 0x5, 0x118, 0x8d, 0x2, 0xa46, 
       0xa45, 0x3, 0x2, 0x2, 0x2, 0xa46, 0xa47, 0x3, 0x2, 0x2, 0x2, 0xa47, 
       0xa49, 0x3, 0x2, 0x2, 0x2, 0xa48, 0xa4a, 0x5, 0x12c, 0x97, 0x2, 0xa49, 
       0xa48, 0x3, 0x2, 0x2, 0x2, 0xa49, 0xa4a, 0x3, 0x2, 0x2, 0x2, 0xa4a, 
       0xa6c, 0x3, 0x2, 0x2, 0x2, 0xa4b, 0xa4d, 0x5, 0x120, 0x91, 0x2, 0xa4c, 
       0xa4e, 0x5, 0x118, 0x8d, 0x2, 0xa4d, 0xa4c, 0x3, 0x2, 0x2, 0x2, 0xa4d, 
       0xa4e, 0x3, 0x2, 0x2, 0x2, 0xa4e, 0xa6c, 0x3, 0x2, 0x2, 0x2, 0xa4f, 
       0xa54, 0x5, 0x124, 0x93, 0x2, 0xa50, 0xa52, 0x5, 0x118, 0x8d, 0x2, 
       0xa51, 0xa53, 0x5, 0x134, 0x9b, 0x2, 0xa52, 0xa51, 0x3, 0x2, 0x2, 
       0x2, 0xa52, 0xa53, 0x3, 0x2, 0x2, 0x2, 0xa53, 0xa55, 0x3, 0x2, 0x2, 
       0x2, 0xa54, 0xa50, 0x3, 0x2, 0x2, 0x2, 0xa54, 0xa55, 0x3, 0x2, 0x2, 
       0x2, 0xa55, 0xa6c, 0x3, 0x2, 0x2, 0x2, 0xa56, 0xa58, 0x5, 0x11a, 
       0x8e, 0x2, 0xa57, 0xa59, 0x5, 0x118, 0x8d, 0x2, 0xa58, 0xa57, 0x3, 
       0x2, 0x2, 0x2, 0xa58, 0xa59, 0x3, 0x2, 0x2, 0x2, 0xa59, 0xa6c, 0x3, 
       0x2, 0x2, 0x2, 0xa5a, 0xa5c, 0x5, 0x126, 0x94, 0x2, 0xa5b, 0xa5d, 
       0x5, 0x118, 0x8d, 0x2, 0xa5c, 0xa5b, 0x3, 0x2, 0x2, 0x2, 0xa5c, 0xa5d, 
       0x3, 0x2, 0x2, 0x2, 0xa5d, 0xa6c, 0x3, 0x2, 0x2, 0x2, 0xa5e, 0xa60, 
       0x7, 0x1c2, 0x2, 0x2, 0xa5f, 0xa61, 0x5, 0x118, 0x8d, 0x2, 0xa60, 
       0xa5f, 0x3, 0x2, 0x2, 0x2, 0xa60, 0xa61, 0x3, 0x2, 0x2, 0x2, 0xa61, 
       0xa6c, 0x3, 0x2, 0x2, 0x2, 0xa62, 0xa63, 0x7, 0x1c2, 0x2, 0x2, 0xa63, 
       0xa64, 0x7, 0x1d5, 0x2, 0x2, 0xa64, 0xa69, 0x5, 0x126, 0x94, 0x2, 
       0xa65, 0xa67, 0x5, 0x118, 0x8d, 0x2, 0xa66, 0xa68, 0x5, 0x134, 0x9b, 
       0x2, 0xa67, 0xa66, 0x3, 0x2, 0x2, 0x2, 0xa67, 0xa68, 0x3, 0x2, 0x2, 
       0x2, 0xa68, 0xa6a, 0x3, 0x2, 0x2, 0x2, 0xa69, 0xa65, 0x3, 0x2, 0x2, 
       0x2, 0xa69, 0xa6a, 0x3, 0x2, 0x2, 0x2, 0xa6a, 0xa6c, 0x3, 0x2, 0x2, 
       0x2, 0xa6b, 0xa41, 0x3, 0x2, 0x2, 0x2, 0xa6b, 0xa4b, 0x3, 0x2, 0x2, 
       0x2, 0xa6b, 0xa4f, 0x3, 0x2, 0x2, 0x2, 0xa6b, 0xa56, 0x3, 0x2, 0x2, 
       0x2, 0xa6b, 0xa5a, 0x3, 0x2, 0x2, 0x2, 0xa6b, 0xa5e, 0x3, 0x2, 0x2, 
       0x2, 0xa6b, 0xa62, 0x3, 0x2, 0x2, 0x2, 0xa6c, 0x111, 0x3, 0x2, 0x2, 
       0x2, 0xa6d, 0xa6f, 0x7, 0xb1, 0x2, 0x2, 0xa6e, 0xa70, 0x7, 0xae, 
       0x2, 0x2, 0xa6f, 0xa6e, 0x3, 0x2, 0x2, 0x2, 0xa6f, 0xa70, 0x3, 0x2, 
       0x2, 0x2, 0xa70, 0xa71, 0x3, 0x2, 0x2, 0x2, 0xa71, 0xa72, 0x7, 0x1da, 
       0x2, 0x2, 0xa72, 0xa74, 0x5, 0x114, 0x8b, 0x2, 0xa73, 0xa75, 0x9, 
       0x8, 0x2, 0x2, 0xa74, 0xa73, 0x3, 0x2, 0x2, 0x2, 0xa74, 0xa75, 0x3, 
       0x2, 0x2, 0x2, 0xa75, 0xa76, 0x3, 0x2, 0x2, 0x2, 0xa76, 0xa79, 0x7, 
       0x1db, 0x2, 0x2, 0xa77, 0xa78, 0x7, 0x17c, 0x2, 0x2, 0xa78, 0xa7a, 
       0x5, 0x116, 0x8c, 0x2, 0xa79, 0xa77, 0x3, 0x2, 0x2, 0x2, 0xa79, 0xa7a, 
       0x3, 0x2, 0x2, 0x2, 0xa7a, 0x113, 0x3, 0x2, 0x2, 0x2, 0xa7b, 0xa7c, 
       0x7, 0x1c3, 0x2, 0x2, 0xa7c, 0x115, 0x3, 0x2, 0x2, 0x2, 0xa7d, 0xa7e, 
       0x7, 0x1c3, 0x2, 0x2, 0xa7e, 0x117, 0x3, 0x2, 0x2, 0x2, 0xa7f, 0xa81, 
       0x7, 0x8, 0x2, 0x2, 0xa80, 0xa7f, 0x3, 0x2, 0x2, 0x2, 0xa80, 0xa81, 
       0x3, 0x2, 0x2, 0x2, 0xa81, 0xa82, 0x3, 0x2, 0x2, 0x2, 0xa82, 0xa83, 
       0x5, 0x17e, 0xc0, 0x2, 0xa83, 0x119, 0x3, 0x2, 0x2, 0x2, 0xa84, 0xa85, 
       0x7, 0x15, 0x2, 0x2, 0xa85, 0xa86, 0x7, 0x1da, 0x2, 0x2, 0xa86, 0xa87, 
       0x7, 0x16, 0x2, 0x2, 0xa87, 0xa88, 0x5, 0x162, 0xb2, 0x2, 0xa88, 
       0xa89, 0x7, 0x1dc, 0x2, 0x2, 0xa89, 0xa8a, 0x9, 0x2e, 0x2, 0x2, 0xa8a, 
       0xa8b, 0x7, 0x1db, 0x2, 0x2, 0xa8b, 0x11b, 0x3, 0x2, 0x2, 0x2, 0xa8c, 
       0xa8e, 0x7, 0x5e, 0x2, 0x2, 0xa8d, 0xa8c, 0x3, 0x2, 0x2, 0x2, 0xa8d, 
       0xa8e, 0x3, 0x2, 0x2, 0x2, 0xa8e, 0xa94, 0x3, 0x2, 0x2, 0x2, 0xa8f, 
       0xa91, 0x9, 0x2f, 0x2, 0x2, 0xa90, 0xa92, 0x7, 0x82, 0x2, 0x2, 0xa91, 
       0xa90, 0x3, 0x2, 0x2, 0x2, 0xa91, 0xa92, 0x3, 0x2, 0x2, 0x2, 0xa92, 
       0xa94, 0x3, 0x2, 0x2, 0x2, 0xa93, 0xa8d, 0x3, 0x2, 0x2, 0x2, 0xa93, 
       0xa8f, 0x3, 0x2, 0x2, 0x2, 0xa94, 0xa96, 0x3, 0x2, 0x2, 0x2, 0xa95, 
       0xa97, 0x9, 0x30, 0x2, 0x2, 0xa96, 0xa95, 0x3, 0x2, 0x2, 0x2, 0xa96, 
       0xa97, 0x3, 0x2, 0x2, 0x2, 0xa97, 0x11d, 0x3, 0x2, 0x2, 0x2, 0xa98, 
       0xa9a, 0x5, 0x162, 0xb2, 0x2, 0xa99, 0xa9b, 0x5, 0x12c, 0x97, 0x2, 
       0xa9a, 0xa99, 0x3, 0x2, 0x2, 0x2, 0xa9a, 0xa9b, 0x3, 0x2, 0x2, 0x2, 
       0xa9b, 0x11f, 0x3, 0x2, 0x2, 0x2, 0xa9c, 0xa9d, 0x7, 0x7d, 0x2, 0x2, 
       0xa9d, 0xa9e, 0x7, 0x1da, 0x2, 0x2, 0xa9e, 0xa9f, 0x7, 0x1c5, 0x2, 
       0x2, 0xa9f, 0xaa0, 0x7, 0x1dc, 0x2, 0x2, 0xaa0, 0xaa1, 0x7, 0x1c5, 
       0x2, 0x2, 0xaa1, 0xaa2, 0x7, 0x1dc, 0x2, 0x2, 0xaa2, 0xaa3, 0x7, 
       0x1c5, 0x2, 0x2, 0xaa3, 0xab7, 0x7, 0x1db, 0x2, 0x2, 0xaa4, 0xaa5, 
       0x7, 0x7d, 0x2, 0x2, 0xaa5, 0xaa6, 0x7, 0x1da, 0x2, 0x2, 0xaa6, 0xaa7, 
       0x7, 0x10, 0x2, 0x2, 0xaa7, 0xaa8, 0x7, 0x1c5, 0x2, 0x2, 0xaa8, 0xab2, 
       0x7, 0x1dc, 0x2, 0x2, 0xaa9, 0xaae, 0x5, 0x122, 0x92, 0x2, 0xaaa, 
       0xaab, 0x7, 0x1dc, 0x2, 0x2, 0xaab, 0xaad, 0x5, 0x122, 0x92, 0x2, 
       0xaac, 0xaaa, 0x3, 0x2, 0x2, 0x2, 0xaad, 0xab0, 0x3, 0x2, 0x2, 0x2, 
       0xaae, 0xaac, 0x3, 0x2, 0x2, 0x2, 0xaae, 0xaaf, 0x3, 0x2, 0x2, 0x2, 
       0xaaf, 0xab3, 0x3, 0x2, 0x2, 0x2, 0xab0, 0xaae, 0x3, 0x2, 0x2, 0x2, 
       0xab1, 0xab3, 0x5, 0x17e, 0xc0, 0x2, 0xab2, 0xaa9, 0x3, 0x2, 0x2, 
       0x2, 0xab2, 0xab1, 0x3, 0x2, 0x2, 0x2, 0xab3, 0xab4, 0x3, 0x2, 0x2, 
       0x2, 0xab4, 0xab5, 0x7, 0x1db, 0x2, 0x2, 0xab5, 0xab7, 0x3, 0x2, 
       0x2, 0x2, 0xab6, 0xa9c, 0x3, 0x2, 0x2, 0x2, 0xab6, 0xaa4, 0x3, 0x2, 
       0x2, 0x2, 0xab7, 0x121, 0x3, 0x2, 0x2, 0x2, 0xab8, 0xab9, 0x5, 0x17e, 
       0xc0, 0x2, 0xab9, 0xaba, 0x7, 0x1c9, 0x2, 0x2, 0xaba, 0xabb, 0x9, 
       0x31, 0x2, 0x2, 0xabb, 0x123, 0x3, 0x2, 0x2, 0x2, 0xabc, 0xac8, 0x5, 
       0xd8, 0x6d, 0x2, 0xabd, 0xabe, 0x7, 0x1da, 0x2, 0x2, 0xabe, 0xabf, 
       0x5, 0xd8, 0x6d, 0x2, 0xabf, 0xac0, 0x7, 0x1db, 0x2, 0x2, 0xac0, 
       0xac8, 0x3, 0x2, 0x2, 0x2, 0xac1, 0xac2, 0x7, 0x1da, 0x2, 0x2, 0xac2, 
       0xac3, 0x5, 0x13a, 0x9e, 0x2, 0xac3, 0xac4, 0x7, 0x1db, 0x2, 0x2, 
       0xac4, 0xac5, 0x5, 0x118, 0x8d, 0x2, 0xac5, 0xac6, 0x5, 0x134, 0x9b, 
       0x2, 0xac6, 0xac8, 0x3, 0x2, 0x2, 0x2, 0xac7, 0xabc, 0x3, 0x2, 0x2, 
       0x2, 0xac7, 0xabd, 0x3, 0x2, 0x2, 0x2, 0xac7, 0xac1, 0x3, 0x2, 0x2, 
       0x2, 0xac8, 0x125, 0x3, 0x2, 0x2, 0x2, 0xac9, 0xb77, 0x5, 0x144, 
       0xa3, 0x2, 0xaca, 0xb77, 0x5, 0x146, 0xa4, 0x2, 0xacb, 0xacc, 0x5, 
       0x176, 0xbc, 0x2, 0xacc, 0xace, 0x7, 0x1da, 0x2, 0x2, 0xacd, 0xacf, 
       0x5, 0x13c, 0x9f, 0x2, 0xace, 0xacd, 0x3, 0x2, 0x2, 0x2, 0xace, 0xacf, 
       0x3, 0x2, 0x2, 0x2, 0xacf, 0xad0, 0x3, 0x2, 0x2, 0x2, 0xad0, 0xad1, 
       0x7, 0x1db, 0x2, 0x2, 0xad1, 0xb77, 0x3, 0x2, 0x2, 0x2, 0xad2, 0xb77, 
       0x5, 0x142, 0xa2, 0x2, 0xad3, 0xad4, 0x7, 0xe5, 0x2, 0x2, 0xad4, 
       0xad5, 0x7, 0x1da, 0x2, 0x2, 0xad5, 0xad6, 0x7, 0x1df, 0x2, 0x2, 
       0xad6, 0xb77, 0x7, 0x1db, 0x2, 0x2, 0xad7, 0xad8, 0x7, 0xe8, 0x2, 
       0x2, 0xad8, 0xad9, 0x7, 0x1da, 0x2, 0x2, 0xad9, 0xada, 0x5, 0xd0, 
       0x69, 0x2, 0xada, 0xadb, 0x7, 0x8, 0x2, 0x2, 0xadb, 0xadc, 0x5, 0x19c, 
       0xcf, 0x2, 0xadc, 0xadd, 0x7, 0x1db, 0x2, 0x2, 0xadd, 0xb77, 0x3, 
       0x2, 0x2, 0x2, 0xade, 0xadf, 0x7, 0x25, 0x2, 0x2, 0xadf, 0xae0, 0x7, 
       0x1da, 0x2, 0x2, 0xae0, 0xae1, 0x5, 0x19c, 0xcf, 0x2, 0xae1, 0xae2, 
       0x7, 0x1dc, 0x2, 0x2, 0xae2, 0xae5, 0x5, 0xd0, 0x69, 0x2, 0xae3, 
       0xae4, 0x7, 0x1dc, 0x2, 0x2, 0xae4, 0xae6, 0x5, 0xd0, 0x69, 0x2, 
       0xae5, 0xae3, 0x3, 0x2, 0x2, 0x2, 0xae5, 0xae6, 0x3, 0x2, 0x2, 0x2, 
       0xae6, 0xae7, 0x3, 0x2, 0x2, 0x2, 0xae7, 0xae8, 0x7, 0x1db, 0x2, 
       0x2, 0xae8, 0xb77, 0x3, 0x2, 0x2, 0x2, 0xae9, 0xaea, 0x7, 0xed, 0x2, 
       0x2, 0xaea, 0xaeb, 0x7, 0x1da, 0x2, 0x2, 0xaeb, 0xaec, 0x7, 0x1df, 
       0x2, 0x2, 0xaec, 0xb77, 0x7, 0x1db, 0x2, 0x2, 0xaed, 0xaee, 0x7, 
       0x1b, 0x2, 0x2, 0xaee, 0xaef, 0x7, 0x1da, 0x2, 0x2, 0xaef, 0xaf0, 
       0x5, 0x13c, 0x9f, 0x2, 0xaf0, 0xaf1, 0x7, 0x1db, 0x2, 0x2, 0xaf1, 
       0xb77, 0x3, 0x2, 0x2, 0x2, 0xaf2, 0xb77, 0x7, 0x2b, 0x2, 0x2, 0xaf3, 
       0xb77, 0x7, 0x2c, 0x2, 0x2, 0xaf4, 0xaf5, 0x7, 0xfc, 0x2, 0x2, 0xaf5, 
       0xaf6, 0x7, 0x1da, 0x2, 0x2, 0xaf6, 0xaf7, 0x7, 0x1c4, 0x2, 0x2, 
       0xaf7, 0xaf8, 0x7, 0x1dc, 0x2, 0x2, 0xaf8, 0xaf9, 0x5, 0xd0, 0x69, 
       0x2, 0xaf9, 0xafa, 0x7, 0x1dc, 0x2, 0x2, 0xafa, 0xafb, 0x5, 0xd0, 
       0x69, 0x2, 0xafb, 0xafc, 0x7, 0x1db, 0x2, 0x2, 0xafc, 0xb77, 0x3, 
       0x2, 0x2, 0x2, 0xafd, 0xafe, 0x7, 0xfd, 0x2, 0x2, 0xafe, 0xaff, 0x7, 
       0x1da, 0x2, 0x2, 0xaff, 0xb00, 0x7, 0x1c4, 0x2, 0x2, 0xb00, 0xb01, 
       0x7, 0x1dc, 0x2, 0x2, 0xb01, 0xb02, 0x5, 0xd0, 0x69, 0x2, 0xb02, 
       0xb03, 0x7, 0x1dc, 0x2, 0x2, 0xb03, 0xb04, 0x5, 0xd0, 0x69, 0x2, 
       0xb04, 0xb05, 0x7, 0x1db, 0x2, 0x2, 0xb05, 0xb77, 0x3, 0x2, 0x2, 
       0x2, 0xb06, 0xb07, 0x7, 0xfe, 0x2, 0x2, 0xb07, 0xb08, 0x7, 0x1da, 
       0x2, 0x2, 0xb08, 0xb09, 0x7, 0x1c4, 0x2, 0x2, 0xb09, 0xb0a, 0x7, 
       0x1dc, 0x2, 0x2, 0xb0a, 0xb0b, 0x5, 0xd0, 0x69, 0x2, 0xb0b, 0xb0c, 
       0x7, 0x1db, 0x2, 0x2, 0xb0c, 0xb77, 0x3, 0x2, 0x2, 0x2, 0xb0d, 0xb0e, 
       0x7, 0xff, 0x2, 0x2, 0xb0e, 0xb0f, 0x7, 0x1da, 0x2, 0x2, 0xb0f, 0xb10, 
       0x7, 0x1c4, 0x2, 0x2, 0xb10, 0xb11, 0x7, 0x1dc, 0x2, 0x2, 0xb11, 
       0xb12, 0x5, 0xd0, 0x69, 0x2, 0xb12, 0xb13, 0x7, 0x1db, 0x2, 0x2, 
       0xb13, 0xb77, 0x3, 0x2, 0x2, 0x2, 0xb14, 0xb15, 0x7, 0x101, 0x2, 
       0x2, 0xb15, 0xb16, 0x7, 0x1da, 0x2, 0x2, 0xb16, 0xb17, 0x5, 0xd0, 
       0x69, 0x2, 0xb17, 0xb18, 0x7, 0x1dc, 0x2, 0x2, 0xb18, 0xb19, 0x5, 
       0xd0, 0x69, 0x2, 0xb19, 0xb1a, 0x7, 0x1dc, 0x2, 0x2, 0xb1a, 0xb1b, 
       0x5, 0xd0, 0x69, 0x2, 0xb1b, 0xb1c, 0x7, 0x1dc, 0x2, 0x2, 0xb1c, 
       0xb1d, 0x5, 0xd0, 0x69, 0x2, 0xb1d, 0xb1e, 0x7, 0x1dc, 0x2, 0x2, 
       0xb1e, 0xb1f, 0x5, 0xd0, 0x69, 0x2, 0xb1f, 0xb20, 0x7, 0x1dc, 0x2, 
       0x2, 0xb20, 0xb21, 0x5, 0xd0, 0x69, 0x2, 0xb21, 0xb22, 0x7, 0x1dc, 
       0x2, 0x2, 0xb22, 0xb23, 0x5, 0xd0, 0x69, 0x2, 0xb23, 0xb24, 0x7, 
       0x1dc, 0x2, 0x2, 0xb24, 0xb25, 0x5, 0xd0, 0x69, 0x2, 0xb25, 0xb26, 
       0x7, 0x1dc, 0x2, 0x2, 0xb26, 0xb27, 0x5, 0xd0, 0x69, 0x2, 0xb27, 
       0xb28, 0x7, 0x1dc, 0x2, 0x2, 0xb28, 0xb29, 0x5, 0xd0, 0x69, 0x2, 
       0xb29, 0xb2a, 0x7, 0x1db, 0x2, 0x2, 0xb2a, 0xb77, 0x3, 0x2, 0x2, 
       0x2, 0xb2b, 0xb2c, 0x7, 0x56, 0x2, 0x2, 0xb2c, 0xb2d, 0x7, 0x1da, 
       0x2, 0x2, 0xb2d, 0xb30, 0x5, 0x19c, 0xcf, 0x2, 0xb2e, 0xb2f, 0x7, 
       0x1dc, 0x2, 0x2, 0xb2f, 0xb31, 0x7, 0x1c3, 0x2, 0x2, 0xb30, 0xb2e, 
       0x3, 0x2, 0x2, 0x2, 0xb30, 0xb31, 0x3, 0x2, 0x2, 0x2, 0xb31, 0xb34, 
       0x3, 0x2, 0x2, 0x2, 0xb32, 0xb33, 0x7, 0x1dc, 0x2, 0x2, 0xb33, 0xb35, 
       0x7, 0x1c3, 0x2, 0x2, 0xb34, 0xb32, 0x3, 0x2, 0x2, 0x2, 0xb34, 0xb35, 
       0x3, 0x2, 0x2, 0x2, 0xb35, 0xb36, 0x3, 0x2, 0x2, 0x2, 0xb36, 0xb37, 
       0x7, 0x1db, 0x2, 0x2, 0xb37, 0xb77, 0x3, 0x2, 0x2, 0x2, 0xb38, 0xb39, 
       0x7, 0x59, 0x2, 0x2, 0xb39, 0xb3a, 0x7, 0x1da, 0x2, 0x2, 0xb3a, 0xb3b, 
       0x5, 0xe2, 0x72, 0x2, 0xb3b, 0xb3c, 0x7, 0x1dc, 0x2, 0x2, 0xb3c, 
       0xb3d, 0x5, 0xd0, 0x69, 0x2, 0xb3d, 0xb3e, 0x7, 0x1dc, 0x2, 0x2, 
       0xb3e, 0xb3f, 0x5, 0xd0, 0x69, 0x2, 0xb3f, 0xb40, 0x7, 0x1db, 0x2, 
       0x2, 0xb40, 0xb77, 0x3, 0x2, 0x2, 0x2, 0xb41, 0xb77, 0x7, 0x14c, 
       0x2, 0x2, 0xb42, 0xb43, 0x7, 0x74, 0x2, 0x2, 0xb43, 0xb44, 0x7, 0x1da, 
       0x2, 0x2, 0xb44, 0xb45, 0x5, 0xd0, 0x69, 0x2, 0xb45, 0xb46, 0x7, 
       0x1dc, 0x2, 0x2, 0xb46, 0xb47, 0x5, 0xd0, 0x69, 0x2, 0xb47, 0xb48, 
       0x7, 0x1db, 0x2, 0x2, 0xb48, 0xb77, 0x3, 0x2, 0x2, 0x2, 0xb49, 0xb4a, 
       0x7, 0x167, 0x2, 0x2, 0xb4a, 0xb4b, 0x7, 0x1da, 0x2, 0x2, 0xb4b, 
       0xb4c, 0x5, 0xd0, 0x69, 0x2, 0xb4c, 0xb4d, 0x7, 0x8, 0x2, 0x2, 0xb4d, 
       0xb50, 0x5, 0x19c, 0xcf, 0x2, 0xb4e, 0xb4f, 0x7, 0x1b3, 0x2, 0x2, 
       0xb4f, 0xb51, 0x5, 0xd0, 0x69, 0x2, 0xb50, 0xb4e, 0x3, 0x2, 0x2, 
       0x2, 0xb50, 0xb51, 0x3, 0x2, 0x2, 0x2, 0xb51, 0xb52, 0x3, 0x2, 0x2, 
       0x2, 0xb52, 0xb53, 0x7, 0x1db, 0x2, 0x2, 0xb53, 0xb77, 0x3, 0x2, 
       0x2, 0x2, 0xb54, 0xb77, 0x7, 0xa6, 0x2, 0x2, 0xb55, 0xb56, 0x7, 0x19b, 
       0x2, 0x2, 0xb56, 0xb57, 0x7, 0x1da, 0x2, 0x2, 0xb57, 0xb58, 0x5, 
       0xd0, 0x69, 0x2, 0xb58, 0xb59, 0x7, 0x1dc, 0x2, 0x2, 0xb59, 0xb5a, 
       0x5, 0xd0, 0x69, 0x2, 0xb5a, 0xb5b, 0x7, 0x1db, 0x2, 0x2, 0xb5b, 
       0xb77, 0x3, 0x2, 0x2, 0x2, 0xb5c, 0xb77, 0x7, 0xaf, 0x2, 0x2, 0xb5d, 
       0xb5e, 0x7, 0xbb, 0x2, 0x2, 0xb5e, 0xb5f, 0x7, 0x1da, 0x2, 0x2, 0xb5f, 
       0xb60, 0x5, 0x19c, 0xcf, 0x2, 0xb60, 0xb61, 0x7, 0x1dc, 0x2, 0x2, 
       0xb61, 0xb62, 0x5, 0xd0, 0x69, 0x2, 0xb62, 0xb63, 0x7, 0x1db, 0x2, 
       0x2, 0xb63, 0xb77, 0x3, 0x2, 0x2, 0x2, 0xb64, 0xb65, 0x7, 0xba, 0x2, 
       0x2, 0xb65, 0xb66, 0x7, 0x1da, 0x2, 0x2, 0xb66, 0xb67, 0x5, 0xd0, 
       0x69, 0x2, 0xb67, 0xb68, 0x7, 0x8, 0x2, 0x2, 0xb68, 0xb69, 0x5, 0x19c, 
       0xcf, 0x2, 0xb69, 0xb6a, 0x7, 0x1db, 0x2, 0x2, 0xb6a, 0xb77, 0x3, 
       0x2, 0x2, 0x2, 0xb6b, 0xb6c, 0x7, 0xbc, 0x2, 0x2, 0xb6c, 0xb6d, 0x7, 
       0x1da, 0x2, 0x2, 0xb6d, 0xb6e, 0x5, 0xd0, 0x69, 0x2, 0xb6e, 0xb6f, 
       0x7, 0x8, 0x2, 0x2, 0xb6f, 0xb72, 0x5, 0x19c, 0xcf, 0x2, 0xb70, 0xb71, 
       0x7, 0x1b3, 0x2, 0x2, 0xb71, 0xb73, 0x5, 0xd0, 0x69, 0x2, 0xb72, 
       0xb70, 0x3, 0x2, 0x2, 0x2, 0xb72, 0xb73, 0x3, 0x2, 0x2, 0x2, 0xb73, 
       0xb74, 0x3, 0x2, 0x2, 0x2, 0xb74, 0xb75, 0x7, 0x1db, 0x2, 0x2, 0xb75, 
       0xb77, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xac9, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xaca, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xacb, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xad2, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xad3, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xad7, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xade, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xae9, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xaed, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xaf2, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xaf3, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xaf4, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xafd, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xb06, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xb0d, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xb14, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xb2b, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xb38, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xb41, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xb42, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xb49, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xb54, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xb55, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xb5c, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xb5d, 0x3, 0x2, 0x2, 0x2, 0xb76, 
       0xb64, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xb6b, 0x3, 0x2, 0x2, 0x2, 0xb77, 
       0x127, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb79, 0x7, 0xca, 0x2, 0x2, 0xb79, 
       0xb7a, 0x5, 0xd0, 0x69, 0x2, 0xb7a, 0xb7b, 0x7, 0xb3, 0x2, 0x2, 0xb7b, 
       0xb7c, 0x5, 0xd0, 0x69, 0x2, 0xb7c, 0x129, 0x3, 0x2, 0x2, 0x2, 0xb7d, 
       0xb7e, 0x7, 0xca, 0x2, 0x2, 0xb7e, 0xb7f, 0x5, 0xe2, 0x72, 0x2, 0xb7f, 
       0xb80, 0x7, 0xb3, 0x2, 0x2, 0xb80, 0xb81, 0x5, 0xd0, 0x69, 0x2, 0xb81, 
       0x12b, 0x3, 0x2, 0x2, 0x2, 0xb82, 0xb84, 0x7, 0xcd, 0x2, 0x2, 0xb83, 
       0xb82, 0x3, 0x2, 0x2, 0x2, 0xb83, 0xb84, 0x3, 0x2, 0x2, 0x2, 0xb84, 
       0xb85, 0x3, 0x2, 0x2, 0x2, 0xb85, 0xb86, 0x7, 0x1da, 0x2, 0x2, 0xb86, 
       0xb8b, 0x5, 0x130, 0x99, 0x2, 0xb87, 0xb88, 0x7, 0x1dc, 0x2, 0x2, 
       0xb88, 0xb8a, 0x5, 0x130, 0x99, 0x2, 0xb89, 0xb87, 0x3, 0x2, 0x2, 
       0x2, 0xb8a, 0xb8d, 0x3, 0x2, 0x2, 0x2, 0xb8b, 0xb89, 0x3, 0x2, 0x2, 
       0x2, 0xb8b, 0xb8c, 0x3, 0x2, 0x2, 0x2, 0xb8c, 0xb8e, 0x3, 0x2, 0x2, 
       0x2, 0xb8d, 0xb8b, 0x3, 0x2, 0x2, 0x2, 0xb8e, 0xb8f, 0x7, 0x1db, 
       0x2, 0x2, 0xb8f, 0x12d, 0x3, 0x2, 0x2, 0x2, 0xb90, 0xb91, 0x7, 0xcd, 
       0x2, 0x2, 0xb91, 0xb92, 0x7, 0x1da, 0x2, 0x2, 0xb92, 0xb97, 0x5, 
       0x130, 0x99, 0x2, 0xb93, 0xb94, 0x7, 0x1dc, 0x2, 0x2, 0xb94, 0xb96, 
       0x5, 0x130, 0x99, 0x2, 0xb95, 0xb93, 0x3, 0x2, 0x2, 0x2, 0xb96, 0xb99, 
       0x3, 0x2, 0x2, 0x2, 0xb97, 0xb95, 0x3, 0x2, 0x2, 0x2, 0xb97, 0xb98, 
       0x3, 0x2, 0x2, 0x2, 0xb98, 0xb9a, 0x3, 0x2, 0x2, 0x2, 0xb99, 0xb97, 
       0x3, 0x2, 0x2, 0x2, 0xb9a, 0xb9b, 0x7, 0x1db, 0x2, 0x2, 0xb9b, 0x12f, 
       0x3, 0x2, 0x2, 0x2, 0xb9c, 0xb9e, 0x7, 0x155, 0x2, 0x2, 0xb9d, 0xb9c, 
       0x3, 0x2, 0x2, 0x2, 0xb9d, 0xb9e, 0x3, 0x2, 0x2, 0x2, 0xb9e, 0xbc5, 
       0x3, 0x2, 0x2, 0x2, 0xb9f, 0xba0, 0x7, 0x5c, 0x2, 0x2, 0xba0, 0xba1, 
       0x7, 0x1da, 0x2, 0x2, 0xba1, 0xba6, 0x5, 0x132, 0x9a, 0x2, 0xba2, 
       0xba3, 0x7, 0x1dc, 0x2, 0x2, 0xba3, 0xba5, 0x5, 0x132, 0x9a, 0x2, 
       0xba4, 0xba2, 0x3, 0x2, 0x2, 0x2, 0xba5, 0xba8, 0x3, 0x2, 0x2, 0x2, 
       0xba6, 0xba4, 0x3, 0x2, 0x2, 0x2, 0xba6, 0xba7, 0x3, 0x2, 0x2, 0x2, 
       0xba7, 0xba9, 0x3, 0x2, 0x2, 0x2, 0xba8, 0xba6, 0x3, 0x2, 0x2, 0x2, 
       0xba9, 0xbaa, 0x7, 0x1db, 0x2, 0x2, 0xbaa, 0xbc6, 0x3, 0x2, 0x2, 
       0x2, 0xbab, 0xbac, 0x7, 0x5c, 0x2, 0x2, 0xbac, 0xbad, 0x7, 0x1c9, 
       0x2, 0x2, 0xbad, 0xbc6, 0x5, 0x132, 0x9a, 0x2, 0xbae, 0xbbd, 0x7, 
       0x4b, 0x2, 0x2, 0xbaf, 0xbb0, 0x7, 0x1da, 0x2, 0x2, 0xbb0, 0xbb1, 
       0x5, 0x132, 0x9a, 0x2, 0xbb1, 0xbb2, 0x7, 0x1da, 0x2, 0x2, 0xbb2, 
       0xbb7, 0x7, 0x1c4, 0x2, 0x2, 0xbb3, 0xbb4, 0x7, 0x1dc, 0x2, 0x2, 
       0xbb4, 0xbb6, 0x7, 0x1c4, 0x2, 0x2, 0xbb5, 0xbb3, 0x3, 0x2, 0x2, 
       0x2, 0xbb6, 0xbb9, 0x3, 0x2, 0x2, 0x2, 0xbb7, 0xbb5, 0x3, 0x2, 0x2, 
       0x2, 0xbb7, 0xbb8, 0x3, 0x2, 0x2, 0x2, 0xbb8, 0xbba, 0x3, 0x2, 0x2, 
       0x2, 0xbb9, 0xbb7, 0x3, 0x2, 0x2, 0x2, 0xbba, 0xbbb, 0x7, 0x1db, 
       0x2, 0x2, 0xbbb, 0xbbc, 0x7, 0x1db, 0x2, 0x2, 0xbbc, 0xbbe, 0x3, 
       0x2, 0x2, 0x2, 0xbbd, 0xbaf, 0x3, 0x2, 0x2, 0x2, 0xbbd, 0xbbe, 0x3, 
       0x2, 0x2, 0x2, 0xbbe, 0xbc6, 0x3, 0x2, 0x2, 0x2, 0xbbf, 0xbc6, 0x7, 
       0x18c, 0x2, 0x2, 0xbc0, 0xbc6, 0x7, 0x194, 0x2, 0x2, 0xbc1, 0xbc2, 
       0x7, 0x195, 0x2, 0x2, 0xbc2, 0xbc3, 0x7, 0x1c9, 0x2, 0x2, 0xbc3, 
       0xbc6, 0x7, 0x1c3, 0x2, 0x2, 0xbc4, 0xbc6, 0x7, 0x1c4, 0x2, 0x2, 
       0xbc5, 0xb9f, 0x3, 0x2, 0x2, 0x2, 0xbc5, 0xbab, 0x3, 0x2, 0x2, 0x2, 
       0xbc5, 0xbae, 0x3, 0x2, 0x2, 0x2, 0xbc5, 0xbbf, 0x3, 0x2, 0x2, 0x2, 
       0xbc5, 0xbc0, 0x3, 0x2, 0x2, 0x2, 0xbc5, 0xbc1, 0x3, 0x2, 0x2, 0x2, 
       0xbc5, 0xbc4, 0x3, 0x2, 0x2, 0x2, 0xbc5, 0xbc6, 0x3, 0x2, 0x2, 0x2, 
       0xbc6, 0x131, 0x3, 0x2, 0x2, 0x2, 0xbc7, 0xbca, 0x5, 0x17e, 0xc0, 
       0x2, 0xbc8, 0xbca, 0x7, 0x1c3, 0x2, 0x2, 0xbc9, 0xbc7, 0x3, 0x2, 
       0x2, 0x2, 0xbc9, 0xbc8, 0x3, 0x2, 0x2, 0x2, 0xbca, 0x133, 0x3, 0x2, 
       0x2, 0x2, 0xbcb, 0xbcc, 0x7, 0x1da, 0x2, 0x2, 0xbcc, 0xbd1, 0x5, 
       0x136, 0x9c, 0x2, 0xbcd, 0xbce, 0x7, 0x1dc, 0x2, 0x2, 0xbce, 0xbd0, 
       0x5, 0x136, 0x9c, 0x2, 0xbcf, 0xbcd, 0x3, 0x2, 0x2, 0x2, 0xbd0, 0xbd3, 
       0x3, 0x2, 0x2, 0x2, 0xbd1, 0xbcf, 0x3, 0x2, 0x2, 0x2, 0xbd1, 0xbd2, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbd4, 0x3, 0x2, 0x2, 0x2, 0xbd3, 0xbd1, 
       0x3, 0x2, 0x2, 0x2, 0xbd4, 0xbd5, 0x7, 0x1db, 0x2, 0x2, 0xbd5, 0x135, 
       0x3, 0x2, 0x2, 0x2, 0xbd6, 0xbd9, 0x5, 0x17e, 0xc0, 0x2, 0xbd7, 0xbd9, 
       0x7, 0x1c5, 0x2, 0x2, 0xbd8, 0xbd6, 0x3, 0x2, 0x2, 0x2, 0xbd8, 0xbd7, 
       0x3, 0x2, 0x2, 0x2, 0xbd9, 0x137, 0x3, 0x2, 0x2, 0x2, 0xbda, 0xbdb, 
       0x7, 0x1df, 0x2, 0x2, 0xbdb, 0x139, 0x3, 0x2, 0x2, 0x2, 0xbdc, 0xbdd, 
       0x7, 0xc5, 0x2, 0x2, 0xbdd, 0xbe2, 0x5, 0x13e, 0xa0, 0x2, 0xbde, 
       0xbdf, 0x7, 0x1dc, 0x2, 0x2, 0xbdf, 0xbe1, 0x5, 0x13e, 0xa0, 0x2, 
       0xbe0, 0xbde, 0x3, 0x2, 0x2, 0x2, 0xbe1, 0xbe4, 0x3, 0x2, 0x2, 0x2, 
       0xbe2, 0xbe0, 0x3, 0x2, 0x2, 0x2, 0xbe2, 0xbe3, 0x3, 0x2, 0x2, 0x2, 
       0xbe3, 0x13b, 0x3, 0x2, 0x2, 0x2, 0xbe4, 0xbe2, 0x3, 0x2, 0x2, 0x2, 
       0xbe5, 0xbea, 0x5, 0xd0, 0x69, 0x2, 0xbe6, 0xbe7, 0x7, 0x1dc, 0x2, 
       0x2, 0xbe7, 0xbe9, 0x5, 0xd0, 0x69, 0x2, 0xbe8, 0xbe6, 0x3, 0x2, 
       0x2, 0x2, 0xbe9, 0xbec, 0x3, 0x2, 0x2, 0x2, 0xbea, 0xbe8, 0x3, 0x2, 
       0x2, 0x2, 0xbea, 0xbeb, 0x3, 0x2, 0x2, 0x2, 0xbeb, 0x13d, 0x3, 0x2, 
       0x2, 0x2, 0xbec, 0xbea, 0x3, 0x2, 0x2, 0x2, 0xbed, 0xbee, 0x7, 0x1da, 
       0x2, 0x2, 0xbee, 0xbef, 0x5, 0x13c, 0x9f, 0x2, 0xbef, 0xbf0, 0x7, 
       0x1db, 0x2, 0x2, 0xbf0, 0x13f, 0x3, 0x2, 0x2, 0x2, 0xbf1, 0xbf2, 
       0x7, 0x6e, 0x2, 0x2, 0xbf2, 0xbf3, 0x7, 0xc6, 0x2, 0x2, 0xbf3, 0xbf4, 
       0x7, 0x4a, 0x2, 0x2, 0xbf4, 0x141, 0x3, 0x2, 0x2, 0x2, 0xbf5, 0xbf6, 
       0x5, 0x140, 0xa1, 0x2, 0xbf6, 0xbf7, 0x5, 0x166, 0xb4, 0x2, 0xbf7, 
       0xbf8, 0x5, 0x14a, 0xa6, 0x2, 0xbf8, 0x143, 0x3, 0x2, 0x2, 0x2, 0xbf9, 
       0xbfa, 0x9, 0x32, 0x2, 0x2, 0xbfa, 0xbfb, 0x7, 0x1da, 0x2, 0x2, 0xbfb, 
       0xbfc, 0x7, 0x1db, 0x2, 0x2, 0xbfc, 0xc11, 0x5, 0x14a, 0xa6, 0x2, 
       0xbfd, 0xbfe, 0x9, 0x33, 0x2, 0x2, 0xbfe, 0xbff, 0x7, 0x1da, 0x2, 
       0x2, 0xbff, 0xc00, 0x5, 0xd0, 0x69, 0x2, 0xc00, 0xc01, 0x7, 0x1db, 
       0x2, 0x2, 0xc01, 0xc02, 0x5, 0x14a, 0xa6, 0x2, 0xc02, 0xc11, 0x3, 
       0x2, 0x2, 0x2, 0xc03, 0xc04, 0x9, 0x34, 0x2, 0x2, 0xc04, 0xc05, 0x7, 
       0x1da, 0x2, 0x2, 0xc05, 0xc0a, 0x5, 0xd0, 0x69, 0x2, 0xc06, 0xc07, 
       0x7, 0x1dc, 0x2, 0x2, 0xc07, 0xc09, 0x5, 0xd0, 0x69, 0x2, 0xc08, 
       0xc06, 0x3, 0x2, 0x2, 0x2, 0xc09, 0xc0c, 0x3, 0x2, 0x2, 0x2, 0xc0a, 
       0xc08, 0x3, 0x2, 0x2, 0x2, 0xc0a, 0xc0b, 0x3, 0x2, 0x2, 0x2, 0xc0b, 
       0xc0d, 0x3, 0x2, 0x2, 0x2, 0xc0c, 0xc0a, 0x3, 0x2, 0x2, 0x2, 0xc0d, 
       0xc0e, 0x7, 0x1db, 0x2, 0x2, 0xc0e, 0xc0f, 0x5, 0x14a, 0xa6, 0x2, 
       0xc0f, 0xc11, 0x3, 0x2, 0x2, 0x2, 0xc10, 0xbf9, 0x3, 0x2, 0x2, 0x2, 
       0xc10, 0xbfd, 0x3, 0x2, 0x2, 0x2, 0xc10, 0xc03, 0x3, 0x2, 0x2, 0x2, 
       0xc11, 0x145, 0x3, 0x2, 0x2, 0x2, 0xc12, 0xc13, 0x9, 0x35, 0x2, 0x2, 
       0xc13, 0xc15, 0x7, 0x1da, 0x2, 0x2, 0xc14, 0xc16, 0x5, 0x148, 0xa5, 
       0x2, 0xc15, 0xc14, 0x3, 0x2, 0x2, 0x2, 0xc15, 0xc16, 0x3, 0x2, 0x2, 
       0x2, 0xc16, 0xc17, 0x3, 0x2, 0x2, 0x2, 0xc17, 0xc18, 0x5, 0xd0, 0x69, 
       0x2, 0xc18, 0xc1a, 0x7, 0x1db, 0x2, 0x2, 0xc19, 0xc1b, 0x5, 0x14a, 
       0xa6, 0x2, 0xc1a, 0xc19, 0x3, 0x2, 0x2, 0x2, 0xc1a, 0xc1b, 0x3, 0x2, 
       0x2, 0x2, 0xc1b, 0xc3c, 0x3, 0x2, 0x2, 0x2, 0xc1c, 0xc1d, 0x9, 0x36, 
       0x2, 0x2, 0xc1d, 0xc23, 0x7, 0x1da, 0x2, 0x2, 0xc1e, 0xc24, 0x7, 
       0x1df, 0x2, 0x2, 0xc1f, 0xc21, 0x5, 0x148, 0xa5, 0x2, 0xc20, 0xc1f, 
       0x3, 0x2, 0x2, 0x2, 0xc20, 0xc21, 0x3, 0x2, 0x2, 0x2, 0xc21, 0xc22, 
       0x3, 0x2, 0x2, 0x2, 0xc22, 0xc24, 0x5, 0xd0, 0x69, 0x2, 0xc23, 0xc1e, 
       0x3, 0x2, 0x2, 0x2, 0xc23, 0xc20, 0x3, 0x2, 0x2, 0x2, 0xc24, 0xc25, 
       0x3, 0x2, 0x2, 0x2, 0xc25, 0xc27, 0x7, 0x1db, 0x2, 0x2, 0xc26, 0xc28, 
       0x5, 0x14a, 0xa6, 0x2, 0xc27, 0xc26, 0x3, 0x2, 0x2, 0x2, 0xc27, 0xc28, 
       0x3, 0x2, 0x2, 0x2, 0xc28, 0xc3c, 0x3, 0x2, 0x2, 0x2, 0xc29, 0xc2a, 
       0x7, 0xee, 0x2, 0x2, 0xc2a, 0xc2c, 0x7, 0x1da, 0x2, 0x2, 0xc2b, 0xc2d, 
       0x5, 0x148, 0xa5, 0x2, 0xc2c, 0xc2b, 0x3, 0x2, 0x2, 0x2, 0xc2c, 0xc2d, 
       0x3, 0x2, 0x2, 0x2, 0xc2d, 0xc2e, 0x3, 0x2, 0x2, 0x2, 0xc2e, 0xc2f, 
       0x5, 0xd0, 0x69, 0x2, 0xc2f, 0xc30, 0x7, 0x1db, 0x2, 0x2, 0xc30, 
       0xc3c, 0x3, 0x2, 0x2, 0x2, 0xc31, 0xc32, 0x7, 0x126, 0x2, 0x2, 0xc32, 
       0xc33, 0x7, 0x1da, 0x2, 0x2, 0xc33, 0xc34, 0x5, 0xd0, 0x69, 0x2, 
       0xc34, 0xc35, 0x7, 0x1db, 0x2, 0x2, 0xc35, 0xc3c, 0x3, 0x2, 0x2, 
       0x2, 0xc36, 0xc37, 0x7, 0x127, 0x2, 0x2, 0xc37, 0xc38, 0x7, 0x1da, 
       0x2, 0x2, 0xc38, 0xc39, 0x5, 0x13c, 0x9f, 0x2, 0xc39, 0xc3a, 0x7, 
       0x1db, 0x2, 0x2, 0xc3a, 0xc3c, 0x3, 0x2, 0x2, 0x2, 0xc3b, 0xc12, 
       0x3, 0x2, 0x2, 0x2, 0xc3b, 0xc1c, 0x3, 0x2, 0x2, 0x2, 0xc3b, 0xc29, 
       0x3, 0x2, 0x2, 0x2, 0xc3b, 0xc31, 0x3, 0x2, 0x2, 0x2, 0xc3b, 0xc36, 
       0x3, 0x2, 0x2, 0x2, 0xc3c, 0x147, 0x3, 0x2, 0x2, 0x2, 0xc3d, 0xc3e, 
       0x9, 0x25, 0x2, 0x2, 0xc3e, 0x149, 0x3, 0x2, 0x2, 0x2, 0xc3f, 0xc40, 
       0x7, 0x83, 0x2, 0x2, 0xc40, 0xc44, 0x7, 0x1da, 0x2, 0x2, 0xc41, 0xc42, 
       0x7, 0x168, 0x2, 0x2, 0xc42, 0xc43, 0x7, 0x11, 0x2, 0x2, 0xc43, 0xc45, 
       0x5, 0x13c, 0x9f, 0x2, 0xc44, 0xc41, 0x3, 0x2, 0x2, 0x2, 0xc44, 0xc45, 
       0x3, 0x2, 0x2, 0x2, 0xc45, 0xc47, 0x3, 0x2, 0x2, 0x2, 0xc46, 0xc48, 
       0x5, 0xf6, 0x7c, 0x2, 0xc47, 0xc46, 0x3, 0x2, 0x2, 0x2, 0xc47, 0xc48, 
       0x3, 0x2, 0x2, 0x2, 0xc48, 0xc4a, 0x3, 0x2, 0x2, 0x2, 0xc49, 0xc4b, 
       0x5, 0x14c, 0xa7, 0x2, 0xc4a, 0xc49, 0x3, 0x2, 0x2, 0x2, 0xc4a, 0xc4b, 
       0x3, 0x2, 0x2, 0x2, 0xc4b, 0xc4c, 0x3, 0x2, 0x2, 0x2, 0xc4c, 0xc4d, 
       0x7, 0x1db, 0x2, 0x2, 0xc4d, 0x14b, 0x3, 0x2, 0x2, 0x2, 0xc4e, 0xc4f, 
       0x9, 0x37, 0x2, 0x2, 0xc4f, 0xc50, 0x5, 0x14e, 0xa8, 0x2, 0xc50, 
       0x14d, 0x3, 0x2, 0x2, 0x2, 0xc51, 0xc58, 0x5, 0x152, 0xaa, 0x2, 0xc52, 
       0xc53, 0x7, 0xd, 0x2, 0x2, 0xc53, 0xc54, 0x5, 0x150, 0xa9, 0x2, 0xc54, 
       0xc55, 0x7, 0x6, 0x2, 0x2, 0xc55, 0xc56, 0x5, 0x150, 0xa9, 0x2, 0xc56, 
       0xc58, 0x3, 0x2, 0x2, 0x2, 0xc57, 0xc51, 0x3, 0x2, 0x2, 0x2, 0xc57, 
       0xc52, 0x3, 0x2, 0x2, 0x2, 0xc58, 0x14f, 0x3, 0x2, 0x2, 0x2, 0xc59, 
       0xc5c, 0x5, 0x152, 0xaa, 0x2, 0xc5a, 0xc5c, 0x5, 0x154, 0xab, 0x2, 
       0xc5b, 0xc59, 0x3, 0x2, 0x2, 0x2, 0xc5b, 0xc5a, 0x3, 0x2, 0x2, 0x2, 
       0xc5c, 0x151, 0x3, 0x2, 0x2, 0x2, 0xc5d, 0xc5e, 0x7, 0x1af, 0x2, 
       0x2, 0xc5e, 0xc64, 0x7, 0x16c, 0x2, 0x2, 0xc5f, 0xc60, 0x7, 0x1c3, 
       0x2, 0x2, 0xc60, 0xc64, 0x7, 0x16c, 0x2, 0x2, 0xc61, 0xc62, 0x7, 
       0x28, 0x2, 0x2, 0xc62, 0xc64, 0x7, 0x182, 0x2, 0x2, 0xc63, 0xc5d, 
       0x3, 0x2, 0x2, 0x2, 0xc63, 0xc5f, 0x3, 0x2, 0x2, 0x2, 0xc63, 0xc61, 
       0x3, 0x2, 0x2, 0x2, 0xc64, 0x153, 0x3, 0x2, 0x2, 0x2, 0xc65, 0xc66, 
       0x7, 0x1af, 0x2, 0x2, 0xc66, 0xc6a, 0x7, 0x11e, 0x2, 0x2, 0xc67, 
       0xc68, 0x7, 0x1c3, 0x2, 0x2, 0xc68, 0xc6a, 0x7, 0x11e, 0x2, 0x2, 
       0xc69, 0xc65, 0x3, 0x2, 0x2, 0x2, 0xc69, 0xc67, 0x3, 0x2, 0x2, 0x2, 
       0xc6a, 0x155, 0x3, 0x2, 0x2, 0x2, 0xc6b, 0xc6c, 0x7, 0x11a, 0x2, 
       0x2, 0xc6c, 0xc71, 0x5, 0x158, 0xad, 0x2, 0xc6d, 0xc6e, 0x7, 0x1dc, 
       0x2, 0x2, 0xc6e, 0xc70, 0x5, 0x158, 0xad, 0x2, 0xc6f, 0xc6d, 0x3, 
       0x2, 0x2, 0x2, 0xc70, 0xc73, 0x3, 0x2, 0x2, 0x2, 0xc71, 0xc6f, 0x3, 
       0x2, 0x2, 0x2, 0xc71, 0xc72, 0x3, 0x2, 0x2, 0x2, 0xc72, 0xc8e, 0x3, 
       0x2, 0x2, 0x2, 0xc73, 0xc71, 0x3, 0x2, 0x2, 0x2, 0xc74, 0xc75, 0x7, 
       0x106, 0x2, 0x2, 0xc75, 0xc78, 0x7, 0x1c9, 0x2, 0x2, 0xc76, 0xc79, 
       0x5, 0x17e, 0xc0, 0x2, 0xc77, 0xc79, 0x7, 0x1c5, 0x2, 0x2, 0xc78, 
       0xc76, 0x3, 0x2, 0x2, 0x2, 0xc78, 0xc77, 0x3, 0x2, 0x2, 0x2, 0xc79, 
       0xc8e, 0x3, 0x2, 0x2, 0x2, 0xc7a, 0xc7b, 0x7, 0x105, 0x2, 0x2, 0xc7b, 
       0xc7e, 0x7, 0x1c9, 0x2, 0x2, 0xc7c, 0xc7f, 0x5, 0x17e, 0xc0, 0x2, 
       0xc7d, 0xc7f, 0x7, 0x1c5, 0x2, 0x2, 0xc7e, 0xc7c, 0x3, 0x2, 0x2, 
       0x2, 0xc7e, 0xc7d, 0x3, 0x2, 0x2, 0x2, 0xc7f, 0xc8e, 0x3, 0x2, 0x2, 
       0x2, 0xc80, 0xc81, 0x7, 0x151, 0x2, 0x2, 0xc81, 0xc82, 0x7, 0x1c9, 
       0x2, 0x2, 0xc82, 0xc8e, 0x9, 0xb, 0x2, 0x2, 0xc83, 0xc84, 0x7, 0x1a9, 
       0x2, 0x2, 0xc84, 0xc85, 0x7, 0x1c9, 0x2, 0x2, 0xc85, 0xc8e, 0x9, 
       0xb, 0x2, 0x2, 0xc86, 0xc87, 0x7, 0x1ac, 0x2, 0x2, 0xc87, 0xc88, 
       0x7, 0x1c9, 0x2, 0x2, 0xc88, 0xc8e, 0x7, 0x1c3, 0x2, 0x2, 0xc89, 
       0xc8a, 0x7, 0x104, 0x2, 0x2, 0xc8a, 0xc8e, 0x9, 0xb, 0x2, 0x2, 0xc8b, 
       0xc8c, 0x7, 0x1aa, 0x2, 0x2, 0xc8c, 0xc8e, 0x9, 0xb, 0x2, 0x2, 0xc8d, 
       0xc6b, 0x3, 0x2, 0x2, 0x2, 0xc8d, 0xc74, 0x3, 0x2, 0x2, 0x2, 0xc8d, 
       0xc7a, 0x3, 0x2, 0x2, 0x2, 0xc8d, 0xc80, 0x3, 0x2, 0x2, 0x2, 0xc8d, 
       0xc83, 0x3, 0x2, 0x2, 0x2, 0xc8d, 0xc86, 0x3, 0x2, 0x2, 0x2, 0xc8d, 
       0xc89, 0x3, 0x2, 0x2, 0x2, 0xc8d, 0xc8b, 0x3, 0x2, 0x2, 0x2, 0xc8e, 
       0x157, 0x3, 0x2, 0x2, 0x2, 0xc8f, 0xc96, 0x7, 0x1da, 0x2, 0x2, 0xc90, 
       0xc91, 0x7, 0x156, 0x2, 0x2, 0xc91, 0xc92, 0x7, 0x1c9, 0x2, 0x2, 
       0xc92, 0xc97, 0x9, 0x38, 0x2, 0x2, 0xc93, 0xc94, 0x7, 0x10b, 0x2, 
       0x2, 0xc94, 0xc95, 0x7, 0x1c9, 0x2, 0x2, 0xc95, 0xc97, 0x7, 0x1c5, 
       0x2, 0x2, 0xc96, 0xc90, 0x3, 0x2, 0x2, 0x2, 0xc96, 0xc93, 0x3, 0x2, 
       0x2, 0x2, 0xc97, 0xc98, 0x3, 0x2, 0x2, 0x2, 0xc98, 0xc99, 0x7, 0x1db, 
       0x2, 0x2, 0xc99, 0x159, 0x3, 0x2, 0x2, 0x2, 0xc9a, 0xc9d, 0x5, 0x15c, 
       0xaf, 0x2, 0xc9b, 0xc9d, 0x5, 0x15e, 0xb0, 0x2, 0xc9c, 0xc9a, 0x3, 
       0x2, 0x2, 0x2, 0xc9c, 0xc9b, 0x3, 0x2, 0x2, 0x2, 0xc9d, 0x15b, 0x3, 
       0x2, 0x2, 0x2, 0xc9e, 0xc9f, 0x7, 0x118, 0x2, 0x2, 0xc9f, 0xca2, 
       0x5, 0x17e, 0xc0, 0x2, 0xca0, 0xca1, 0x7, 0x22, 0x2, 0x2, 0xca1, 
       0xca3, 0x7, 0x11a, 0x2, 0x2, 0xca2, 0xca0, 0x3, 0x2, 0x2, 0x2, 0xca2, 
       0xca3, 0x3, 0x2, 0x2, 0x2, 0xca3, 0xca5, 0x3, 0x2, 0x2, 0x2, 0xca4, 
       0xca6, 0x7, 0x32, 0x2, 0x2, 0xca5, 0xca4, 0x3, 0x2, 0x2, 0x2, 0xca5, 
       0xca6, 0x3, 0x2, 0x2, 0x2, 0xca6, 0xca9, 0x3, 0x2, 0x2, 0x2, 0xca7, 
       0xca8, 0x7, 0x22, 0x2, 0x2, 0xca8, 0xcaa, 0x7, 0x149, 0x2, 0x2, 0xca9, 
       0xca7, 0x3, 0x2, 0x2, 0x2, 0xca9, 0xcaa, 0x3, 0x2, 0x2, 0x2, 0xcaa, 
       0xcab, 0x3, 0x2, 0x2, 0x2, 0xcab, 0xcb0, 0x5, 0x15e, 0xb0, 0x2, 0xcac, 
       0xcad, 0x7, 0x1dc, 0x2, 0x2, 0xcad, 0xcaf, 0x5, 0x15e, 0xb0, 0x2, 
       0xcae, 0xcac, 0x3, 0x2, 0x2, 0x2, 0xcaf, 0xcb2, 0x3, 0x2, 0x2, 0x2, 
       0xcb0, 0xcae, 0x3, 0x2, 0x2, 0x2, 0xcb0, 0xcb1, 0x3, 0x2, 0x2, 0x2, 
       0xcb1, 0x15d, 0x3, 0x2, 0x2, 0x2, 0xcb2, 0xcb0, 0x3, 0x2, 0x2, 0x2, 
       0xcb3, 0xcb4, 0x7, 0x1da, 0x2, 0x2, 0xcb4, 0xcb5, 0x7, 0x150, 0x2, 
       0x2, 0xcb5, 0xcb8, 0x7, 0x1c9, 0x2, 0x2, 0xcb6, 0xcb9, 0x5, 0x17e, 
       0xc0, 0x2, 0xcb7, 0xcb9, 0x7, 0x1c5, 0x2, 0x2, 0xcb8, 0xcb6, 0x3, 
       0x2, 0x2, 0x2, 0xcb8, 0xcb7, 0x3, 0x2, 0x2, 0x2, 0xcb9, 0xcbb, 0x3, 
       0x2, 0x2, 0x2, 0xcba, 0xcbc, 0x7, 0x1dc, 0x2, 0x2, 0xcbb, 0xcba, 
       0x3, 0x2, 0x2, 0x2, 0xcbb, 0xcbc, 0x3, 0x2, 0x2, 0x2, 0xcbc, 0xcbd, 
       0x3, 0x2, 0x2, 0x2, 0xcbd, 0xcbe, 0x7, 0x48, 0x2, 0x2, 0xcbe, 0xcbf, 
       0x7, 0x1c9, 0x2, 0x2, 0xcbf, 0xcc1, 0x7, 0x1c5, 0x2, 0x2, 0xcc0, 
       0xcc2, 0x7, 0x1dc, 0x2, 0x2, 0xcc1, 0xcc0, 0x3, 0x2, 0x2, 0x2, 0xcc1, 
       0xcc2, 0x3, 0x2, 0x2, 0x2, 0xcc2, 0xcc9, 0x3, 0x2, 0x2, 0x2, 0xcc3, 
       0xcc4, 0x7, 0x192, 0x2, 0x2, 0xcc4, 0xcc5, 0x7, 0x1c9, 0x2, 0x2, 
       0xcc5, 0xcc7, 0x5, 0x186, 0xc4, 0x2, 0xcc6, 0xcc8, 0x7, 0x1dc, 0x2, 
       0x2, 0xcc7, 0xcc6, 0x3, 0x2, 0x2, 0x2, 0xcc7, 0xcc8, 0x3, 0x2, 0x2, 
       0x2, 0xcc8, 0xcca, 0x3, 0x2, 0x2, 0x2, 0xcc9, 0xcc3, 0x3, 0x2, 0x2, 
       0x2, 0xcc9, 0xcca, 0x3, 0x2, 0x2, 0x2, 0xcca, 0xcd4, 0x3, 0x2, 0x2, 
       0x2, 0xccb, 0xccc, 0x7, 0x147, 0x2, 0x2, 0xccc, 0xccf, 0x7, 0x1c9, 
       0x2, 0x2, 0xccd, 0xcd0, 0x5, 0x186, 0xc4, 0x2, 0xcce, 0xcd0, 0x7, 
       0x1b2, 0x2, 0x2, 0xccf, 0xccd, 0x3, 0x2, 0x2, 0x2, 0xccf, 0xcce, 
       0x3, 0x2, 0x2, 0x2, 0xcd0, 0xcd2, 0x3, 0x2, 0x2, 0x2, 0xcd1, 0xcd3, 
       0x7, 0x1dc, 0x2, 0x2, 0xcd2, 0xcd1, 0x3, 0x2, 0x2, 0x2, 0xcd2, 0xcd3, 
       0x3, 0x2, 0x2, 0x2, 0xcd3, 0xcd5, 0x3, 0x2, 0x2, 0x2, 0xcd4, 0xccb, 
       0x3, 0x2, 0x2, 0x2, 0xcd4, 0xcd5, 0x3, 0x2, 0x2, 0x2, 0xcd5, 0xcdc, 
       0x3, 0x2, 0x2, 0x2, 0xcd6, 0xcd7, 0x7, 0x119, 0x2, 0x2, 0xcd7, 0xcd8, 
       0x7, 0x1c9, 0x2, 0x2, 0xcd8, 0xcda, 0x5, 0x186, 0xc4, 0x2, 0xcd9, 
       0xcdb, 0x7, 0x1dc, 0x2, 0x2, 0xcda, 0xcd9, 0x3, 0x2, 0x2, 0x2, 0xcda, 
       0xcdb, 0x3, 0x2, 0x2, 0x2, 0xcdb, 0xcdd, 0x3, 0x2, 0x2, 0x2, 0xcdc, 
       0xcd6, 0x3, 0x2, 0x2, 0x2, 0xcdc, 0xcdd, 0x3, 0x2, 0x2, 0x2, 0xcdd, 
       0xcde, 0x3, 0x2, 0x2, 0x2, 0xcde, 0xcdf, 0x7, 0x1db, 0x2, 0x2, 0xcdf, 
       0x15f, 0x3, 0x2, 0x2, 0x2, 0xce0, 0xce1, 0x5, 0x17e, 0xc0, 0x2, 0xce1, 
       0xce2, 0x7, 0x1d5, 0x2, 0x2, 0xce2, 0xce3, 0x5, 0x17e, 0xc0, 0x2, 
       0xce3, 0xce4, 0x7, 0x1d5, 0x2, 0x2, 0xce4, 0xce5, 0x5, 0x17e, 0xc0, 
       0x2, 0xce5, 0xce6, 0x7, 0x1d5, 0x2, 0x2, 0xce6, 0xcf2, 0x3, 0x2, 
       0x2, 0x2, 0xce7, 0xce8, 0x5, 0x17e, 0xc0, 0x2, 0xce8, 0xcea, 0x7, 
       0x1d5, 0x2, 0x2, 0xce9, 0xceb, 0x5, 0x17e, 0xc0, 0x2, 0xcea, 0xce9, 
       0x3, 0x2, 0x2, 0x2, 0xcea, 0xceb, 0x3, 0x2, 0x2, 0x2, 0xceb, 0xcec, 
       0x3, 0x2, 0x2, 0x2, 0xcec, 0xced, 0x7, 0x1d5, 0x2, 0x2, 0xced, 0xcf2, 
       0x3, 0x2, 0x2, 0x2, 0xcee, 0xcef, 0x5, 0x17e, 0xc0, 0x2, 0xcef, 0xcf0, 
       0x7, 0x1d5, 0x2, 0x2, 0xcf0, 0xcf2, 0x3, 0x2, 0x2, 0x2, 0xcf1, 0xce0, 
       0x3, 0x2, 0x2, 0x2, 0xcf1, 0xce7, 0x3, 0x2, 0x2, 0x2, 0xcf1, 0xcee, 
       0x3, 0x2, 0x2, 0x2, 0xcf1, 0xcf2, 0x3, 0x2, 0x2, 0x2, 0xcf2, 0xcf3, 
       0x3, 0x2, 0x2, 0x2, 0xcf3, 0xcf4, 0x5, 0x17e, 0xc0, 0x2, 0xcf4, 0x161, 
       0x3, 0x2, 0x2, 0x2, 0xcf5, 0xcf6, 0x5, 0x17e, 0xc0, 0x2, 0xcf6, 0xcf8, 
       0x7, 0x1d5, 0x2, 0x2, 0xcf7, 0xcf9, 0x5, 0x17e, 0xc0, 0x2, 0xcf8, 
       0xcf7, 0x3, 0x2, 0x2, 0x2, 0xcf8, 0xcf9, 0x3, 0x2, 0x2, 0x2, 0xcf9, 
       0xcfa, 0x3, 0x2, 0x2, 0x2, 0xcfa, 0xcfb, 0x7, 0x1d5, 0x2, 0x2, 0xcfb, 
       0xd00, 0x3, 0x2, 0x2, 0x2, 0xcfc, 0xcfd, 0x5, 0x17e, 0xc0, 0x2, 0xcfd, 
       0xcfe, 0x7, 0x1d5, 0x2, 0x2, 0xcfe, 0xd00, 0x3, 0x2, 0x2, 0x2, 0xcff, 
       0xcf5, 0x3, 0x2, 0x2, 0x2, 0xcff, 0xcfc, 0x3, 0x2, 0x2, 0x2, 0xcff, 
       0xd00, 0x3, 0x2, 0x2, 0x2, 0xd00, 0xd01, 0x3, 0x2, 0x2, 0x2, 0xd01, 
       0xd02, 0x5, 0x17e, 0xc0, 0x2, 0xd02, 0x163, 0x3, 0x2, 0x2, 0x2, 0xd03, 
       0xd04, 0x5, 0x17e, 0xc0, 0x2, 0xd04, 0xd05, 0x7, 0x1d5, 0x2, 0x2, 
       0xd05, 0xd07, 0x3, 0x2, 0x2, 0x2, 0xd06, 0xd03, 0x3, 0x2, 0x2, 0x2, 
       0xd06, 0xd07, 0x3, 0x2, 0x2, 0x2, 0xd07, 0xd08, 0x3, 0x2, 0x2, 0x2, 
       0xd08, 0xd09, 0x5, 0x17e, 0xc0, 0x2, 0xd09, 0x165, 0x3, 0x2, 0x2, 
       0x2, 0xd0a, 0xd0b, 0x5, 0x17e, 0xc0, 0x2, 0xd0b, 0xd0d, 0x7, 0x1d5, 
       0x2, 0x2, 0xd0c, 0xd0e, 0x5, 0x17e, 0xc0, 0x2, 0xd0d, 0xd0c, 0x3, 
       0x2, 0x2, 0x2, 0xd0d, 0xd0e, 0x3, 0x2, 0x2, 0x2, 0xd0e, 0xd0f, 0x3, 
       0x2, 0x2, 0x2, 0xd0f, 0xd10, 0x7, 0x1d5, 0x2, 0x2, 0xd10, 0xd15, 
       0x3, 0x2, 0x2, 0x2, 0xd11, 0xd12, 0x5, 0x17e, 0xc0, 0x2, 0xd12, 0xd13, 
       0x7, 0x1d5, 0x2, 0x2, 0xd13, 0xd15, 0x3, 0x2, 0x2, 0x2, 0xd14, 0xd0a, 
       0x3, 0x2, 0x2, 0x2, 0xd14, 0xd11, 0x3, 0x2, 0x2, 0x2, 0xd14, 0xd15, 
       0x3, 0x2, 0x2, 0x2, 0xd15, 0xd16, 0x3, 0x2, 0x2, 0x2, 0xd16, 0xd17, 
       0x5, 0x17e, 0xc0, 0x2, 0xd17, 0x167, 0x3, 0x2, 0x2, 0x2, 0xd18, 0xd1b, 
       0x5, 0x160, 0xb1, 0x2, 0xd19, 0xd1b, 0x7, 0x1c2, 0x2, 0x2, 0xd1a, 
       0xd18, 0x3, 0x2, 0x2, 0x2, 0xd1a, 0xd19, 0x3, 0x2, 0x2, 0x2, 0xd1b, 
       0x169, 0x3, 0x2, 0x2, 0x2, 0xd1c, 0xd1d, 0x5, 0x162, 0xb2, 0x2, 0xd1d, 
       0xd1e, 0x7, 0x1d5, 0x2, 0x2, 0xd1e, 0xd20, 0x3, 0x2, 0x2, 0x2, 0xd1f, 
       0xd1c, 0x3, 0x2, 0x2, 0x2, 0xd1f, 0xd20, 0x3, 0x2, 0x2, 0x2, 0xd20, 
       0xd21, 0x3, 0x2, 0x2, 0x2, 0xd21, 0xd22, 0x5, 0x17e, 0xc0, 0x2, 0xd22, 
       0x16b, 0x3, 0x2, 0x2, 0x2, 0xd23, 0xd28, 0x5, 0x17e, 0xc0, 0x2, 0xd24, 
       0xd25, 0x7, 0x1dc, 0x2, 0x2, 0xd25, 0xd27, 0x5, 0x17e, 0xc0, 0x2, 
       0xd26, 0xd24, 0x3, 0x2, 0x2, 0x2, 0xd27, 0xd2a, 0x3, 0x2, 0x2, 0x2, 
       0xd28, 0xd26, 0x3, 0x2, 0x2, 0x2, 0xd28, 0xd29, 0x3, 0x2, 0x2, 0x2, 
       0xd29, 0x16d, 0x3, 0x2, 0x2, 0x2, 0xd2a, 0xd28, 0x3, 0x2, 0x2, 0x2, 
       0xd2b, 0xd2e, 0x5, 0x17e, 0xc0, 0x2, 0xd2c, 0xd2e, 0x7, 0x1c2, 0x2, 
       0x2, 0xd2d, 0xd2b, 0x3, 0x2, 0x2, 0x2, 0xd2d, 0xd2c, 0x3, 0x2, 0x2, 
       0x2, 0xd2e, 0x16f, 0x3, 0x2, 0x2, 0x2, 0xd2f, 0xd30, 0x9, 0xb, 0x2, 
       0x2, 0xd30, 0x171, 0x3, 0x2, 0x2, 0x2, 0xd31, 0xd32, 0x9, 0x39, 0x2, 
       0x2, 0xd32, 0x173, 0x3, 0x2, 0x2, 0x2, 0xd33, 0xd35, 0x7, 0x72, 0x2, 
       0x2, 0xd34, 0xd33, 0x3, 0x2, 0x2, 0x2, 0xd34, 0xd35, 0x3, 0x2, 0x2, 
       0x2, 0xd35, 0xd36, 0x3, 0x2, 0x2, 0x2, 0xd36, 0xd37, 0x7, 0x73, 0x2, 
       0x2, 0xd37, 0x175, 0x3, 0x2, 0x2, 0x2, 0xd38, 0xd4b, 0x5, 0x166, 
       0xb4, 0x2, 0xd39, 0xd4b, 0x7, 0x9a, 0x2, 0x2, 0xd3a, 0xd4b, 0x7, 
       0x66, 0x2, 0x2, 0xd3b, 0xd4b, 0x7, 0xe5, 0x2, 0x2, 0xd3c, 0xd4b, 
       0x7, 0xed, 0x2, 0x2, 0xd3d, 0xd4b, 0x7, 0x44, 0x2, 0x2, 0xd3e, 0xd4b, 
       0x7, 0x6a, 0x2, 0x2, 0xd3f, 0xd4b, 0x7, 0x6b, 0x2, 0x2, 0xd40, 0xd4b, 
       0x7, 0x19e, 0x2, 0x2, 0xd41, 0xd4b, 0x7, 0x19d, 0x2, 0x2, 0xd42, 
       0xd4b, 0x7, 0x181, 0x2, 0x2, 0xd43, 0xd4b, 0x7, 0xea, 0x2, 0x2, 0xd44, 
       0xd4b, 0x7, 0x11d, 0x2, 0x2, 0xd45, 0xd4b, 0x7, 0x16b, 0x2, 0x2, 
       0xd46, 0xd4b, 0x7, 0xf5, 0x2, 0x2, 0xd47, 0xd4b, 0x7, 0x190, 0x2, 
       0x2, 0xd48, 0xd4b, 0x7, 0x1a0, 0x2, 0x2, 0xd49, 0xd4b, 0x7, 0xaa, 
       0x2, 0x2, 0xd4a, 0xd38, 0x3, 0x2, 0x2, 0x2, 0xd4a, 0xd39, 0x3, 0x2, 
       0x2, 0x2, 0xd4a, 0xd3a, 0x3, 0x2, 0x2, 0x2, 0xd4a, 0xd3b, 0x3, 0x2, 
       0x2, 0x2, 0xd4a, 0xd3c, 0x3, 0x2, 0x2, 0x2, 0xd4a, 0xd3d, 0x3, 0x2, 
       0x2, 0x2, 0xd4a, 0xd3e, 0x3, 0x2, 0x2, 0x2, 0xd4a, 0xd3f, 0x3, 0x2, 
       0x2, 0x2, 0xd4a, 0xd40, 0x3, 0x2, 0x2, 0x2, 0xd4a, 0xd41, 0x3, 0x2, 
       0x2, 0x2, 0xd4a, 0xd42, 0x3, 0x2, 0x2, 0x2, 0xd4a, 0xd43, 0x3, 0x2, 
       0x2, 0x2, 0xd4a, 0xd44, 0x3, 0x2, 0x2, 0x2, 0xd4a, 0xd45, 0x3, 0x2, 
       0x2, 0x2, 0xd4a, 0xd46, 0x3, 0x2, 0x2, 0x2, 0xd4a, 0xd47, 0x3, 0x2, 
       0x2, 0x2, 0xd4a, 0xd48, 0x3, 0x2, 0x2, 0x2, 0xd4a, 0xd49, 0x3, 0x2, 
       0x2, 0x2, 0xd4b, 0x177, 0x3, 0x2, 0x2, 0x2, 0xd4c, 0xd4f, 0x7, 0x73, 
       0x2, 0x2, 0xd4d, 0xd4f, 0x5, 0x17a, 0xbe, 0x2, 0xd4e, 0xd4c, 0x3, 
       0x2, 0x2, 0x2, 0xd4e, 0xd4d, 0x3, 0x2, 0x2, 0x2, 0xd4f, 0x179, 0x3, 
       0x2, 0x2, 0x2, 0xd50, 0xd60, 0x7, 0x1c5, 0x2, 0x2, 0xd51, 0xd60, 
       0x7, 0x1c6, 0x2, 0x2, 0xd52, 0xd54, 0x5, 0x17c, 0xbf, 0x2, 0xd53, 
       0xd52, 0x3, 0x2, 0x2, 0x2, 0xd53, 0xd54, 0x3, 0x2, 0x2, 0x2, 0xd54, 
       0xd55, 0x3, 0x2, 0x2, 0x2, 0xd55, 0xd60, 0x7, 0x1c3, 0x2, 0x2, 0xd56, 
       0xd58, 0x5, 0x17c, 0xbf, 0x2, 0xd57, 0xd56, 0x3, 0x2, 0x2, 0x2, 0xd57, 
       0xd58, 0x3, 0x2, 0x2, 0x2, 0xd58, 0xd59, 0x3, 0x2, 0x2, 0x2, 0xd59, 
       0xd60, 0x9, 0x3a, 0x2, 0x2, 0xd5a, 0xd5c, 0x5, 0x17c, 0xbf, 0x2, 
       0xd5b, 0xd5a, 0x3, 0x2, 0x2, 0x2, 0xd5b, 0xd5c, 0x3, 0x2, 0x2, 0x2, 
       0xd5c, 0xd5d, 0x3, 0x2, 0x2, 0x2, 0xd5d, 0xd5e, 0x7, 0x1d9, 0x2, 
       0x2, 0xd5e, 0xd60, 0x9, 0x3b, 0x2, 0x2, 0xd5f, 0xd50, 0x3, 0x2, 0x2, 
       0x2, 0xd5f, 0xd51, 0x3, 0x2, 0x2, 0x2, 0xd5f, 0xd53, 0x3, 0x2, 0x2, 
       0x2, 0xd5f, 0xd57, 0x3, 0x2, 0x2, 0x2, 0xd5f, 0xd5b, 0x3, 0x2, 0x2, 
       0x2, 0xd60, 0x17b, 0x3, 0x2, 0x2, 0x2, 0xd61, 0xd62, 0x9, 0x20, 0x2, 
       0x2, 0xd62, 0x17d, 0x3, 0x2, 0x2, 0x2, 0xd63, 0xd67, 0x5, 0x180, 
       0xc1, 0x2, 0xd64, 0xd67, 0x7, 0x1c0, 0x2, 0x2, 0xd65, 0xd67, 0x7, 
       0x1c1, 0x2, 0x2, 0xd66, 0xd63, 0x3, 0x2, 0x2, 0x2, 0xd66, 0xd64, 
       0x3, 0x2, 0x2, 0x2, 0xd66, 0xd65, 0x3, 0x2, 0x2, 0x2, 0xd67, 0x17f, 
       0x3, 0x2, 0x2, 0x2, 0xd68, 0xd69, 0x9, 0x3c, 0x2, 0x2, 0xd69, 0x181, 
       0x3, 0x2, 0x2, 0x2, 0xd6a, 0xd7a, 0x7, 0x1c9, 0x2, 0x2, 0xd6b, 0xd7a, 
       0x7, 0x1ca, 0x2, 0x2, 0xd6c, 0xd7a, 0x7, 0x1cb, 0x2, 0x2, 0xd6d, 
       0xd6e, 0x7, 0x1cb, 0x2, 0x2, 0xd6e, 0xd7a, 0x7, 0x1c9, 0x2, 0x2, 
       0xd6f, 0xd70, 0x7, 0x1ca, 0x2, 0x2, 0xd70, 0xd7a, 0x7, 0x1c9, 0x2, 
       0x2, 0xd71, 0xd72, 0x7, 0x1cb, 0x2, 0x2, 0xd72, 0xd7a, 0x7, 0x1ca, 
       0x2, 0x2, 0xd73, 0xd74, 0x7, 0x1cc, 0x2, 0x2, 0xd74, 0xd7a, 0x7, 
       0x1c9, 0x2, 0x2, 0xd75, 0xd76, 0x7, 0x1cc, 0x2, 0x2, 0xd76, 0xd7a, 
       0x7, 0x1ca, 0x2, 0x2, 0xd77, 0xd78, 0x7, 0x1cc, 0x2, 0x2, 0xd78, 
       0xd7a, 0x7, 0x1cb, 0x2, 0x2, 0xd79, 0xd6a, 0x3, 0x2, 0x2, 0x2, 0xd79, 
       0xd6b, 0x3, 0x2, 0x2, 0x2, 0xd79, 0xd6c, 0x3, 0x2, 0x2, 0x2, 0xd79, 
       0xd6d, 0x3, 0x2, 0x2, 0x2, 0xd79, 0xd6f, 0x3, 0x2, 0x2, 0x2, 0xd79, 
       0xd71, 0x3, 0x2, 0x2, 0x2, 0xd79, 0xd73, 0x3, 0x2, 0x2, 0x2, 0xd79, 
       0xd75, 0x3, 0x2, 0x2, 0x2, 0xd79, 0xd77, 0x3, 0x2, 0x2, 0x2, 0xd7a, 
       0x183, 0x3, 0x2, 0x2, 0x2, 0xd7b, 0xd7c, 0x9, 0x3d, 0x2, 0x2, 0xd7c, 
       0x185, 0x3, 0x2, 0x2, 0x2, 0xd7d, 0xd7f, 0x7, 0x1c3, 0x2, 0x2, 0xd7e, 
       0xd80, 0x9, 0x3e, 0x2, 0x2, 0xd7f, 0xd7e, 0x3, 0x2, 0x2, 0x2, 0xd7f, 
       0xd80, 0x3, 0x2, 0x2, 0x2, 0xd80, 0x187, 0x3, 0x2, 0x2, 0x2, 0xd81, 
       0xd84, 0x7, 0x26, 0x2, 0x2, 0xd82, 0xd83, 0x7, 0x80, 0x2, 0x2, 0xd83, 
       0xd85, 0x7, 0x5, 0x2, 0x2, 0xd84, 0xd82, 0x3, 0x2, 0x2, 0x2, 0xd84, 
       0xd85, 0x3, 0x2, 0x2, 0x2, 0xd85, 0xd88, 0x3, 0x2, 0x2, 0x2, 0xd86, 
       0xd88, 0x7, 0x5, 0x2, 0x2, 0xd87, 0xd81, 0x3, 0x2, 0x2, 0x2, 0xd87, 
       0xd86, 0x3, 0x2, 0x2, 0x2, 0xd88, 0xd89, 0x3, 0x2, 0x2, 0x2, 0xd89, 
       0xd8a, 0x9, 0x3f, 0x2, 0x2, 0xd8a, 0xd8d, 0x5, 0x166, 0xb4, 0x2, 
       0xd8b, 0xd8c, 0x7, 0x1dd, 0x2, 0x2, 0xd8c, 0xd8e, 0x7, 0x1c3, 0x2, 
       0x2, 0xd8d, 0xd8b, 0x3, 0x2, 0x2, 0x2, 0xd8d, 0xd8e, 0x3, 0x2, 0x2, 
       0x2, 0xd8e, 0xd9d, 0x3, 0x2, 0x2, 0x2, 0xd8f, 0xd91, 0x7, 0x1da, 
       0x2, 0x2, 0xd90, 0xd8f, 0x3, 0x2, 0x2, 0x2, 0xd90, 0xd91, 0x3, 0x2, 
       0x2, 0x2, 0xd91, 0xd92, 0x3, 0x2, 0x2, 0x2, 0xd92, 0xd97, 0x5, 0x192, 
       0xca, 0x2, 0xd93, 0xd94, 0x7, 0x1dc, 0x2, 0x2, 0xd94, 0xd96, 0x5, 
       0x192, 0xca, 0x2, 0xd95, 0xd93, 0x3, 0x2, 0x2, 0x2, 0xd96, 0xd99, 
       0x3, 0x2, 0x2, 0x2, 0xd97, 0xd95, 0x3, 0x2, 0x2, 0x2, 0xd97, 0xd98, 
       0x3, 0x2, 0x2, 0x2, 0xd98, 0xd9b, 0x3, 0x2, 0x2, 0x2, 0xd99, 0xd97, 
       0x3, 0x2, 0x2, 0x2, 0xd9a, 0xd9c, 0x7, 0x1db, 0x2, 0x2, 0xd9b, 0xd9a, 
       0x3, 0x2, 0x2, 0x2, 0xd9b, 0xd9c, 0x3, 0x2, 0x2, 0x2, 0xd9c, 0xd9e, 
       0x3, 0x2, 0x2, 0x2, 0xd9d, 0xd90, 0x3, 0x2, 0x2, 0x2, 0xd9d, 0xd9e, 
       0x3, 0x2, 0x2, 0x2, 0xd9e, 0xda8, 0x3, 0x2, 0x2, 0x2, 0xd9f, 0xda0, 
       0x7, 0xcd, 0x2, 0x2, 0xda0, 0xda5, 0x5, 0x194, 0xcb, 0x2, 0xda1, 
       0xda2, 0x7, 0x1dc, 0x2, 0x2, 0xda2, 0xda4, 0x5, 0x194, 0xcb, 0x2, 
       0xda3, 0xda1, 0x3, 0x2, 0x2, 0x2, 0xda4, 0xda7, 0x3, 0x2, 0x2, 0x2, 
       0xda5, 0xda3, 0x3, 0x2, 0x2, 0x2, 0xda5, 0xda6, 0x3, 0x2, 0x2, 0x2, 
       0xda6, 0xda9, 0x3, 0x2, 0x2, 0x2, 0xda7, 0xda5, 0x3, 0x2, 0x2, 0x2, 
       0xda8, 0xd9f, 0x3, 0x2, 0x2, 0x2, 0xda8, 0xda9, 0x3, 0x2, 0x2, 0x2, 
       0xda9, 0xdac, 0x3, 0x2, 0x2, 0x2, 0xdaa, 0xdab, 0x7, 0x4a, 0x2, 0x2, 
       0xdab, 0xdad, 0x7, 0x93, 0x2, 0x2, 0xdac, 0xdaa, 0x3, 0x2, 0x2, 0x2, 
       0xdac, 0xdad, 0x3, 0x2, 0x2, 0x2, 0xdad, 0xdae, 0x3, 0x2, 0x2, 0x2, 
       0xdae, 0xdaf, 0x7, 0x8, 0x2, 0x2, 0xdaf, 0xdb0, 0x5, 0x6, 0x4, 0x2, 
       0xdb0, 0x189, 0x3, 0x2, 0x2, 0x2, 0xdb1, 0xdb4, 0x7, 0x26, 0x2, 0x2, 
       0xdb2, 0xdb3, 0x7, 0x80, 0x2, 0x2, 0xdb3, 0xdb5, 0x7, 0x5, 0x2, 0x2, 
       0xdb4, 0xdb2, 0x3, 0x2, 0x2, 0x2, 0xdb4, 0xdb5, 0x3, 0x2, 0x2, 0x2, 
       0xdb5, 0xdb8, 0x3, 0x2, 0x2, 0x2, 0xdb6, 0xdb8, 0x7, 0x5, 0x2, 0x2, 
       0xdb7, 0xdb1, 0x3, 0x2, 0x2, 0x2, 0xdb7, 0xdb6, 0x3, 0x2, 0x2, 0x2, 
       0xdb8, 0xdb9, 0x3, 0x2, 0x2, 0x2, 0xdb9, 0xdba, 0x7, 0x51, 0x2, 0x2, 
       0xdba, 0xdc8, 0x5, 0x166, 0xb4, 0x2, 0xdbb, 0xdbc, 0x7, 0x1da, 0x2, 
       0x2, 0xdbc, 0xdc1, 0x5, 0x192, 0xca, 0x2, 0xdbd, 0xdbe, 0x7, 0x1dc, 
       0x2, 0x2, 0xdbe, 0xdc0, 0x5, 0x192, 0xca, 0x2, 0xdbf, 0xdbd, 0x3, 
       0x2, 0x2, 0x2, 0xdc0, 0xdc3, 0x3, 0x2, 0x2, 0x2, 0xdc1, 0xdbf, 0x3, 
       0x2, 0x2, 0x2, 0xdc1, 0xdc2, 0x3, 0x2, 0x2, 0x2, 0xdc2, 0xdc4, 0x3, 
       0x2, 0x2, 0x2, 0xdc3, 0xdc1, 0x3, 0x2, 0x2, 0x2, 0xdc4, 0xdc5, 0x7, 
       0x1db, 0x2, 0x2, 0xdc5, 0xdc9, 0x3, 0x2, 0x2, 0x2, 0xdc6, 0xdc7, 
       0x7, 0x1da, 0x2, 0x2, 0xdc7, 0xdc9, 0x7, 0x1db, 0x2, 0x2, 0xdc8, 
       0xdbb, 0x3, 0x2, 0x2, 0x2, 0xdc8, 0xdc6, 0x3, 0x2, 0x2, 0x2, 0xdc9, 
       0xdcd, 0x3, 0x2, 0x2, 0x2, 0xdca, 0xdce, 0x5, 0x18c, 0xc7, 0x2, 0xdcb, 
       0xdce, 0x5, 0x18e, 0xc8, 0x2, 0xdcc, 0xdce, 0x5, 0x190, 0xc9, 0x2, 
       0xdcd, 0xdca, 0x3, 0x2, 0x2, 0x2, 0xdcd, 0xdcb, 0x3, 0x2, 0x2, 0x2, 
       0xdcd, 0xdcc, 0x3, 0x2, 0x2, 0x2, 0xdce, 0xdd0, 0x3, 0x2, 0x2, 0x2, 
       0xdcf, 0xdd1, 0x7, 0x1dd, 0x2, 0x2, 0xdd0, 0xdcf, 0x3, 0x2, 0x2, 
       0x2, 0xdd0, 0xdd1, 0x3, 0x2, 0x2, 0x2, 0xdd1, 0x18b, 0x3, 0x2, 0x2, 
       0x2, 0xdd2, 0xdd3, 0x7, 0x97, 0x2, 0x2, 0xdd3, 0xddd, 0x7, 0xb0, 
       0x2, 0x2, 0xdd4, 0xdd5, 0x7, 0xcd, 0x2, 0x2, 0xdd5, 0xdda, 0x5, 0x196, 
       0xcc, 0x2, 0xdd6, 0xdd7, 0x7, 0x1dc, 0x2, 0x2, 0xdd7, 0xdd9, 0x5, 
       0x196, 0xcc, 0x2, 0xdd8, 0xdd6, 0x3, 0x2, 0x2, 0x2, 0xdd9, 0xddc, 
       0x3, 0x2, 0x2, 0x2, 0xdda, 0xdd8, 0x3, 0x2, 0x2, 0x2, 0xdda, 0xddb, 
       0x3, 0x2, 0x2, 0x2, 0xddb, 0xdde, 0x3, 0x2, 0x2, 0x2, 0xddc, 0xdda, 
       0x3, 0x2, 0x2, 0x2, 0xddd, 0xdd4, 0x3, 0x2, 0x2, 0x2, 0xddd, 0xdde, 
       0x3, 0x2, 0x2, 0x2, 0xdde, 0xde0, 0x3, 0x2, 0x2, 0x2, 0xddf, 0xde1, 
       0x7, 0x8, 0x2, 0x2, 0xde0, 0xddf, 0x3, 0x2, 0x2, 0x2, 0xde0, 0xde1, 
       0x3, 0x2, 0x2, 0x2, 0xde1, 0xde2, 0x3, 0x2, 0x2, 0x2, 0xde2, 0xde8, 
       0x7, 0x96, 0x2, 0x2, 0xde3, 0xde4, 0x7, 0x1da, 0x2, 0x2, 0xde4, 0xde5, 
       0x5, 0x36, 0x1c, 0x2, 0xde5, 0xde6, 0x7, 0x1db, 0x2, 0x2, 0xde6, 
       0xde9, 0x3, 0x2, 0x2, 0x2, 0xde7, 0xde9, 0x5, 0x36, 0x1c, 0x2, 0xde8, 
       0xde3, 0x3, 0x2, 0x2, 0x2, 0xde8, 0xde7, 0x3, 0x2, 0x2, 0x2, 0xde9, 
       0x18d, 0x3, 0x2, 0x2, 0x2, 0xdea, 0xdeb, 0x7, 0x97, 0x2, 0x2, 0xdeb, 
       0xdec, 0x7, 0x1c2, 0x2, 0x2, 0xdec, 0xdf6, 0x5, 0xb6, 0x5c, 0x2, 
       0xded, 0xdee, 0x7, 0xcd, 0x2, 0x2, 0xdee, 0xdf3, 0x5, 0x196, 0xcc, 
       0x2, 0xdef, 0xdf0, 0x7, 0x1dc, 0x2, 0x2, 0xdf0, 0xdf2, 0x5, 0x196, 
       0xcc, 0x2, 0xdf1, 0xdef, 0x3, 0x2, 0x2, 0x2, 0xdf2, 0xdf5, 0x3, 0x2, 
       0x2, 0x2, 0xdf3, 0xdf1, 0x3, 0x2, 0x2, 0x2, 0xdf3, 0xdf4, 0x3, 0x2, 
       0x2, 0x2, 0xdf4, 0xdf7, 0x3, 0x2, 0x2, 0x2, 0xdf5, 0xdf3, 0x3, 0x2, 
       0x2, 0x2, 0xdf6, 0xded, 0x3, 0x2, 0x2, 0x2, 0xdf6, 0xdf7, 0x3, 0x2, 
       0x2, 0x2, 0xdf7, 0xdf9, 0x3, 0x2, 0x2, 0x2, 0xdf8, 0xdfa, 0x7, 0x8, 
       0x2, 0x2, 0xdf9, 0xdf8, 0x3, 0x2, 0x2, 0x2, 0xdf9, 0xdfa, 0x3, 0x2, 
       0x2, 0x2, 0xdfa, 0xdfb, 0x3, 0x2, 0x2, 0x2, 0xdfb, 0xdff, 0x7, 0xc, 
       0x2, 0x2, 0xdfc, 0xdfe, 0x5, 0x8, 0x5, 0x2, 0xdfd, 0xdfc, 0x3, 0x2, 
       0x2, 0x2, 0xdfe, 0xe01, 0x3, 0x2, 0x2, 0x2, 0xdff, 0xdfd, 0x3, 0x2, 
       0x2, 0x2, 0xdff, 0xe00, 0x3, 0x2, 0x2, 0x2, 0xe00, 0xe02, 0x3, 0x2, 
       0x2, 0x2, 0xe01, 0xdff, 0x3, 0x2, 0x2, 0x2, 0xe02, 0xe04, 0x7, 0x96, 
       0x2, 0x2, 0xe03, 0xe05, 0x7, 0x1dd, 0x2, 0x2, 0xe04, 0xe03, 0x3, 
       0x2, 0x2, 0x2, 0xe04, 0xe05, 0x3, 0x2, 0x2, 0x2, 0xe05, 0xe06, 0x3, 
       0x2, 0x2, 0x2, 0xe06, 0xe08, 0x7, 0x3d, 0x2, 0x2, 0xe07, 0xe09, 0x7, 
       0x1dd, 0x2, 0x2, 0xe08, 0xe07, 0x3, 0x2, 0x2, 0x2, 0xe08, 0xe09, 
       0x3, 0x2, 0x2, 0x2, 0xe09, 0x18f, 0x3, 0x2, 0x2, 0x2, 0xe0a, 0xe0b, 
       0x7, 0x97, 0x2, 0x2, 0xe0b, 0xe15, 0x5, 0x19c, 0xcf, 0x2, 0xe0c, 
       0xe0d, 0x7, 0xcd, 0x2, 0x2, 0xe0d, 0xe12, 0x5, 0x196, 0xcc, 0x2, 
       0xe0e, 0xe0f, 0x7, 0x1dc, 0x2, 0x2, 0xe0f, 0xe11, 0x5, 0x196, 0xcc, 
       0x2, 0xe10, 0xe0e, 0x3, 0x2, 0x2, 0x2, 0xe11, 0xe14, 0x3, 0x2, 0x2, 
       0x2, 0xe12, 0xe10, 0x3, 0x2, 0x2, 0x2, 0xe12, 0xe13, 0x3, 0x2, 0x2, 
       0x2, 0xe13, 0xe16, 0x3, 0x2, 0x2, 0x2, 0xe14, 0xe12, 0x3, 0x2, 0x2, 
       0x2, 0xe15, 0xe0c, 0x3, 0x2, 0x2, 0x2, 0xe15, 0xe16, 0x3, 0x2, 0x2, 
       0x2, 0xe16, 0xe18, 0x3, 0x2, 0x2, 0x2, 0xe17, 0xe19, 0x7, 0x8, 0x2, 
       0x2, 0xe18, 0xe17, 0x3, 0x2, 0x2, 0x2, 0xe18, 0xe19, 0x3, 0x2, 0x2, 
       0x2, 0xe19, 0xe1a, 0x3, 0x2, 0x2, 0x2, 0xe1a, 0xe1e, 0x7, 0xc, 0x2, 
       0x2, 0xe1b, 0xe1d, 0x5, 0x8, 0x5, 0x2, 0xe1c, 0xe1b, 0x3, 0x2, 0x2, 
       0x2, 0xe1d, 0xe20, 0x3, 0x2, 0x2, 0x2, 0xe1e, 0xe1c, 0x3, 0x2, 0x2, 
       0x2, 0xe1e, 0xe1f, 0x3, 0x2, 0x2, 0x2, 0xe1f, 0xe21, 0x3, 0x2, 0x2, 
       0x2, 0xe20, 0xe1e, 0x3, 0x2, 0x2, 0x2, 0xe21, 0xe22, 0x7, 0x96, 0x2, 
       0x2, 0xe22, 0xe24, 0x5, 0xd0, 0x69, 0x2, 0xe23, 0xe25, 0x7, 0x1dd, 
       0x2, 0x2, 0xe24, 0xe23, 0x3, 0x2, 0x2, 0x2, 0xe24, 0xe25, 0x3, 0x2, 
       0x2, 0x2, 0xe25, 0xe26, 0x3, 0x2, 0x2, 0x2, 0xe26, 0xe27, 0x7, 0x3d, 
       0x2, 0x2, 0xe27, 0x191, 0x3, 0x2, 0x2, 0x2, 0xe28, 0xe2c, 0x7, 0x1c2, 
       0x2, 0x2, 0xe29, 0xe2a, 0x5, 0x17e, 0xc0, 0x2, 0xe2a, 0xe2b, 0x7, 
       0x1d5, 0x2, 0x2, 0xe2b, 0xe2d, 0x3, 0x2, 0x2, 0x2, 0xe2c, 0xe29, 
       0x3, 0x2, 0x2, 0x2, 0xe2c, 0xe2d, 0x3, 0x2, 0x2, 0x2, 0xe2d, 0xe2f, 
       0x3, 0x2, 0x2, 0x2, 0xe2e, 0xe30, 0x7, 0x8, 0x2, 0x2, 0xe2f, 0xe2e, 
       0x3, 0x2, 0x2, 0x2, 0xe2f, 0xe30, 0x3, 0x2, 0x2, 0x2, 0xe30, 0xe31, 
       0x3, 0x2, 0x2, 0x2, 0xe31, 0xe33, 0x5, 0x19c, 0xcf, 0x2, 0xe32, 0xe34, 
       0x7, 0xc7, 0x2, 0x2, 0xe33, 0xe32, 0x3, 0x2, 0x2, 0x2, 0xe33, 0xe34, 
       0x3, 0x2, 0x2, 0x2, 0xe34, 0xe37, 0x3, 0x2, 0x2, 0x2, 0xe35, 0xe36, 
       0x7, 0x1c9, 0x2, 0x2, 0xe36, 0xe38, 0x5, 0x178, 0xbd, 0x2, 0xe37, 
       0xe35, 0x3, 0x2, 0x2, 0x2, 0xe37, 0xe38, 0x3, 0x2, 0x2, 0x2, 0xe38, 
       0xe3a, 0x3, 0x2, 0x2, 0x2, 0xe39, 0xe3b, 0x9, 0x40, 0x2, 0x2, 0xe3a, 
       0xe39, 0x3, 0x2, 0x2, 0x2, 0xe3a, 0xe3b, 0x3, 0x2, 0x2, 0x2, 0xe3b, 
       0x193, 0x3, 0x2, 0x2, 0x2, 0xe3c, 0xe40, 0x7, 0x112, 0x2, 0x2, 0xe3d, 
       0xe40, 0x7, 0x177, 0x2, 0x2, 0xe3e, 0xe40, 0x5, 0xb2, 0x5a, 0x2, 
       0xe3f, 0xe3c, 0x3, 0x2, 0x2, 0x2, 0xe3f, 0xe3d, 0x3, 0x2, 0x2, 0x2, 
       0xe3f, 0xe3e, 0x3, 0x2, 0x2, 0x2, 0xe40, 0x195, 0x3, 0x2, 0x2, 0x2, 
       0xe41, 0xe4e, 0x7, 0x112, 0x2, 0x2, 0xe42, 0xe4e, 0x7, 0x187, 0x2, 
       0x2, 0xe43, 0xe44, 0x7, 0x97, 0x2, 0x2, 0xe44, 0xe45, 0x7, 0x73, 
       0x2, 0x2, 0xe45, 0xe46, 0x7, 0x79, 0x2, 0x2, 0xe46, 0xe47, 0x7, 0x73, 
       0x2, 0x2, 0xe47, 0xe4e, 0x7, 0x130, 0x2, 0x2, 0xe48, 0xe49, 0x7, 
       0x12, 0x2, 0x2, 0xe49, 0xe4a, 0x7, 0x79, 0x2, 0x2, 0xe4a, 0xe4b, 
       0x7, 0x73, 0x2, 0x2, 0xe4b, 0xe4e, 0x7, 0x130, 0x2, 0x2, 0xe4c, 0xe4e, 
       0x5, 0xb2, 0x5a, 0x2, 0xe4d, 0xe41, 0x3, 0x2, 0x2, 0x2, 0xe4d, 0xe42, 
       0x3, 0x2, 0x2, 0x2, 0xe4d, 0xe43, 0x3, 0x2, 0x2, 0x2, 0xe4d, 0xe48, 
       0x3, 0x2, 0x2, 0x2, 0xe4d, 0xe4c, 0x3, 0x2, 0x2, 0x2, 0xe4e, 0x197, 
       0x3, 0x2, 0x2, 0x2, 0xe4f, 0xe50, 0x7, 0x16a, 0x2, 0x2, 0xe50, 0xe51, 
       0x7, 0x1da, 0x2, 0x2, 0xe51, 0xe52, 0x5, 0xd0, 0x69, 0x2, 0xe52, 
       0xe53, 0x7, 0x1db, 0x2, 0x2, 0xe53, 0xe54, 0x7, 0xce, 0x2, 0x2, 0xe54, 
       0xe55, 0x7, 0x54, 0x2, 0x2, 0xe55, 0xe56, 0x7, 0x1da, 0x2, 0x2, 0xe56, 
       0xe57, 0x5, 0xf6, 0x7c, 0x2, 0xe57, 0xe58, 0x7, 0x1db, 0x2, 0x2, 
       0xe58, 0xe59, 0x5, 0x14a, 0xa6, 0x2, 0xe59, 0x199, 0x3, 0x2, 0x2, 
       0x2, 0xe5a, 0xe5b, 0x7, 0x19a, 0x2, 0x2, 0xe5b, 0xe5c, 0x7, 0x1da, 
       0x2, 0x2, 0xe5c, 0xe5d, 0x5, 0xd0, 0x69, 0x2, 0xe5d, 0xe5e, 0x7, 
       0x1dc, 0x2, 0x2, 0xe5e, 0xe5f, 0x5, 0xd0, 0x69, 0x2, 0xe5f, 0xe60, 
       0x7, 0x1db, 0x2, 0x2, 0xe60, 0xe61, 0x7, 0xce, 0x2, 0x2, 0xe61, 0xe62, 
       0x7, 0x54, 0x2, 0x2, 0xe62, 0xe63, 0x7, 0x1da, 0x2, 0x2, 0xe63, 0xe64, 
       0x5, 0xf6, 0x7c, 0x2, 0xe64, 0xe65, 0x7, 0x1db, 0x2, 0x2, 0xe65, 
       0x19b, 0x3, 0x2, 0x2, 0x2, 0xe66, 0xe68, 0x5, 0x17e, 0xc0, 0x2, 0xe67, 
       0xe69, 0x7, 0x56, 0x2, 0x2, 0xe68, 0xe67, 0x3, 0x2, 0x2, 0x2, 0xe68, 
       0xe69, 0x3, 0x2, 0x2, 0x2, 0xe69, 0xe71, 0x3, 0x2, 0x2, 0x2, 0xe6a, 
       0xe6b, 0x7, 0x1da, 0x2, 0x2, 0xe6b, 0xe6e, 0x9, 0x41, 0x2, 0x2, 0xe6c, 
       0xe6d, 0x7, 0x1dc, 0x2, 0x2, 0xe6d, 0xe6f, 0x7, 0x1c3, 0x2, 0x2, 
       0xe6e, 0xe6c, 0x3, 0x2, 0x2, 0x2, 0xe6e, 0xe6f, 0x3, 0x2, 0x2, 0x2, 
       0xe6f, 0xe70, 0x3, 0x2, 0x2, 0x2, 0xe70, 0xe72, 0x7, 0x1db, 0x2, 
       0x2, 0xe71, 0xe6a, 0x3, 0x2, 0x2, 0x2, 0xe71, 0xe72, 0x3, 0x2, 0x2, 
       0x2, 0xe72, 0xe81, 0x3, 0x2, 0x2, 0x2, 0xe73, 0xe81, 0x7, 0xfb, 0x2, 
       0x2, 0xe74, 0xe75, 0x7, 0x100, 0x2, 0x2, 0xe75, 0xe76, 0x7, 0x1da, 
       0x2, 0x2, 0xe76, 0xe77, 0x7, 0x1c3, 0x2, 0x2, 0xe77, 0xe81, 0x7, 
       0x1db, 0x2, 0x2, 0xe78, 0xe7a, 0x7, 0x39, 0x2, 0x2, 0xe79, 0xe7b, 
       0x7, 0x88, 0x2, 0x2, 0xe7a, 0xe79, 0x3, 0x2, 0x2, 0x2, 0xe7a, 0xe7b, 
       0x3, 0x2, 0x2, 0x2, 0xe7b, 0xe81, 0x3, 0x2, 0x2, 0x2, 0xe7c, 0xe81, 
       0x7, 0x131, 0x2, 0x2, 0xe7d, 0xe81, 0x7, 0x1a7, 0x2, 0x2, 0xe7e, 
       0xe81, 0x7, 0x193, 0x2, 0x2, 0xe7f, 0xe81, 0x7, 0xe4, 0x2, 0x2, 0xe80, 
       0xe66, 0x3, 0x2, 0x2, 0x2, 0xe80, 0xe73, 0x3, 0x2, 0x2, 0x2, 0xe80, 
       0xe74, 0x3, 0x2, 0x2, 0x2, 0xe80, 0xe78, 0x3, 0x2, 0x2, 0x2, 0xe80, 
       0xe7c, 0x3, 0x2, 0x2, 0x2, 0xe80, 0xe7d, 0x3, 0x2, 0x2, 0x2, 0xe80, 
       0xe7e, 0x3, 0x2, 0x2, 0x2, 0xe80, 0xe7f, 0x3, 0x2, 0x2, 0x2, 0xe81, 
       0x19d, 0x3, 0x2, 0x2, 0x2, 0x20a, 0x1a1, 0x1a7, 0x1ab, 0x1af, 0x1b3, 
       0x1bc, 0x1c2, 0x1d9, 0x1df, 0x1e8, 0x1ec, 0x1ef, 0x1f3, 0x1f7, 0x1fb, 
       0x200, 0x205, 0x207, 0x210, 0x213, 0x218, 0x21b, 0x21d, 0x221, 0x224, 
       0x22c, 0x22f, 0x234, 0x237, 0x23c, 0x241, 0x244, 0x249, 0x24f, 0x256, 
       0x25a, 0x25c, 0x261, 0x26e, 0x273, 0x27b, 0x27e, 0x282, 0x285, 0x289, 
       0x28c, 0x290, 0x293, 0x296, 0x299, 0x29c, 0x2a0, 0x2a5, 0x2a8, 0x2ac, 
       0x2af, 0x2b3, 0x2b6, 0x2ba, 0x2c0, 0x2c3, 0x2c7, 0x2ca, 0x2cd, 0x2d4, 
       0x2d7, 0x2db, 0x2de, 0x2e1, 0x2e4, 0x2e7, 0x2eb, 0x2ef, 0x2f2, 0x2fa, 
       0x2fe, 0x302, 0x305, 0x308, 0x30b, 0x30e, 0x315, 0x319, 0x31b, 0x323, 
       0x329, 0x32f, 0x331, 0x335, 0x338, 0x33b, 0x340, 0x345, 0x348, 0x350, 
       0x354, 0x35b, 0x35e, 0x367, 0x36a, 0x36e, 0x376, 0x379, 0x37d, 0x380, 
       0x389, 0x390, 0x394, 0x398, 0x39b, 0x39f, 0x3a2, 0x3b2, 0x3b6, 0x3bc, 
       0x3be, 0x3c1, 0x3c9, 0x3cf, 0x3d4, 0x3d7, 0x3dd, 0x3e5, 0x3ee, 0x3f6, 
       0x3f9, 0x400, 0x403, 0x42b, 0x42e, 0x434, 0x440, 0x442, 0x445, 0x45d, 
       0x468, 0x470, 0x47b, 0x480, 0x483, 0x48b, 0x495, 0x4af, 0x4b5, 0x4c0, 
       0x4d3, 0x4db, 0x4e2, 0x4f9, 0x506, 0x50c, 0x511, 0x514, 0x51a, 0x51e, 
       0x525, 0x52e, 0x532, 0x538, 0x53c, 0x53f, 0x545, 0x549, 0x54f, 0x556, 
       0x55a, 0x560, 0x564, 0x571, 0x577, 0x588, 0x58c, 0x594, 0x598, 0x5a0, 
       0x5a4, 0x5a6, 0x5aa, 0x5ae, 0x5b2, 0x5b6, 0x5bc, 0x5c0, 0x5c2, 0x5c7, 
       0x5cf, 0x5d2, 0x5d5, 0x5de, 0x5e3, 0x5e8, 0x5eb, 0x5ed, 0x5f1, 0x5f5, 
       0x5f8, 0x5fc, 0x602, 0x607, 0x60e, 0x610, 0x614, 0x61b, 0x61f, 0x622, 
       0x62b, 0x62e, 0x630, 0x639, 0x644, 0x648, 0x64a, 0x64c, 0x652, 0x657, 
       0x65e, 0x66b, 0x66d, 0x66f, 0x672, 0x675, 0x67c, 0x67f, 0x685, 0x68a, 
       0x68c, 0x68f, 0x695, 0x69d, 0x69f, 0x6a2, 0x6a6, 0x6a9, 0x6af, 0x6b2, 
       0x6b6, 0x6b9, 0x6bf, 0x6c2, 0x6c4, 0x6c8, 0x6cd, 0x6d5, 0x6da, 0x6e3, 
       0x6e8, 0x6ed, 0x6f3, 0x6f7, 0x6fa, 0x6fe, 0x704, 0x70c, 0x711, 0x713, 
       0x716, 0x71b, 0x720, 0x723, 0x728, 0x72b, 0x72e, 0x734, 0x73a, 0x73e, 
       0x743, 0x746, 0x74b, 0x750, 0x754, 0x759, 0x75d, 0x76e, 0x774, 0x77d, 
       0x787, 0x791, 0x793, 0x795, 0x798, 0x79b, 0x7a6, 0x7a8, 0x7aa, 0x7ad, 
       0x7b0, 0x7b3, 0x7b6, 0x7b9, 0x7bc, 0x7c8, 0x7cb, 0x7ce, 0x7d7, 0x7da, 
       0x7dd, 0x7e4, 0x7e7, 0x7f5, 0x7f8, 0x7ff, 0x80e, 0x812, 0x81f, 0x823, 
       0x82b, 0x82f, 0x843, 0x85a, 0x85c, 0x862, 0x869, 0x872, 0x87e, 0x885, 
       0x88c, 0x894, 0x89d, 0x8a1, 0x8ab, 0x8b2, 0x8be, 0x8c0, 0x8d7, 0x8e0, 
       0x8e6, 0x8ec, 0x8f2, 0x8fd, 0x905, 0x90d, 0x912, 0x916, 0x91f, 0x923, 
       0x926, 0x92b, 0x92f, 0x935, 0x937, 0x93b, 0x944, 0x947, 0x94a, 0x94e, 
       0x952, 0x95e, 0x96c, 0x971, 0x976, 0x97a, 0x981, 0x98a, 0x991, 0x993, 
       0x9a1, 0x9a9, 0x9ac, 0x9ae, 0x9b5, 0x9b9, 0x9c4, 0x9e6, 0x9f6, 0x9fc, 
       0xa03, 0xa09, 0xa0e, 0xa16, 0xa19, 0xa1b, 0xa22, 0xa2b, 0xa3c, 0xa3e, 
       0xa43, 0xa46, 0xa49, 0xa4d, 0xa52, 0xa54, 0xa58, 0xa5c, 0xa60, 0xa67, 
       0xa69, 0xa6b, 0xa6f, 0xa74, 0xa79, 0xa80, 0xa8d, 0xa91, 0xa93, 0xa96, 
       0xa9a, 0xaae, 0xab2, 0xab6, 0xac7, 0xace, 0xae5, 0xb30, 0xb34, 0xb50, 
       0xb72, 0xb76, 0xb83, 0xb8b, 0xb97, 0xb9d, 0xba6, 0xbb7, 0xbbd, 0xbc5, 
       0xbc9, 0xbd1, 0xbd8, 0xbe2, 0xbea, 0xc0a, 0xc10, 0xc15, 0xc1a, 0xc20, 
       0xc23, 0xc27, 0xc2c, 0xc3b, 0xc44, 0xc47, 0xc4a, 0xc57, 0xc5b, 0xc63, 
       0xc69, 0xc71, 0xc78, 0xc7e, 0xc8d, 0xc96, 0xc9c, 0xca2, 0xca5, 0xca9, 
       0xcb0, 0xcb8, 0xcbb, 0xcc1, 0xcc7, 0xcc9, 0xccf, 0xcd2, 0xcd4, 0xcda, 
       0xcdc, 0xcea, 0xcf1, 0xcf8, 0xcff, 0xd06, 0xd0d, 0xd14, 0xd1a, 0xd1f, 
       0xd28, 0xd2d, 0xd34, 0xd4a, 0xd4e, 0xd53, 0xd57, 0xd5b, 0xd5f, 0xd66, 
       0xd79, 0xd7f, 0xd84, 0xd87, 0xd8d, 0xd90, 0xd97, 0xd9b, 0xd9d, 0xda5, 
       0xda8, 0xdac, 0xdb4, 0xdb7, 0xdc1, 0xdc8, 0xdcd, 0xdd0, 0xdda, 0xddd, 
       0xde0, 0xde8, 0xdf3, 0xdf6, 0xdf9, 0xdff, 0xe04, 0xe08, 0xe12, 0xe15, 
       0xe18, 0xe1e, 0xe24, 0xe2c, 0xe2f, 0xe33, 0xe37, 0xe3a, 0xe3f, 0xe4d, 
       0xe68, 0xe6e, 0xe71, 0xe7a, 0xe80, 
  };

  _serializedATN.insert(_serializedATN.end(), serializedATNSegment0,
    serializedATNSegment0 + sizeof(serializedATNSegment0) / sizeof(serializedATNSegment0[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment1,
    serializedATNSegment1 + sizeof(serializedATNSegment1) / sizeof(serializedATNSegment1[0]));


  atn::ATNDeserializer deserializer;
  _atn = deserializer.deserialize(_serializedATN);

  size_t count = _atn.getNumberOfDecisions();
  _decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);
  }
}

tsqlParser::Initializer tsqlParser::_init;
