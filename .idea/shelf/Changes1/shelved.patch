Index: src/pytsql/tsql.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import logging\nimport re\nimport warnings\nfrom pathlib import Path\nfrom re import Match\nfrom typing import Any, Dict, List, Optional, Union\n\nimport antlr4.tree.Tree\nimport sqlalchemy\nfrom antlr4 import InputStream, Token\nfrom sqlalchemy.engine import Connection\n\nfrom pytsql.grammar import USE_CPP_IMPLEMENTATION, SA_ErrorListener, parse, tsqlParser\n\n_REPLACE_START = \"<replace>\"\n_REPLACE_END = \"</replace>\"\n_EOF = \"<EOF>\"\n_GO = \"GO\"\n_PRINTS_TABLE = \"#pytsql_prints\"\n\n\ndef _code(path: Union[str, Path], encoding: str) -> str:\n    with Path(path).open(encoding=encoding) as fh:\n        return \"\\n\".join(fh.readlines())\n\n\ndef _process_replacement(line: str, parameters: Dict[str, Any]) -> str:\n    \"\"\"Appropriately replace a single <replace> statement.\"\"\"\n    new_line = line.format(**parameters)\n    if None in parameters.values():\n        raise ValueError(\"Found a parameter with no specified replacement value.\")\n    if \"{\" and \"}\" in new_line:\n        raise ValueError(\n            \"There was a parameter that was not replaced. Double check the parameters dictionary.\"\n        )\n    return new_line\n\n\ndef _parametrize(\n    source: str,\n    parameters: Dict[str, Any],\n    start: str = _REPLACE_START,\n    end: str = _REPLACE_END,\n) -> str:\n    \"\"\"Replace all {start} and {end} statements, i.e. parametrizes the SQL script.\n\n    Parameters\n    ----------\n        source:     string containing the source SQL code\n        parameters: dictionary containing variables and their replacements\n    Returns\n    -------\n        the input source code, separated by newlines, with parameter replacements\n    \"\"\"\n\n    def parametrization_replacer(match: Match) -> str:\n        return _process_replacement(match.group(1), parameters)\n\n    # The pattern matches all parametrization patterns, including those within a string literal.\n    pattern = re.compile(\n        rf\"/\\* {re.escape(start)} \\*/.*?/\\* {re.escape(end)}(.*?) \\*/\",\n        re.DOTALL | re.MULTILINE,\n    )\n\n    parametrized = re.sub(pattern, parametrization_replacer, source)\n\n    non_empty_stripped_lines = [\n        x.strip() for x in parametrized.split(\"\\n\") if x.strip() != \"\"\n    ]\n\n    return \"\\n\".join(non_empty_stripped_lines)\n\n\nclass _TSQLVisitor(antlr4.ParseTreeVisitor):\n    def __init__(self):\n        # This attribute holds declarations of sql variables, also\n        # referred to as `dynamic sql`.\n        # In sql ides, these variables remain part of a session and\n        # can therefore be used in the entirety of a script.\n        # When executing code via sqlalchemy, on the other hand, this\n        # session information is lost after the execution of a batch.\n        # We therefore need to manually prepend it to all following\n        # batches.\n        self.dynamics: List[str] = []\n\n    def visit(\n        self, tree: tsqlParser.Sql_clauseContext, prepend_dynamics: bool = True\n    ) -> str:\n        dynamics = self.dynamics[:]\n\n        chunks = tree.accept(self)\n\n        # CREATE SCHEMA/VIEW must be the only statement in a batch\n        is_create_schema_or_view = tree.ddl_clause() is not None and (\n            tree.ddl_clause().create_schema() is not None\n            or tree.ddl_clause().create_view() is not None\n        )\n        if not prepend_dynamics or is_create_schema_or_view:\n            return \" \".join(chunks)\n\n        return \" \".join(dynamics + chunks)\n\n    def visitChildren(self, node: antlr4.ParserRuleContext) -> List[str]:\n        if isinstance(node, tsqlParser.Print_statementContext):\n            # Print statements are replaced by inserts into a temporary table so that they can be evaluated\n            # at the right time and fetched afterwards.\n            result = (\n                f\"INSERT INTO {_PRINTS_TABLE} VALUES ( LEFT (\".split()\n                + super().visitChildren(node.expression())\n                + \", 2000 ) ) ;\".split()\n            )\n        else:\n            result = super().visitChildren(node)\n\n        if isinstance(node, tsqlParser.Declare_statementContext):\n            self.dynamics.extend(result)\n\n        return result\n\n    def visitTerminal(self, node: antlr4.TerminalNode) -> List[str]:\n        return [str(node)]\n\n    def defaultResult(self) -> List[str]:\n        return []\n\n    def aggregateResult(\n        self, aggregate: List[str], next_result: List[str]\n    ) -> List[str]:\n        return aggregate + next_result\n\n\nclass _RaisingErrorListener(SA_ErrorListener):\n    def syntaxError(\n        self,\n        input_stream: InputStream,\n        offendingSymbol: Optional[Token],\n        char_index: int,\n        line: int,\n        column: int,\n        msg: str,\n    ):\n        error_message = f\"Line {line}:{column} {msg}.\"\n        if offendingSymbol is not None:\n            error_message += f\" Problem near token '{offendingSymbol.text}'.\"\n        logging.error(error_message)\n        raise ValueError(f\"Error parsing SQL script: {error_message}\")\n\n\ndef _split(code: str, isolate_top_level_statements: bool = True) -> List[str]:\n    if not USE_CPP_IMPLEMENTATION:\n        warnings.warn(\n            \"Can not find C++ version of the parser, Python version will be used instead.\"\n            \" Something is likely wrong with your installation of the package,\"\n            \" and is preventing the use of the faster C++ parser.\"\n        )\n\n    logging.info(\"Started SQL script parsing\")\n\n    # The default error listener only prints to the console without raising exceptions.\n    error_listener = _RaisingErrorListener()\n\n    # Using code created by `speedy-antlr-tool` to parse the input.\n    tree = parse(InputStream(data=code), \"tsql_file\", error_listener)\n    visitor = _TSQLVisitor()\n\n    # Our current definition of a 'batch' in isolation mode is a single top-level SQL clause.\n    # Note that this differs from the grammar definition of a batch, which is\n    # a group of clauses between GO statements. The latter matches the definition of batches\n    # in non-isolation mode.\n    batches = []\n    for batch in tree.batch():\n        clauses = []\n        first_clause_in_batch = True\n        for sql_clause in batch.sql_clauses().sql_clause():\n            prepend_dynamics = first_clause_in_batch or isolate_top_level_statements\n            clause = visitor.visit(sql_clause, prepend_dynamics=prepend_dynamics)\n            if clause != \"\":\n                clauses.append(clause)\n                first_clause_in_batch = False\n        if isolate_top_level_statements:\n            batches.extend(clauses)\n        else:\n            batches.append(\"\\n\".join(clauses))\n\n    logging.info(\"SQL script parsed successfully.\")\n\n    return batches\n\n\ndef _fetch_and_clear_prints(conn: Connection):\n    prints = conn.execute(f\"SELECT * FROM {_PRINTS_TABLE};\")\n    for row in prints.all():\n        logging.info(f\"Captured PRINT statement: {row[0]}\")\n    conn.execute(f\"DELETE FROM {_PRINTS_TABLE};\")\n\n\ndef executes(\n    code: str,\n    engine: sqlalchemy.engine.Engine,\n    parameters: Optional[Dict[str, Any]] = None,\n    isolate_top_level_statements=True,\n) -> None:\n    \"\"\"Execute a given sql string through a sqlalchemy.engine.Engine connection.\n\n    Please note either no parameters should be used or all parameters marked in a sql\n    script should be given.\n\n    Args\n    ----\n    code T-SQL string to be executed\n    engine (sqlalchemy.engine.Engine): established mssql connection\n    parameters An optional dictionary of parameters to substituted in the sql script\n    isolate_top_level_statements: whether to execute statements one by one or in whole batches\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    parametrized_code = _parametrize(code, parameters) if parameters else code\n    with engine.connect().execution_options(isolation_level=\"AUTOCOMMIT\") as conn:\n        # Since the prints table is a temporary one, it will be local to the connection and it will be dropped once the\n        # connection is closed. Caveat: sqlalchemy engines can pool connections, so we still have to drop it preemtively.\n        conn.execute(f\"DROP TABLE IF EXISTS {_PRINTS_TABLE}\")\n        conn.execute(f\"CREATE TABLE {_PRINTS_TABLE} (p NVARCHAR(4000))\")\n        for batch in _split(parametrized_code, isolate_top_level_statements):\n            conn.execute(batch)\n            _fetch_and_clear_prints(conn)\n\n\ndef execute(\n    path: Union[str, Path],\n    engine: sqlalchemy.engine.Engine,\n    parameters: Optional[Dict[str, Any]] = None,\n    isolate_top_level_statements=True,\n    encoding: str = \"utf-8\",\n) -> None:\n    \"\"\"Execute a given sql script through a sqlalchemy.engine.Engine connection.\n\n    Args\n    ----\n    path (Path or str): Path to the sql file to be executed\n    engine (sqlalchemy.engine.Engine): established mssql connection\n    encoding: file encoding of the sql script (default: utf-8)\n    isolate_top_level_statements: whether to execute statements one by one or in whole batches\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    executes(_code(path, encoding), engine, parameters, isolate_top_level_statements)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/pytsql/tsql.py b/src/pytsql/tsql.py
--- a/src/pytsql/tsql.py	(revision 6fdf20492630b2860cca2301e0ce4e9b764d4e50)
+++ b/src/pytsql/tsql.py	(date 1675867650070)
@@ -9,6 +9,7 @@
 import sqlalchemy
 from antlr4 import InputStream, Token
 from sqlalchemy.engine import Connection
+from sqlalchemy import text
 
 from pytsql.grammar import USE_CPP_IMPLEMENTATION, SA_ErrorListener, parse, tsqlParser
 
@@ -188,7 +189,7 @@
 
 
 def _fetch_and_clear_prints(conn: Connection):
-    prints = conn.execute(f"SELECT * FROM {_PRINTS_TABLE};")
+    prints = conn.execute(text(f"SELECT * FROM {_PRINTS_TABLE};"))
     for row in prints.all():
         logging.info(f"Captured PRINT statement: {row[0]}")
     conn.execute(f"DELETE FROM {_PRINTS_TABLE};")
@@ -221,10 +222,11 @@
     with engine.connect().execution_options(isolation_level="AUTOCOMMIT") as conn:
         # Since the prints table is a temporary one, it will be local to the connection and it will be dropped once the
         # connection is closed. Caveat: sqlalchemy engines can pool connections, so we still have to drop it preemtively.
-        conn.execute(f"DROP TABLE IF EXISTS {_PRINTS_TABLE}")
-        conn.execute(f"CREATE TABLE {_PRINTS_TABLE} (p NVARCHAR(4000))")
+        conn.execute(text(f"DROP TABLE IF EXISTS {_PRINTS_TABLE}"))
+        conn.execute(text(f"CREATE TABLE {_PRINTS_TABLE} (p NVARCHAR(4000))"))
         for batch in _split(parametrized_code, isolate_top_level_statements):
-            conn.execute(batch)
+            sql_batch = text(batch)
+            conn.ex(sql_batch)
             _fetch_and_clear_prints(conn)
 
 
